## 什么是字节对齐？
在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。
`为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”`。比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除。
对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而非标准数据类型按下面的原则对齐：
`数组` ：按照`基本数据类型`对齐，第一个对齐了后面的自然也就对齐了。 
`联合` ：按其包含的`长度最大的数据类型`对齐。 
`结构体`： 结构体中每个数据类型都要对齐。
  比如有如下一个结构体：
  struct stu{
    char sex;
    int length;
    char name[10];
  };
  struct stu my_stu;
由于在x86下，GCC默认按4字节对齐，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们sizeof(my_stu)会得到长度为20，而不是15。
 ![image](https://github.com/woojean/woojean.github.io/blob/master/images/img_4.png)

需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。

## 定义于类外部的成员函数的返回类型不一定在类作用域中
在定义于类外部的成员函数中，形参表和函数体处于类作用域中，函数返回类型不一定在类作用域中：与形参类型相比，返回类型出现在成员名字前面。如果函数在类定义体之外定义，则用于返回类型的名字在类作用域之外。如果返回类型使用由类定义的类型，则必须使用完全限定名：
```
class Screen {
public:
  typedef std::string::size_type index;
  index get_cursor() const;
};
     
inline Screen::index Screen::get_cursor() const{ // 常成员函数是不能改变成员变量值的函数
  return cursor;
}
```

## 什么是后期静态绑定？什么是转发调用？
用于在`继承范围内`引用静态调用的类。"后期绑定"的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。
例：使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于定义当前方法所在的类： 
class A {
  public static function who(){
    echo __CLASS__;
  }
  
  public static function test(){
    self::who();
  }
}

class B extends A {
  public static function who(){
    echo __CLASS__;
  }
}

B::test();
输出：A

如果换成static关键字：
class A {
  public static function who(){
    echo __CLASS__;
  }
 
  public static function test(){
    static::who(); // 后期静态绑定从这里开始
  }
}

class B extends A {
  public static function who(){
    echo __CLASS__;
  }
}

B::test();
输出：B

准确说，后期静态绑定工作原理是存储了在上一个"非转发调用"（non-forwarding call）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。
所谓的"转发调用"（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。

## 容器内元素的类型约束
C++ 语言中，大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：
1）元素类型必须`支持赋值运算`。
2）元素类型的`对象必须可以复制`。
此外，关联容器的键类型还需满足其他的约束。

## 有哪些成员必须在构造函数初始化列表中进行初始化？
对于这样的成员，在构造函数函数体中对它们赋值不起作用。`没有默认构造函数的类类型的成员，以及const或引用类型的成员`，不管是哪种类型，都必须在构造函数初始化列表中进行初始化。

## 变量在超出作用域时应该自动撤销
动态分配的对象只有在指向该对象的指针被删除时才撤销。`如果没有删除指向动态对象的指针，则不会运行该对象的析构函数，对象就一直存在，从而导致内存泄漏`，而且，对象内部使用的任何资源也不会释放。`当对象的引用或指针超出作用域时，不会运行析构函数`。只有删除指向动态分配对象的指针或实际对象（而不是对象的引用）超出作用域时，才会运行析构函数。

## 派生类型必须对想要重定义的每个继承成员进行声明，派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外
`返回对基类型的引用（或指针）的虚函数`。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。Item_base 类可以定义返回 Item_base* 的虚函数，如果这样，Bulk_item 类中定义的实例可以定义为返回 Item_base* 或 Bulk_item*。

## typedef int mytype[10]的作用
typedef int *p;
标识符p将被定义为了一个typedef name，这个typedef name表示一个类型，什么类型呢？就是int *p这个声明中标识符p的类型(int*)。

typedef double MYDOUBLE;  
分析:去掉typedef ，得到正常变量声明=> double MYDOUBLE;变量MYDOUBLE的类型为double;
MYDOUBLE d; // d是一个double类型的变量

typedef int* Func(int);
分析:去掉typedef  ，得到正常变量声明=> int* Func(int);
变量Func的类型为一个函数标识符，该函数返回值类型为int*，参数类型为int;
Func *fptr; // fptr是一个pointer to function with one int parameter, returning a pointer to int
Func f;   这样的声明意义就不大了。

typedef int (*PFunc)(int);
分析:去掉typedef，得到正常变量声明 int (*PFunc)(int);
变量PFunc的类型为一个函数指针，指向的返回值类型为int，参数类型为int的函数原型;

typedef int A[5];
分析:去掉typedef，得到正常变量声明int A[5];
变量A的类型为一个含有5个元素的整型数组；


## 如何避免同一头文件的多次include
`#ifndef … `或者 `#pragma once`
`#pragma once`是编译器相关的，就是说即使这个编译系统上有效，但在其他编译系统也不一定可以，不过现在基本上已经是每个编译器都有这个杂注了。
`#ifndef，#define，#endif`是C/C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式。


## C++中模板的编译过程
第一遍扫描到模板定义时将token流存入语法树中，不做其它操作
第二遍当模板被实例化时用模板实参代入进行运算，将所有的模板参数换为实参进行语法和语义分析
特别需要注意的是`类模板的成员函数只有在调用的时候才会被实例化`。

## new/delete与malloc/free之间的联系和区别
(1) malloc/free和new/delete的联系
  a）存储方式相同。malloc和new动态申请的内存都位于堆中。申请的内存都不能自动被操作系统收回，都需要配套的free和delete来释放。
  b）除了带有构造函数和析构函数的类等数据类型以外，对于一般数据类型，如int、char等等，两组动态申请的方式可以通用，作用效果一样，只是形式不一样。
  c）内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。
  d）两组都需要配对使用，malloc配free，new配delete，注意，这不仅仅是习惯问题，如果不配对使用，容易造成内存泄露。同时，在C++中，两组之间不能混着用，虽说有时能编译过，但容易存在较大的隐患。
(2) malloc/free和new/delete的区别
  a）malloc返回void类型指针，free的形参为void指针，new和delete直接带具体类型的指针。
  b）malloc和free属于C语言中的函数，需要库的支持，而new/delete是C++中的运算符，况且可以重载，所以new/delete的执行效率高些。C++中为了兼用C语法，所以保留malloc和free的使用，但建议尽量使用new和delete。
  c）在C++中， new是类型安全的，而malloc不是。例如：
　   int* p = new char[10];  // 编译时指出错误
      delete [] p;                                     //对数组需要加中括号“[]”
　   int* p = malloc(sizeof(char)*10);    // 编译时无法指出错误
    free (p);   //只需要所释放内存的头指针（free释放malloc分配的数组）。在malloc和free的面前没有对象没有数组，只有“内存块”。一次malloc分配的东西，一次free一定能回收。至于内存块的大小内存管理会进行记录，这应该是库函数的事。free的真正弊端在于它不会调用析构函数。

  d）使用new动态申请类对象的内存空间时，类对象的构建要调用构造函数，相当于对内存空间进行了初始化。而malloc动态申请的类对象的内存空间时，不会初始化，也就是说申请的内存空间无法使用，因为类的初始化是由构造函数完成的。delete和free的意义分别于new和malloc相反。
  e）不能用malloc和free来完成类对象的动态创建和删除。
另：
void *calloc(int n,int size);
函数返回值为void型指针。如果执行成功，函数从堆上获得size X n的字节空间，并返回该空间的首地址。如果执行失败，函数返回NULL。该函数与malloc函数的一个显著不同时是，calloc函数得到的内存空间是经过初始化的，其内容全为0。calloc函数适合为数组申请空间，可以将size设置为数组元素的空间长度，将n设置为数组的容量。

realloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能，其函数声明如下：
void * realloc(void * p,int n);
其中，指针p必须为指向堆内存空间的指针，即由malloc函数、calloc函数或realloc函数分配空间的指针。realloc函数将指针p指向的内存块的大小改变为n字节。如果n小于或等于p之前指向的空间大小，那么。保持原有状态不变。如果n大于原来p之前指向的空间大小，那么，系统将重新为p从堆上分配一块大小为n的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p之前指向的空间被释放。relloc函数分配的空间也是未初始化的。
注意：使用malloc函数，calloc函数和realloc函数分配的内存空间都要使用free函数或指针参数为NULL的realloc函数来释放。


## 使用 define 定义一年有多少毫秒
```
#define MS_OF_YEAR (365*24*60*60*1000)UL
```
（对于整数溢出的考虑）


## 指针的数组和指向数组的指针
int *p[5] 跟 int (*p)[5] 的区别，
前者定义了指针的数组，后者定义了指向数组的指针


## 可以声明一个类而不定义它：
class Screen; // declaration of the Screen class
这个声明，有时称为`前向声明`（forward declaraton），在程序中引入了类类型的Screen。在声明之后、定义之前，类 Screen 是一个`不完全类型`（incompete type），即已知 Screen 是一个类型，但不知道包含哪些成员。不完全类型（incomplete type）只能以有限方式使用。不能定义该类型的对象。不完全类型只能用于定义指向该类型的指针及引用，或者用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数。


## const引用是指向const对象的引用
const对象的引用只能是const引用，但是const引用也可用于非const对象。
```
  const int ival = 1024;
  const int &refVal = ival;   // ok: both reference and object are const
  int &ref2 = ival;           // error: 将普通的引用绑定到 const 对象是不合法的
```
可以读取但不能修改refVal ，因此，任何对 refVal 的赋值都是不合法的。这个限制有其意义：不能直接对 ival 赋值，因此不能通过使用 refVal 来修改 ival。
const 引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：
```
  int i = 42;
  // legal for const references only
  const int &r = 42;
  const int &r2 = r + i;
```

## 结构体大小如何判断？
偏移量：偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。
由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：
1.结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）
2.结构体大小必须是所有成员大小的整数倍。
此外：`结构体变量的首地址能够被其最宽基本类型成员的大小所整除`；
因此`不同的定义顺序会影响到结构体的大小`：
```
  struct s{
	  char c;
	  int i;
	  char cc;
  };  // 大小为12

  struct s{
	  char c;
	  char cc;
    int i;
  };  // 大小为8
```
当结构体中的成员又是另外一种结构体类型时，只需要把其展开，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。
附：基本数据类型所占字节数如下
类型                  字节
char                  	1
short int             	2
int                   	2(16bit)/4(32bit)/4(64bit)
long                  	4(16bit)/4(32bit)/8(64bit)
指针变量              	4
float                 	4
double                	8
long long             	8
long double           	10
各种数据类型所占字节长度，主要是int型,long型和指针数据类型的差异。
int型数据，如果是16bit平台,则是2个字节，如果是32bit的，则占4个字节,64bit仍然是4字节。
long型数据，如果是16bit平台,则是4个字节，如果是32bit的，则占4个字节,64bit仍然是8字节。
指针型数据，比较特殊，大多是4个字节，只有在16bit平台，并且指针式段内寻址时才是2个字节。
另外注意：sizeof(表达式)这样的使用，sizeof是给出其操作数所需要占用的内存大小，在编译时就可以确定。因此不需要去计算表达式的值；
因此有：
```
int i = 3;
cout << sizeof(i++) << endl;
cout << i << endl;
```
输出4,3。i++根本没有执行。
![image](https://github.com/woojean/woojean.github.io/blob/master/images/img_3.png)


## 虚函数和纯虚函数的区别是什么？
定义一个函数为虚函数，不代表函数为不被实现的函数，定义它为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为纯虚函数，才代表函数没有被实现，定义他是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 
`虚函数有实现，纯虚函数没有方法的实现`。包含纯虚函数的类将成为抽象类，不可实例化对象。纯虚函数必循在其子类中进行重写，不然其子类也成为抽象类。不能实例化对象。


## 在函数体内声明[1] char *str="abc";和[2] char str[]={'a','b','c'};有什么区别
[1][2]中str变量都分配在栈上
[1]中str指向常量存储区的字符串”abc”，其中字符串末尾会补0
[2]中str数组的内容存储于栈空间，数组大小为3，字符串不会补0

## 友元声明将已命名的类或非成员函数引入到外围作用域中
友元函数可以在类的内部定义，该函数的作用域扩展到包围该类定义的作用域。
```
class X {
  friend class Y;
  friend void f() { /* ok to define friend function in the class body */ }
};

class Z {
  Y *ymem; // ok: declaration for class Y introduced by friend in X
  void g() { return ::f(); } // ok: declaration of f introduced by X
};
```
附：友元是一种定义在类外部的普通函数或类，但它需要在类体内进行说明。友元不是该类的成员，但可以访问类中的私有成员。友元关系不具有对称性，也不具有传递性。

## 如果一对函数的区别仅在于是否将形参定义为 const，则仍为重复定义
值得注意的是，形参与const形参的等价性仅适用于非引用、非指针形参。有const引用形参的函数与有非const 引用形参的函数是不同的。类似地，如果函数带有指向const类型的指针形参，则与带有指向相同类型的非const对象的指针形参的函数不相同。

## 虚析构函数
删除指向动态分配对象的指针时，需要在释放对象的内存之前运行析构函数清除对象。处理继承层次中的对象时，指针的静态类型可能与被删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际是派生类型的，则没有定义该行为。`要保证运行适当的析构函数，基类中的析构函数必须为虚函数`：
```
class Item_base {
public:
  // no work, but virtual destructor needed
  // if base pointer that points to a derived object is ever deleted
  virtual ~Item_base() { }
};
```

## 复制初始化和直接初始化
C++支持两种初始化变量的形式：复制初始化和直接初始化。复制初始化语法用等号（=），直接初始化则是把初始化式放在括号中：
  int ival(1024);     // direct-initialization
  int ival = 1024;    // copy-initialization
对内置类型来说，复制初始化和直接初始化几乎没有差别。
内置类型变量是否自动初始化取决于变量定义的位置。`在函数体外定义的变量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化`。除了用作赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难于发现。建议每个内置类型的对象都要初始化。

## 使用数组初始化 vector对象
必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址：
```	
const size_t arr_size = 6;
int int_arr[arr_size] = {0, 1, 2, 3, 4, 5};
// ivec has 6 elements: each a copy of the corresponding element in int_arr
vector<int> ivec(int_arr, int_arr + arr_size);
```
被标出的元素范围可以是数组的子集：
vector<int> ivec(int_arr + 1, int_arr + 4);

## 通过运行时类型识别（RTTI），程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际派生类型。通过下面两个操作符提供 RTTI：
1）typeid 操作符，返回指针或引用所指对象的实际类型。
2）dynamic_cast 操作符，将基类类型的指针或引用安全地转换为派生类型的指针或引用。
这些操作符只为带有一个或多个虚函数的类返回动态类型信息，对于其他类型，返回静态（即编译时）类型的信息。对于带虚函数的类，在运行时执行 RTTI 操作符，但对于其他类型，在编译时计算 RTTI 操作符。
通常，从基类指针获得派生类行为最好的方法是通过虚函数。但是，在某些情况下，不可能使用虚函数。在这些情况下，RTTI 提供了可选的机制。然而，这种机制比使用虚函数更容易出错：程序员必须知道应该将对象强制转换为哪种类型，并且必须检查转换是否成功执行了。

## 标准 C++ 为了加强类型转换的可视性，引入命名的强制转换操作符
1）`dynamic_cast`支持运行时识别指针或引用所指向的对象。
2）`const_cast`将转换掉表达式的 const 性质。
	const char *pc_str;
  char *pc = string_copy(const_cast<char*>(pc_str));
只有使用const_cast才能将const性质转换掉。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了添加或删除 const 特性，用const_cast符来执行其他任何类型转换，都会引起编译错误。
3）static_cast：编译器隐式执行的任何类型转换都可以由static_cast显式完成
	void* p = &d; // ok: address of any data object can be stored in a void*
  // ok: converts void* back to the original pointer type
  double *dp = static_cast<double*>(p);
4）reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。
旧式强制类型转换：在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：
  char *pc = (char*) ip;
效果与使用 reinterpret_cast 符号相同，但这种强制转换的可视性比较差，难以跟踪错误的转换。

附：dynamic_cast<type-id>(expression)与 static_cast<type-id>(expression)的区别：
static_cast字面意思是静态转换，编译期间就能判断是否可以转换成功，但是无法识别兄弟指针之间的转换（先提升一个兄弟指针为父指针，再向下转换）而dynamic_cast是运行时转换，可以编译通过，但是可以与NULL指针的比较来判断是否转换成功！

## 使用 sizeof 的结果部分地依赖所涉及的类型
1）对 char 类型或值为 char 类型的表达式做 sizeof 操作保证得 1。
2）对引用类型做 sizeof 操作将返回存放被引用类型对象所需的内存空间大小。
3）对指针做 sizeof 操作将返回存放指针所需的内存大小；注意，如果要获取该指针所指向对象的大小，则必须对指针进行引用。
4）对数组做 sizeof 操作等效于将对其元素类型做 sizeof 操作的结果乘上数组元素的个数。
因为 sizeof 返回整个数组在内存中的存储长度，所以用 sizeof 数组的结果除以 sizeof 其元素类型的结果，即可求出数组元素的个数。

## free、delete、delete[]
delete汇编化是：
call destructor.
call delete(void*)->free+一些判断
 
free就是free

delete[]是
调相应数量的destructor，
delete(void*)
一般的内存泄露是来源于destructor少掉了时候。


## C++中把一个超出其取值范围的值赋给一个指定类型的对象
当把一个超出其取值范围的值赋给一个指定类型的对象时，编译器会将该值对该类型的可能取值数目求模，然后取所得值。比如8位的 unsigned char，其取值范围从0到255（包括 255）。如果赋给超出这个范围的值，那么编译器将会取该值对256求模后的值。例如，如果试图将336存储到8位的unsigned char中，则实际赋值为80，因为80是336对256求模后的值。
对于unsigned类型来说，负数总是超出其取值范围。unsigned类型的对象可能永远不会保存负数。有些语言中将负数赋给unsigned类型是非法的，但在 C++ 中这是合法的。其结果是该负数对该类型的取值个数求模后的值。所以，如果把-1赋给8位的unsigned char，那么结果是255，因为255是-1对256求模后的值。


## 向基类构造函数传递实参
派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员。但派生类构造函数可通过将基类包含在构造函数初始化列表中来间接初始化继承成员。
```
class Bulk_item : public Item_base {
public:
  Bulk_item(const std::string& book, double sales_price,std::size_t qty = 0, double disc_rate = 0.0):
    Item_base(book, sales_price), min_qty(qty), discount(disc_rate) { }
    // as before
};
这个构造函数使用有两个形参的Item_base 的构造函数初始化基类子对象，它将自己的 book 和 sales_price 实参传递给该构造函数。这个构造函数可以这样使用：
     Bulk_item bulk("0-201-82470-1", 50, 5, .19);
要建立 bulk，首先运行 Item_base 构造函数，该构造函数使用从 Bulk_item 构造函数初始化列表传来的实参初始化 isbn 和 price。Item_base 构造函数执行完毕之后，再初始化 Bulk_item 的成员。最后，运行 Bulk_item 构造函数的（空）函数体。


## 构造函数和析构函数中的虚函数
构造派生类对象时首先运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。撤销派生类对象时，首先撤销它的派生类部分，然后按照与构造顺序的逆序撤销它的基类部分。在这两种情况下，运行构造函数或析构函数的时候，对象都是不完整的。`为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象当作基类类型对象对待`。`如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本`。


## NDEBUG 预处理变量以及 assert 预处理宏
一个常见的调试技术是使用NDEBUG预处理变量以及assert预处理宏,assert宏是在cassert头文件中定义的。
assert 宏需要一个表达式作为它的条件：
assert(expr)
只要NDEBUG未定义，assert宏就求解条件表达式expr，如果结果为false，assert输出信息并且终止程序的执行。如果该表达式有一个非零（例如，true）值，则 assert 不做任何操作。
在测试过程中，assert等效于检验数据是否总是具有预期的大小。一旦开发和测试工作完成，程序就已经建立好，并且定义了NDEBUG。在成品代码中，assert 语句不做任何工作，因此也没有任何运行时代价。当然，也不会引起任何运行时检查。assert 仅用于检查确实不可能的条件，这只对程序的调试有帮助，但不能用来代替运行时的逻辑检查，也不能代替对程序可能产生的错误的检测。


## 指针和引用的比较
虽然使用引用（reference）和指针都可间接访问另一个值，但它们之间有两个重要区别。
第一个区别在于引用总是指向某个对象：`定义引用时没有初始化是错误的`。
第二个重要区别则是赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。引用一经初始化，就始终指向同一个特定对象（这就是为什么`引用必须在定义时初始化`的原因）。


## 数组的维数必须用值大于等于1的常量表达式定义
此常量表达式只能包含整型字面值常量、枚举常量或者用常量表达式初始化的整型const对象。非const变量以及要到运行阶段才知道其值的const 变量都不能用于定义数组的维数。
```	
  const unsigned buf_size = 512, max_files = 20;
  int staff_size = 27;             // nonconst
  const unsigned sz = get_size();  // const value not known until run time
  char input_buffer[buf_size];     // ok: const variable
  string fileTable[max_files + 1]; // ok: constant expression
  double salaries[staff_size];     // error: non const variable
  int test_scores[get_size()];     // error: non const expression
  int vals[sz];                    // error: size not known until run time
```	
虽然staff_size是用字面值常量进行初始化，但staff_size本身是一个非const 对象，只有在运行时才能获得它的值，因此，使用该变量来定义数组维数是非法的。而对于sz，尽管它是一个const对象，但它的值要到运行时调用get_size 函数后才知道，因此，它也不能用于定义数组维数。


## 如果形参是数组的引用，编译器不会将数组实参转化为指针，而是传递数组的引用本身
在这种情况下，`数组大小成为形参和实参类型的一部分`。编译器检查数组的实参的大小与形参的大小是否匹配：
void printValues(int (&arr)[10]) { /* ... */ }


## 用C++实现一个不能被继承的类
`将构造函数和析构函数声明为私有函数，该函数就不可被继承`。同时为了该类可以被实例化，在类中定义一个静态函数，返回初始化的一个类对象。


## define的一些注意点：
1）#define  SQR(x)   printf("Thesquareof x is%d.\n",((x)*(x)));
如果这样使用宏：
SQR(8);则输出为： The squareof x is 64.
注意，`引号中的字符x被当作普通文本来处理，而不被当作一个可以被替换的语言符号`。假如你确实希望在字符串中包含宏参数，那我们就可以使用“#”，它可以把语言符号转化为字符串。上面的例子改一改：
```
#define  SQR(x)   printf("The  squareof   "#x"   is%d.\n",((x)*(x)));
```
再使用：SQR(8);  则输出的是：  The  squareof   8   is  64.

2）求两个数的平方#define SQR(x)  x * x
假设x的值是个表达式10+1，SQR(x)被替换后变成10+1*10+1这并不是想要得到的怎么办括起来就好了  这样  #define SQR(x) （（x）*（x））
求两个数的和：#define SUM (x)（x）+（x）而代码又写成这样：SUM (x)* SUM (x)。替换后变成：（5*3）+（5*3）*（5*3）+（5*3）。所以又错了！所以最外层的括号最好也别省了
要搞定宏定义表达式其实很简单，别吝啬括号就行了。
注意这一点：宏函数被调用时是以实参代换形参。而不是“值传送”。

3）和#运算符一样，`##运算符可以用于宏函数的替换部分`。这个运算符把两个语言符号组合成单个语言符号。看例子： #define  XNAME(n)  x##n
如果这样使用宏：XNAME(8)   则会被展开成这样：  x8 
`##`就是个粘合剂，将前后两部分粘合起来。

## 可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换
```
class Sales_item {
public:
  // default argument for book is the empty string
  Sales_item(const std::string &book = ""):
    isbn(book), units_sold(0), revenue(0.0) { }
  
  Sales_item(std::istream &is);
  // as before
      };
```

## 确定函数调用遵循以下四个步骤
1)首先确定进行函数调用的对象、引用或指针的静态类型。
2)在该类中查找函数，如果找不到，就在直接基类中查找，如此循着类的继承链往上找，直到找到该函数或者查找完最后一个类。如果不能在类或其相关基类中找到该名字，则调用是错误的。
3)一旦找到了该名字，就进行常规类型检查，查看如果给定找到的定义，该函数调用是否合法。
4)假定函数调用合法，编译器就生成代码。如果函数是虚函数且通过引用或指针调用，则编译器生成代码以确定根据对象的动态类型运行哪个函数版本，否则，编译器生成代码直接调用函数


## NoDefault类没有默认构造函数
意味着：
1.具有 NoDefault 成员的每个类的每个构造函数，必须通过传递一个初始的 string 值给 NoDefault 构造函数来显式地初始化 NoDefault 成员。
2.编译器将不会为具有 NoDefault 类型成员的类合成默认构造函数。如果这样的类希望提供默认构造函数，就必须显式地定义，并且默认构造函数必须显式地初始化其 NoDefault 成员。
3.类型不能用作动态分配数组的元素类型。
4.类型的静态分配数组必须为每个元素提供一个显式的初始化式。
5.如果有一个保存 NoDefault 对象的容器，例如 vector，就不能使用接受容器大小而没有同时提供一个元素初始化式的构造函数。


## 为什么不建议让异常离开析构函数？（摘自编码规范）
程序抛出异常时候，会导致栈展开，局部对象依次析构。`如果析构过程中再次抛出异常，程序将会立即中止`。


## STL中的stable_sort()的时间复杂度是多少
stable_sort()使用的算法类似于自适应算法，当空间足够的时，时间复杂度是O(nlogn)；当空间比较紧张时，时间复杂度是O(nlogn*logn)


## 使用define定义max函数
```
#define MAX(a,b)  (a)>(b)?(a): (b)
```
（对于define中()使用的把握）
例：
```
#define TEST1 a+b
#define TEST2 (a+b)
void main(void)
{
    int a, b, c, d;
    c = TEST1;       //相当于 c = a+b;
    d = TEST2;       //相当于 d = (a+b);
}
```
这样写是防止忽略运算符优先级而导致的错误。


## define中为何经常会使用 do{...} while(0);来包装多条语句代码
do{...}while(0)的目的是为了在for循环和if语句时，避免出现下面的情况：
```
#define xxx  i++; i--;
for (I = 0 ; I < 10; I ++) xxx;
展开后变为
for ( I = 0 ; I < 10; I ++ ) I ++; I --;
(对define中do{}while(0)的理解)

## 试图用宏开始或结束一段注释是不行的
```
#define  BSC   //       
#define  BMC  /*    
#define  EMC  */
```
1) BSC my single-linecomment
2) BMC my multi-linecomment  EMC
1)和2)都错误，因为`注释先于预处理指令被处理`,当这两行被展开成//…或/*…*/时,注释已处理完毕此时再出现//…或/*…*/自然错误.


## std::vector实现原理及特定场景下的改进
1)说一下std::vector的实现原理，主要讲一下和内存管理相关的内容
2)常驻内存程序，一个std::vector的生命周期和程序生命周期相同，且会频繁的调用std::vector的push_back()和clear()方法，调用clear()方法时，vector.size()小于1万的概率为0.95,vector.size()可能出现的最大值为100万。如果程序中有多个这样的std::vector实例，程序长期运行后，会导致内存持续增长，一定时间后，可能将内存耗尽。请问，如何用较小的代价修改vector的设计，来避免内存持续增长问题。
答：
1)内存不够用时，双倍扩容。clear()时，不释放内存，以减少内存分配次数。
2)修改clear()方法，当vector.size() 大于1万时，释放内存。


## C++创建动态数组
每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。C语言程序使用一对标准库函数 malloc 和 free 在自由存储区中分配存储空间，而 C++ 语言则使用 new 和 delete 表达式实现相同的功能。
动态分配数组时，只需指定类型和数组长度，不必为数组对象命名，new 表达式返回指向新分配数组的第一个元素的指针：
	int *pia = new int[10]; // array of 10 uninitialized ints

动态分配数组时，如果数组元素具有类类型，将使用该类的默认构造函数实现初始化；如果数组元素是内置类型，则无初始化：
  string *psa = new string[10]; // array of 10 empty strings
  int *pia = new int[10];       // array of 10 uninitialized ints

圆括号要求编译器对数组做值初始化：也可使用跟在数组长度后面的一对空圆括号，对数组元素做值初始化， int *pia2 = new int[10] (); // array of 10 uninitialized ints
	
对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。

const 对象的动态数组（这样的数组实际上用处不大）：如果我们在自由存储区中创建的数组存储了内置类型的 const 对象，则必须为这个数组提供初始化：因为数组元素都是 const 对象，无法赋值。实现这个要求的唯一方法是对数组做值初始化：          
	const int *pci_bad = new const int[100]; // error: uninitialized const array
  const int *pci_ok = new const int[100](); // ok: value-initialized const array

C++ 允许定义类类型的 const 数组，但该类类型必须提供默认构造函数：
  const string *pcs = new const string[100];  // ok: array of 100 empty strings

C++ 虽然不允许定义长度为 0 的数组变量，但明确指出，调用 new 动态创建长度为 0 的数组是合法的：
	char arr[0];            // error: cannot define zero-length array
  char *cp = new char[0]; // ok: but cp can't be dereferenced

用 new 动态创建长度为 0 的数组时，new 返回有效的非零指针。该指针与 new 返回的其他指针不同，不能进行解引用操作，因为它毕竟没有指向任何元素。而允许的操作包括：比较运算，因此该指针能在循环中使用；在该指针上加（减）0；或者减去本身，得 0 值。
如果不再需要使用动态创建的数组，程序员必须显式地将其占用的存储空间返还给程序的自由存储区。C++ 语言为指针提供 delete [] 表达式释放指针所指向的数组空间：delete [] pia; 该语句回收了 pia 所指向的数组，把相应的内存返还给自由存储区。在关键字 delete 和指针之间的空方括号对是必不可少的：它告诉编译器该指针指向的是自由存储区中的数组，而并非单个对象。


## 虚继承
一个类继承多个直接基类的时候，那些类有可能本身还共享另一个基类。在这种情况下，`中间类可以选择使用虚继承，声明愿意与层次中虚继承同一基类的其他类共享虚基类`。用这种方法，后代派生类中将只有一个共享虚基类的副本。
istream 和 ostream 类对它们的基类进行虚继承。通过使基类成为虚基类，istream 和 ostream 指定，如果其他类（如 iostream 同时继承它们两个，则派生类中只出现它们的公共基类的一个副本。通过在派生列表中包含关键字 virtual 设置虚基类：
    class istream : public virtual ios { ... };
    class ostream : virtual public ios { ... };
    // iostream inherits only one copy of its ios base class
    class iostream: public istream, public ostream { ... };
即使基类是虚基类，也照常可以通过基类类型的指针或引用操纵派生类的对象。


## 虚基类成员的可见性
假定通过多个派生路径继承名为 X 的成员，有下面三种可能性：
	1）如果在每个路径中 X 表示同一虚基类成员，则没有二义性，因为共享该成员的单个实例。
	2）如果在某个路径中 X 是虚基类的成员，而在另一路径中 X 是后代派生类的成员，也没有二义性——特定派生类实例的优先级高于共享虚基类实例。
	3）如果沿每个继承路径 X 表示后代派生类的不同成员，则该成员的直接访问是二义性的。
像非虚多重继承层次一样，这种二义性最好用在派生类中提供覆盖实例的类来解决。
特殊的初始化语义：通常，每个类只初始化自己的直接基类。如果使用常规规则，就可能会多次初始化虚基类。类将沿着包含该虚基类的每个继承路径初始化。为了解决这个重复初始化问题，从具有虚基类的类继承的类对初始化进行特殊处理。在虚派生中，由最低层派生类的构造函数初始化虚基类。虽然由最低层派生类初始化虚基类，但是任何直接或间接继承虚基类的类一般也必须为该基类提供自己的初始化式。只要可以创建虚基类派生类类型的独立对象，该类就必须初始化自己的虚基类，这些初始化式只有创建中间类型的对象时使用。


## char的整型运算
char a = '5';
char b = '6';
cout << a+b << endl;  // 输出107
a = a - '0';
cout << a << endl;  // 输出 ♣
附：ASCII码
0:48、A:65、a:97
'A' == 'a'-32


## 只有单个形参，而且该形参是对本类类型对象的引用（常用 const 修饰），这样的构造函数称为复制构造函数
与默认构造函数一样，复制构造函数可由编译器隐式调用。复制构造函数可用于：
	1）根据另一个同类型的对象显式或隐式初始化一个对象。
	2）复制一个对象，将它作为实参传给一个函数。
	3）从函数返回时复制一个对象。
	4）初始化顺序容器中的元素。
	5）根据元素初始化式列表初始化数组元素。


## 要触发动态绑定，满足两个条件
第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定;
第二，必须通过基类类型的引用或指针进行函数调用。


## 对一个包含虚函数成员的对象bzero()会有什么问题？
`对包含虚函数成员的对象bzero会破坏该对象的虚函数表（VTABLE）`，调用该虚函数时将core。
原型：extern void bzero（void *s, int n）;
用法：#include <string.h>
功能：置字节字符串s的前n个字节为零且包括‘\0’。
说明：bzero无返回值，并且使用strings.h头文件，strings.h曾经是posix标准的一部分，但是在POSIX.1-2001标准里面，这些函数被标记为了遗留函数而不推荐使用。在POSIX.1-2008标准里已经没有这些函数了。推荐使用memset替代bzero。


## 如果没有显式提供元素初值，则数组元素会像普通变量一样初始化
	1）在函数体外定义的内置数组，其元素均初始化为 0。
	2）在函数体内定义的内置数组，其元素无初始化。
	3）不管数组在哪里定义，如果其元素为类类型，则自动调用该类的默认构造函数进行初始化；如果该类没有默认构造函数，则必须为该数组的元素提供显式初始化。


## 关键字volatile的意义及使用场景
意思是volatile告诉编译器`不要持有变量的临时拷贝`;
场景可抽象为两个线程，线程1和线程2通过某种方式共享一个变量，线程1根据变量状态进行某种操作，但线程2有可能改变变量的值，由于线程1中对变量的值一直保存到寄存器中，就不会发现变量的改变，此时线程1会做出错误的行为，当然，这个问题也可以由锁进行同步，但会有较大的时间消耗，volatile可以较好的解决此问题。


## 异或操作总结
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
1 ^ 1 = 0
0 ^ a = a
代码验证：
	int a = 123, b = 456;
	a ^ b = 435;
	a ^ b ^ a = 456 ( b )
	a ^ b ^ b = 123 ( a )
应用：不用临时变量交换两值：
	a = a ^ b
	b = b ^ a 
	a = a ^ b


## static、const、volatile、typeof关键字的用途描述
static：静态函数、静态变量、静态类成员
const：const变量，const指针、const函数
volatile：多线程共享变量
typeof：获取类型值


## c++中虚函数的实现机制？
表面现象：虚函数是在类中被声明为virtual的成员函数，`当编译器看到通过指针或引用调用此类函数时，对其执行晚绑定`，即通过指针（或引用）指向的类的类型信息来决定该函数是哪个类的。
实现机制：`编译器对每个包含虚函数的类创建一个表（称为VTABLE）`。在VTABLE中，编译器放置特定类的虚函数地址。在每个带有虚函数的类中，编译器置一指针，称为vpointer（缩写为VPTR），指向这个对象的VTABLE。通过基类指针做虚函数调用时（也就是做多态调用时），编译器静态地插入取得这个VPTR，并在VTABLE表中查找函数地址的代码，这样就能调用正确的函数使晚捆绑发生。


## 对类所继承的成员的访问由基类中的成员访问级别和派生类派生列表中使用的访问标号共同控制
`派生类可以进一步限制但不能放松对所继承的成员的访问`。
派生类不能访问基类的private成员，也不能使自己的用户能够访问那些成员。如果基类成员为public或 protected，则派生列表中使用的访问标号决定该成员在派生类中的访问级别：
	1）如果是公用继承，基类成员保持自己的访问级别：基类的 public 成员为派生类的 public 成员，基类的 protected 成员为派生类的 protected 成员。
	2）如果是受保护继承，基类的 public 和 protected 成员在派生类中为 protected 成员。
	3）如果是私有继承，基类的的所有成员在派生类中为 private 成员。


## 在使用下标访问数组时，实际上是对指向数组元素的指针做下标操作。
只要指针指向数组元素，就可以对它进行下标操作：
```	
  int ia[] = {0,2,4,6,8};
  int *p = &ia[2];     // ok: p points to the element indexed by 2
	int j = p[1];        // ok: p[1] equivalent to *(p + 1),
  int k = p[-2];       // ok: p[-2] is the same element as ia[0]
```

## 写一个病毒
while(1){
	int *p = new int[ 10000000 ]；
}


## 初始化的复制形式和直接形式有所不同
直接初始化直接调用与实参匹配的构造函数，复制初始化总是调用复制构造函数。```复制初始化首先使用指定构造函数创建一个临时对象```，然后用复制构造函数将那个临时对象复制到正在创建的对象：
  string null_book = "9-999-99999-9"; // copy-initialization
  string dots(10, '.');               // direct-initialization
  string empty_copy = string();       // copy-initialization
  string empty_direct;                // direct-initialization
empty_copy和empty_direct的初始化都调用默认构造函数。对前者初始化时，默认构造函数函数创建一个临时对象，然后复制构造函数用该对象初始化 empty_copy。对后者初始化时，直接运行 empty_direct 的默认构造函数。


## C++局部变量，全局变量，静态变量的作用域，生命期？
C++变量根据定义位置的不同，具有不同的作用域，作用域可分为6种：全局作用域，局部作用域，语句作用域，类作用域，命名作用域和文件作用域。
从作用域看：
`全局变量`具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。

`静态局部变量`具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在，他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

`局部变量`也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。

`静态全局变量`也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他`作用于定义它的文件里，不能作用到其他文件里`，即被static关键字修饰过的变量具有`文件作用域`。这样即使两个不同的源文件都定义了相同的静态全局变量，他们也是不同的变量。

从分配内存空间看：
  全局变量、静态局部变量、静态全局变量都在静态存储区分配空间，而局部变量在栈分配空间。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上没有什么不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。
1、静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与堆栈变量和堆变量的区别
2、变量用static告知编译器，自己仅仅在变量的作用域范围内可见。这一点是他与全局变量的区别。
从以上分析可以看出，`把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围，因此static这个说明符在不同的地方起的作用是不同的`。
TIPS：
	1、若全局变量仅在单个文件中访问，则可以讲这个变量修改为静态全局变量。
	2、若全局变量仅在单个函数中使用，则可以将这个变量修改为该函数的静态局部变量。
	3、全局变量、静态局部变量、静态全局变量都存放在静态数据存储区。
	4、函数中必须要使用static变量的情况：当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

