I"_/<ul id="markdown-toc">
  <li><a href="#第1章-ecmascript-6简介" id="markdown-toc-第1章-ecmascript-6简介">第1章 ECMAScript 6简介</a>    <ul>
      <li><a href="#babel转码器" id="markdown-toc-babel转码器">Babel转码器</a>        <ul>
          <li><a href="#babelrc配置文件" id="markdown-toc-babelrc配置文件">.babelrc配置文件</a></li>
          <li><a href="#babel-cli" id="markdown-toc-babel-cli">babel-cli</a></li>
          <li><a href="#babel-node" id="markdown-toc-babel-node">babel-node</a></li>
          <li><a href="#babel-register" id="markdown-toc-babel-register">babel-register</a></li>
          <li><a href="#babel-core" id="markdown-toc-babel-core">babel-core</a></li>
          <li><a href="#babel-polyfill" id="markdown-toc-babel-polyfill">babel-polyfill</a></li>
          <li><a href="#babel用于浏览器环境" id="markdown-toc-babel用于浏览器环境">babel用于浏览器环境</a></li>
        </ul>
      </li>
      <li><a href="#traceur" id="markdown-toc-traceur">Traceur</a></li>
    </ul>
  </li>
  <li><a href="#第2章-let和const命令" id="markdown-toc-第2章-let和const命令">第2章 let和const命令</a>    <ul>
      <li><a href="#let" id="markdown-toc-let">let</a></li>
      <li><a href="#块级作用域" id="markdown-toc-块级作用域">块级作用域</a></li>
      <li><a href="#const" id="markdown-toc-const">const</a></li>
      <li><a href="#全局对象的属性" id="markdown-toc-全局对象的属性">全局对象的属性</a></li>
    </ul>
  </li>
  <li><a href="#第3章-变量的解构赋值" id="markdown-toc-第3章-变量的解构赋值">第3章 变量的解构赋值</a>    <ul>
      <li><a href="#数组的解构赋值" id="markdown-toc-数组的解构赋值">数组的解构赋值</a></li>
      <li><a href="#对象的解构赋值" id="markdown-toc-对象的解构赋值">对象的解构赋值</a></li>
      <li><a href="#字符串的解构赋值" id="markdown-toc-字符串的解构赋值">字符串的解构赋值</a></li>
      <li><a href="#数值和布尔值的解构赋值" id="markdown-toc-数值和布尔值的解构赋值">数值和布尔值的解构赋值</a></li>
      <li><a href="#函数参数的解构赋值" id="markdown-toc-函数参数的解构赋值">函数参数的解构赋值</a></li>
      <li><a href="#圆括号问题" id="markdown-toc-圆括号问题">圆括号问题</a></li>
      <li><a href="#用途" id="markdown-toc-用途">用途</a></li>
    </ul>
  </li>
  <li><a href="#第4章-字符串的扩展" id="markdown-toc-第4章-字符串的扩展">第4章 字符串的扩展</a>    <ul>
      <li><a href="#字符串的遍历器接口" id="markdown-toc-字符串的遍历器接口">字符串的遍历器接口</a></li>
      <li><a href="#模板字符串" id="markdown-toc-模板字符串">模板字符串</a></li>
      <li><a href="#标签模板" id="markdown-toc-标签模板">标签模板</a></li>
      <li><a href="#api" id="markdown-toc-api">API</a></li>
    </ul>
  </li>
  <li><a href="#第5章-正则的扩展" id="markdown-toc-第5章-正则的扩展">第5章 正则的扩展</a>    <ul>
      <li><a href="#构造函数的改变" id="markdown-toc-构造函数的改变">构造函数的改变</a></li>
      <li><a href="#字符串的正则方法" id="markdown-toc-字符串的正则方法">字符串的正则方法</a></li>
      <li><a href="#u修饰符" id="markdown-toc-u修饰符">u修饰符</a></li>
      <li><a href="#y修饰符" id="markdown-toc-y修饰符">y修饰符</a></li>
      <li><a href="#sticky属性" id="markdown-toc-sticky属性">sticky属性</a></li>
      <li><a href="#flags属性" id="markdown-toc-flags属性">flags属性</a></li>
      <li><a href="#regexpescape" id="markdown-toc-regexpescape">RegExp.escape()</a></li>
      <li><a href="#后行断言" id="markdown-toc-后行断言">后行断言</a></li>
    </ul>
  </li>
  <li><a href="#第6章-数值的扩展" id="markdown-toc-第6章-数值的扩展">第6章 数值的扩展</a>    <ul>
      <li><a href="#二进制和八进制表示法" id="markdown-toc-二进制和八进制表示法">二进制和八进制表示法</a></li>
      <li><a href="#numberisfinite" id="markdown-toc-numberisfinite">Number.isFinite()</a></li>
      <li><a href="#numberisnan" id="markdown-toc-numberisnan">Number.isNaN()</a></li>
      <li><a href="#numberparseint-numberparsefloat" id="markdown-toc-numberparseint-numberparsefloat">Number.parseInt(), Number.parseFloat()</a></li>
      <li><a href="#numberisinteger" id="markdown-toc-numberisinteger">Number.isInteger()</a></li>
      <li><a href="#numberepsilon" id="markdown-toc-numberepsilon">Number.EPSILON</a></li>
      <li><a href="#numberissafeinteger" id="markdown-toc-numberissafeinteger">Number.isSafeInteger()</a></li>
      <li><a href="#math对象的扩展" id="markdown-toc-math对象的扩展">Math对象的扩展</a></li>
      <li><a href="#指数运算符" id="markdown-toc-指数运算符">指数运算符</a></li>
    </ul>
  </li>
  <li><a href="#第7章-数组的扩展" id="markdown-toc-第7章-数组的扩展">第7章 数组的扩展</a>    <ul>
      <li><a href="#arrayfrom" id="markdown-toc-arrayfrom">Array.from()</a></li>
      <li><a href="#arrayof" id="markdown-toc-arrayof">Array.of()</a></li>
      <li><a href="#数组实例的copywithin" id="markdown-toc-数组实例的copywithin">数组实例的copyWithin()</a></li>
      <li><a href="#数组实例的find和findindex" id="markdown-toc-数组实例的find和findindex">数组实例的find()和findIndex()</a></li>
      <li><a href="#数组实例的fill" id="markdown-toc-数组实例的fill">数组实例的fill()</a></li>
      <li><a href="#数组实例的entrieskeys和values" id="markdown-toc-数组实例的entrieskeys和values">数组实例的entries()，keys()和values()</a></li>
      <li><a href="#数组实例的includes" id="markdown-toc-数组实例的includes">数组实例的includes()</a></li>
      <li><a href="#数组的空位" id="markdown-toc-数组的空位">数组的空位</a></li>
    </ul>
  </li>
  <li><a href="#第8章-函数的扩展" id="markdown-toc-第8章-函数的扩展">第8章 函数的扩展</a>    <ul>
      <li><a href="#函数参数的默认值" id="markdown-toc-函数参数的默认值">函数参数的默认值</a></li>
      <li><a href="#函数的length属性" id="markdown-toc-函数的length属性">函数的length属性</a></li>
      <li><a href="#rest参数" id="markdown-toc-rest参数">rest参数</a></li>
      <li><a href="#扩展运算符" id="markdown-toc-扩展运算符">扩展运算符</a></li>
      <li><a href="#name属性" id="markdown-toc-name属性">name属性</a></li>
      <li><a href="#箭头函数" id="markdown-toc-箭头函数">箭头函数</a></li>
      <li><a href="#函数绑定" id="markdown-toc-函数绑定">函数绑定</a></li>
      <li><a href="#尾调用优化" id="markdown-toc-尾调用优化">尾调用优化</a></li>
      <li><a href="#函数参数的尾逗号" id="markdown-toc-函数参数的尾逗号">函数参数的尾逗号</a></li>
    </ul>
  </li>
  <li><a href="#第9章-对象的扩展" id="markdown-toc-第9章-对象的扩展">第9章 对象的扩展</a>    <ul>
      <li><a href="#属性的简洁表示法" id="markdown-toc-属性的简洁表示法">属性的简洁表示法</a></li>
      <li><a href="#属性名表达式" id="markdown-toc-属性名表达式">属性名表达式</a></li>
      <li><a href="#方法的name属性" id="markdown-toc-方法的name属性">方法的name属性</a></li>
      <li><a href="#objectis" id="markdown-toc-objectis">Object.is()</a></li>
      <li><a href="#objectassign" id="markdown-toc-objectassign">Object.assign()</a></li>
      <li><a href="#属性的可枚举性" id="markdown-toc-属性的可枚举性">属性的可枚举性</a></li>
      <li><a href="#属性的遍历" id="markdown-toc-属性的遍历">属性的遍历</a></li>
      <li><a href="#__proto__属性objectsetprototypeofobjectgetprototypeof" id="markdown-toc-__proto__属性objectsetprototypeofobjectgetprototypeof">__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</a></li>
      <li><a href="#objectvaluesobjectentries" id="markdown-toc-objectvaluesobjectentries">Object.values()，Object.entries()</a></li>
      <li><a href="#对象的扩展运算符" id="markdown-toc-对象的扩展运算符">对象的扩展运算符</a></li>
      <li><a href="#objectgetownpropertydescriptors" id="markdown-toc-objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors()</a></li>
    </ul>
  </li>
  <li><a href="#第10章-symbol" id="markdown-toc-第10章-symbol">第10章 Symbol</a>    <ul>
      <li><a href="#作为属性名的symbol" id="markdown-toc-作为属性名的symbol">作为属性名的Symbol</a></li>
      <li><a href="#属性名的遍历" id="markdown-toc-属性名的遍历">属性名的遍历</a></li>
      <li><a href="#symbolforsymbolkeyfor" id="markdown-toc-symbolforsymbolkeyfor">Symbol.for()，Symbol.keyFor()</a></li>
      <li><a href="#使用symbol实现模块的-singleton-模式" id="markdown-toc-使用symbol实现模块的-singleton-模式">使用Symbol实现模块的 Singleton 模式</a></li>
      <li><a href="#内置的symbol值" id="markdown-toc-内置的symbol值">内置的Symbol值</a></li>
    </ul>
  </li>
  <li><a href="#第11章-proxy和reflect" id="markdown-toc-第11章-proxy和reflect">第11章 Proxy和Reflect</a>    <ul>
      <li><a href="#proxy支持的拦截操作" id="markdown-toc-proxy支持的拦截操作">Proxy支持的拦截操作</a></li>
      <li><a href="#proxyrevocable" id="markdown-toc-proxyrevocable">Proxy.revocable()</a></li>
      <li><a href="#reflect" id="markdown-toc-reflect">Reflect</a></li>
      <li><a href="#reflect对象的方法" id="markdown-toc-reflect对象的方法">Reflect对象的方法</a></li>
    </ul>
  </li>
  <li><a href="#第12章-二进制数组" id="markdown-toc-第12章-二进制数组">第12章 二进制数组</a>    <ul>
      <li><a href="#二进制数组由三类对象组成" id="markdown-toc-二进制数组由三类对象组成">二进制数组由三类对象组成</a></li>
      <li><a href="#arraybuffer对象" id="markdown-toc-arraybuffer对象">ArrayBuffer对象</a></li>
      <li><a href="#typedarray视图" id="markdown-toc-typedarray视图">TypedArray视图</a></li>
      <li><a href="#dataview视图" id="markdown-toc-dataview视图">DataView视图</a></li>
    </ul>
  </li>
  <li><a href="#第13章-set和map数据结构" id="markdown-toc-第13章-set和map数据结构">第13章 Set和Map数据结构</a>    <ul>
      <li><a href="#set" id="markdown-toc-set">Set</a></li>
      <li><a href="#weakset" id="markdown-toc-weakset">WeakSet</a></li>
      <li><a href="#map" id="markdown-toc-map">Map</a></li>
      <li><a href="#weakmap" id="markdown-toc-weakmap">WeakMap</a></li>
    </ul>
  </li>
  <li><a href="#第14章-iterator和forof循环" id="markdown-toc-第14章-iterator和forof循环">第14章 Iterator和for…of循环</a>    <ul>
      <li><a href="#数据结构的默认iterator接口" id="markdown-toc-数据结构的默认iterator接口">数据结构的默认Iterator接口</a></li>
      <li><a href="#默认调用iterator接口即symboliterator方法的场合" id="markdown-toc-默认调用iterator接口即symboliterator方法的场合">默认调用Iterator接口（即Symbol.iterator方法）的场合</a></li>
      <li><a href="#字符串的iterator接口" id="markdown-toc-字符串的iterator接口">字符串的Iterator接口</a></li>
      <li><a href="#iterator接口与generator函数" id="markdown-toc-iterator接口与generator函数">Iterator接口与Generator函数</a></li>
      <li><a href="#遍历器对象的returnthrow" id="markdown-toc-遍历器对象的returnthrow">遍历器对象的return()，throw()</a></li>
      <li><a href="#forof循环" id="markdown-toc-forof循环">for…of循环</a></li>
    </ul>
  </li>
  <li><a href="#第15章-generator-函数" id="markdown-toc-第15章-generator-函数">第15章 Generator 函数</a>    <ul>
      <li><a href="#yield语句" id="markdown-toc-yield语句">yield语句</a></li>
      <li><a href="#next方法的参数" id="markdown-toc-next方法的参数">next方法的参数</a></li>
      <li><a href="#generatorprototypethrow" id="markdown-toc-generatorprototypethrow">Generator.prototype.throw()</a></li>
      <li><a href="#generatorprototypereturn" id="markdown-toc-generatorprototypereturn">Generator.prototype.return()</a></li>
      <li><a href="#yield语句-1" id="markdown-toc-yield语句-1">yield*语句</a></li>
      <li><a href="#作为对象属性的generator函数" id="markdown-toc-作为对象属性的generator函数">作为对象属性的Generator函数</a></li>
      <li><a href="#generator函数的this" id="markdown-toc-generator函数的this">Generator函数的this</a></li>
      <li><a href="#generator与协程" id="markdown-toc-generator与协程">Generator与协程</a></li>
      <li><a href="#generator的应用" id="markdown-toc-generator的应用">Generator的应用</a></li>
    </ul>
  </li>
  <li><a href="#第16章-promise对象" id="markdown-toc-第16章-promise对象">第16章 Promise对象</a>    <ul>
      <li><a href="#promiseprototypethen" id="markdown-toc-promiseprototypethen">Promise.prototype.then()</a></li>
      <li><a href="#promiseprototypecatch" id="markdown-toc-promiseprototypecatch">Promise.prototype.catch()</a></li>
      <li><a href="#promiseall" id="markdown-toc-promiseall">Promise.all()</a></li>
      <li><a href="#promiseresolve" id="markdown-toc-promiseresolve">Promise.resolve()</a></li>
      <li><a href="#promisereject" id="markdown-toc-promisereject">Promise.reject()</a></li>
      <li><a href="#done" id="markdown-toc-done">done()</a></li>
      <li><a href="#finally" id="markdown-toc-finally">finally()</a></li>
      <li><a href="#generator函数与promise的结合" id="markdown-toc-generator函数与promise的结合">Generator函数与Promise的结合</a></li>
    </ul>
  </li>
  <li><a href="#第17章-异步操作和async函数" id="markdown-toc-第17章-异步操作和async函数">第17章 异步操作和Async函数</a>    <ul>
      <li><a href="#回调函数promise" id="markdown-toc-回调函数promise">回调函数、Promise</a></li>
      <li><a href="#generator函数执行异步任务" id="markdown-toc-generator函数执行异步任务">Generator函数执行异步任务</a></li>
      <li><a href="#thunk函数" id="markdown-toc-thunk函数">Thunk函数</a></li>
      <li><a href="#javascript语言的thunk函数" id="markdown-toc-javascript语言的thunk函数">JavaScript语言的Thunk函数</a></li>
      <li><a href="#thunkify模块" id="markdown-toc-thunkify模块">Thunkify模块</a></li>
      <li><a href="#generator-函数的流程管理" id="markdown-toc-generator-函数的流程管理">Generator 函数的流程管理</a></li>
      <li><a href="#co模块" id="markdown-toc-co模块">co模块</a></li>
      <li><a href="#async函数" id="markdown-toc-async函数">async函数</a></li>
      <li><a href="#async函数语法" id="markdown-toc-async函数语法">async函数语法</a></li>
    </ul>
  </li>
  <li><a href="#第18章-class" id="markdown-toc-第18章-class">第18章 Class</a>    <ul>
      <li><a href="#constructor方法" id="markdown-toc-constructor方法">constructor方法</a></li>
      <li><a href="#类的实例对象" id="markdown-toc-类的实例对象">类的实例对象</a></li>
      <li><a href="#this的指向" id="markdown-toc-this的指向">this的指向</a></li>
      <li><a href="#class的继承" id="markdown-toc-class的继承">Class的继承</a></li>
      <li><a href="#类的prototype属性和__proto__属性" id="markdown-toc-类的prototype属性和__proto__属性">类的prototype属性和__proto__属性</a></li>
      <li><a href="#extends-的继承目标" id="markdown-toc-extends-的继承目标">Extends 的继承目标</a></li>
      <li><a href="#objectgetprototypeof" id="markdown-toc-objectgetprototypeof">Object.getPrototypeOf()</a></li>
      <li><a href="#super关键字" id="markdown-toc-super关键字">super关键字</a></li>
      <li><a href="#实例的__proto__属性" id="markdown-toc-实例的__proto__属性">实例的__proto__属性</a></li>
      <li><a href="#原生构造函数的继承" id="markdown-toc-原生构造函数的继承">原生构造函数的继承</a></li>
      <li><a href="#class的取值函数getter和存值函数setter" id="markdown-toc-class的取值函数getter和存值函数setter">Class的取值函数（getter）和存值函数（setter）</a></li>
      <li><a href="#class的静态方法" id="markdown-toc-class的静态方法">Class的静态方法</a></li>
      <li><a href="#class的静态属性和实例属性" id="markdown-toc-class的静态属性和实例属性">Class的静态属性和实例属性</a></li>
      <li><a href="#newtarget属性" id="markdown-toc-newtarget属性">new.target属性</a></li>
      <li><a href="#mixin模式的实现" id="markdown-toc-mixin模式的实现">Mixin模式的实现</a></li>
    </ul>
  </li>
  <li><a href="#第19章-修饰器" id="markdown-toc-第19章-修饰器">第19章 修饰器</a>    <ul>
      <li><a href="#方法的修饰" id="markdown-toc-方法的修饰">方法的修饰</a></li>
      <li><a href="#为什么修饰器不能用于函数" id="markdown-toc-为什么修饰器不能用于函数">为什么修饰器不能用于函数？</a></li>
      <li><a href="#core-decoratorsjs" id="markdown-toc-core-decoratorsjs">core-decorators.js</a></li>
      <li><a href="#使用修饰器实现自动发布事件" id="markdown-toc-使用修饰器实现自动发布事件">使用修饰器实现自动发布事件</a></li>
      <li><a href="#mixin" id="markdown-toc-mixin">Mixin</a></li>
      <li><a href="#trait" id="markdown-toc-trait">Trait</a></li>
    </ul>
  </li>
  <li><a href="#第20章-module" id="markdown-toc-第20章-module">第20章 Module</a>    <ul>
      <li><a href="#es6的模块自动采用严格模式" id="markdown-toc-es6的模块自动采用严格模式">ES6的模块自动采用严格模式</a></li>
      <li><a href="#export命令" id="markdown-toc-export命令">export命令</a></li>
      <li><a href="#import命令" id="markdown-toc-import命令">import命令</a></li>
      <li><a href="#模块的整体加载" id="markdown-toc-模块的整体加载">模块的整体加载</a></li>
      <li><a href="#export-default命令" id="markdown-toc-export-default命令">export default命令</a></li>
      <li><a href="#模块的继承" id="markdown-toc-模块的继承">模块的继承</a></li>
      <li><a href="#es6模块加载的实质" id="markdown-toc-es6模块加载的实质">ES6模块加载的实质</a></li>
      <li><a href="#循环加载" id="markdown-toc-循环加载">循环加载</a></li>
    </ul>
  </li>
</ul>

<h2 id="第1章-ecmascript-6简介">第1章 ECMAScript 6简介</h2>

<h3 id="babel转码器">Babel转码器</h3>
<h4 id="babelrc配置文件">.babelrc配置文件</h4>
<p>放在项目根目录下，用来配置转码规则和插件，如：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="dl">"</span><span class="s2">presets</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">es2015</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">stage-2</span><span class="dl">"</span>
    <span class="p">],</span> 
  <span class="dl">"</span><span class="s2">plugins</span><span class="dl">"</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>转码规则需要单独安装，如：
$ npm install –save-dev babel-preset-es2015</p>

<h4 id="babel-cli">babel-cli</h4>
<p>用于命令行执行转码，如：
$ babel example.js –out-file compiled.js
$ babel src –out-dir lib</p>

<h4 id="babel-node">babel-node</h4>
<p>是babel-cli自带的一个命令，无需单独安装，可以直接运行ES6代码：
$ babel-node es6.js  # 替代node</p>

<h4 id="babel-register">babel-register</h4>
<p>该模块会改写require命令，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码：
require(“babel-register”);
require(“./index.js”);</p>

<h4 id="babel-core">babel-core</h4>
<p>babel-core提供babel的API，有些代码需要通过调用Babel的API才能进行转码，如：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">es6Code</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">let x = n =&gt; n + 1</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">es5Code</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">babel-core</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">transform</span><span class="p">(</span><span class="nx">es6Code</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">presets</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">es2015</span><span class="dl">'</span><span class="p">]</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">code</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="babel-polyfill">babel-polyfill</h4>
<p>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。如果也想转换这些对象，需要使用babel-polyfill：
import ‘babel-polyfill’;
// 或者
require(‘babel-polyfill’);</p>

<h4 id="babel用于浏览器环境">babel用于浏览器环境</h4>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">node_modules/babel-core/browser.js</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/babel</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="c1">// ES6 code</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>
<p>直接在浏览器中进行转码性能太差，可以配合browserify在服务器端把代码转换为浏览器可以直接执行的代码：
$ npm install –save-dev babelify babel-preset-es2015
$ browserify script.js -o bundle.js -t [ babelify –presets [ es2015 ] ]</p>

<p>可以在package.json中进行配置，这样就不用每次都在命令行输入参数了：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="dl">"</span><span class="s2">browserify</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">transform</span><span class="dl">"</span><span class="p">:</span> <span class="p">[[</span><span class="dl">"</span><span class="s2">babelify</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">presets</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">es2015</span><span class="dl">"</span><span class="p">]</span> <span class="p">}]]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="traceur">Traceur</h3>
<p>（略）</p>

<h2 id="第2章-let和const命令">第2章 let和const命令</h2>

<h3 id="let">let</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用let声明的变量只在let命令所在的代码块内有效</span>
<span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">a</span> <span class="c1">// ReferenceError: a is not defined.</span>
<span class="nx">b</span> <span class="c1">// 1</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用let声明的变量不会“变量提升”，变量一定要在声明后使用</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// 输出undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// 报错ReferenceError</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 会变量提升，即脚本开始运行时变量foo就已存在，但没有值</span>
<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响（const同理）</span>
<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">tmp</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// ReferenceError （暂时性死区）</span>
  <span class="kd">let</span> <span class="nx">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// let不允许在相同作用域内，重复声明同一个变量</span>
<span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 报错</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 报错</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="块级作用域">块级作用域</h3>
<p>ES5只有全局作用域和函数作用域，没有块级作用域，这会造成很多不合理的场景，比如：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hello world</span><span class="dl">"</span><span class="p">;</span>  <span class="c1">// 变量提升，会覆盖外层tmp变量</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">();</span> <span class="c1">// undefined</span>

</code></pre></div></div>
<p>let为JavaScript新增了块级作用域，使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。</p>

<p>ES5标准规定不允许在块级作用域中声明函数，但是很多浏览器没有遵守这个规定。ES6明确允许在块级作用域中声明函数：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES6严格模式</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="c1">// 不报错</span>
</code></pre></div></div>
<p>并且ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数声明语句</span>
<span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">secret</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 函数表达式</span>
<span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">secret</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="const">const</h3>
<p>const声明的变量不得改变值，一旦声明，就必须立即初始化：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">foo</span><span class="p">;</span>
<span class="c1">// SyntaxError: Missing initializer in const declaration</span>
</code></pre></div></div>

<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="nx">foo</span><span class="p">.</span><span class="nx">prop</span>
<span class="c1">// 123</span>

<span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// TypeError: "foo" is read-only</span>
</code></pre></div></div>
<p>如果真的想将对象冻结，应该使用<code class="language-plaintext highlighter-rouge">Object.freeze</code>方法：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 彻底冻结一个对象（包括对象的属性）</span>
<span class="kd">var</span> <span class="nx">constantize</span> <span class="o">=</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">constantize</span><span class="p">(</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ES6一共有6种声明变量的方法</code>：var、function、let、const、import、class</p>

<h3 id="全局对象的属性">全局对象的属性</h3>
<p>全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。
ES5之中，全局对象的属性与全局变量是等价的，未声明的全局变量，自动成为全局对象window的属性。
从ES6开始，全局变量将逐步与全局对象的属性脱钩，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// 如果在Node的REPL环境，可以写成global.a</span>
<span class="c1">// 或者采用通用方法，写成this.a</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 1</span>

<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<h2 id="第3章-变量的解构赋值">第3章 变量的解构赋值</h2>

<h3 id="数组的解构赋值">数组的解构赋值</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">,</span> <span class="p">[[</span><span class="nx">bar</span><span class="p">],</span> <span class="nx">baz</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">]];</span>
<span class="nx">foo</span> <span class="c1">// 1</span>
<span class="nx">bar</span> <span class="c1">// 2</span>
<span class="nx">baz</span> <span class="c1">// 3</span>

<span class="kd">let</span> <span class="p">[</span> <span class="p">,</span> <span class="p">,</span> <span class="nx">third</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">baz</span><span class="dl">"</span><span class="p">];</span>
<span class="nx">third</span> <span class="c1">// "baz"</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 3</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">head</span><span class="p">,</span> <span class="p">...</span><span class="nx">tail</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="nx">head</span> <span class="c1">// 1</span>
<span class="nx">tail</span> <span class="c1">// [2, 3, 4]</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">];</span>
<span class="nx">x</span> <span class="c1">// "a"</span>
<span class="nx">y</span> <span class="c1">// undefined</span>
<span class="nx">z</span> <span class="c1">// []</span>


<span class="c1">// 支持不完全结构</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 2</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">[</span><span class="nx">b</span><span class="p">],</span> <span class="nx">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">];</span>
<span class="nx">a</span> <span class="c1">// 1</span>
<span class="nx">b</span> <span class="c1">// 2</span>
<span class="nx">d</span> <span class="c1">// 4</span>

<span class="c1">// 允许指定默认值</span>
<span class="kd">var</span> <span class="p">[</span><span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">foo</span> <span class="c1">// true</span>

<span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">];</span> <span class="c1">// x='a', y='b'</span>
<span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">];</span> <span class="c1">// x='a', y='b'</span>

<span class="c1">// ES6内部使用严格相等运算符（===），判断一个位置是否有值</span>
<span class="kd">var</span> <span class="p">[</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">];</span>
<span class="nx">x</span> <span class="c1">// 1</span>

<span class="kd">var</span> <span class="p">[</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">null</span><span class="p">];</span>
<span class="nx">x</span> <span class="c1">// null</span>

</code></pre></div></div>

<p>如果等号的右边不是<code class="language-plaintext highlighter-rouge">可遍历</code>的结构，那么将会报错:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 报错</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
</code></pre></div></div>

<p>如果默认值是一个表达式，那么这个表达式是惰性求值的：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 因为x能取到值，所以函数f根本不会执行</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">aaa</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">f</span><span class="p">()]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="对象的解构赋值">对象的解构赋值</h3>
<p>对象的属性没有次序，变量必须与属性同名，才能取到正确的值：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="p">{</span> <span class="nx">bar</span><span class="p">,</span> <span class="nx">foo</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">aaa</span><span class="dl">"</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bbb</span><span class="dl">"</span> <span class="p">};</span>
<span class="nx">foo</span> <span class="c1">// "aaa"</span>
<span class="nx">bar</span> <span class="c1">// "bbb"</span>

<span class="kd">var</span> <span class="p">{</span> <span class="nx">baz</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">aaa</span><span class="dl">"</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bbb</span><span class="dl">"</span> <span class="p">};</span>
<span class="nx">baz</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p>对象的解构赋值是下面形式的简写：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="nx">bar</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">aaa</span><span class="dl">"</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bbb</span><span class="dl">"</span> <span class="p">};</span>
</code></pre></div></div>
<p>即对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。因此，如果变量名与属性名不一致，可以写成下面这样：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="nx">baz</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">aaa</span><span class="dl">'</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bbb</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">baz</span> <span class="c1">// "aaa"</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">first</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span> <span class="na">last</span><span class="p">:</span> <span class="dl">'</span><span class="s1">world</span><span class="dl">'</span> <span class="p">};</span>
<span class="kd">let</span> <span class="p">{</span> <span class="na">first</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span> <span class="na">last</span><span class="p">:</span> <span class="nx">l</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="nx">f</span> <span class="c1">// 'hello'</span>
<span class="nx">l</span> <span class="c1">// 'world'</span>
</code></pre></div></div>

<p>解构也可以用于嵌套结构的对象：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">loc</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">start</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">line</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">column</span><span class="p">:</span> <span class="mi">5</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="p">{</span> <span class="na">loc</span><span class="p">:</span> <span class="p">{</span> <span class="na">start</span><span class="p">:</span> <span class="p">{</span> <span class="nx">line</span> <span class="p">}}</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
<span class="nx">line</span> <span class="c1">// 1</span>
<span class="nx">loc</span>  <span class="c1">// error: loc is undefined</span>
<span class="nx">start</span> <span class="c1">// error: start is undefined</span>
</code></pre></div></div>
<p>只有line是变量，loc和start都是模式，不会被赋值。</p>

<p>如果要将一个已经声明的变量用于解构赋值，必须使用()：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">{</span><span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="c1">// SyntaxError: syntax error</span>
</code></pre></div></div>
<p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。<code class="language-plaintext highlighter-rouge">只有不将大括号写在行首，避免JavaScript将其解释为代码块</code>，才能解决这个问题。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">});</span>
</code></pre></div></div>

<h3 id="字符串的解构赋值">字符串的解构赋值</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">e</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">a</span> <span class="c1">// "h"</span>
<span class="nx">b</span> <span class="c1">// "e"</span>
<span class="nx">c</span> <span class="c1">// "l"</span>
<span class="nx">d</span> <span class="c1">// "l"</span>
<span class="nx">e</span> <span class="c1">// "o"</span>

<span class="kd">let</span> <span class="p">{</span><span class="na">length</span> <span class="p">:</span> <span class="nx">len</span><span class="p">}</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">len</span> <span class="c1">// 5</span>
</code></pre></div></div>

<h3 id="数值和布尔值的解构赋值">数值和布尔值的解构赋值</h3>
<p>如果等号右边是数值和布尔值，则会先转为对象</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="p">{</span><span class="na">toString</span><span class="p">:</span> <span class="nx">s</span><span class="p">}</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">s</span> <span class="o">===</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span> <span class="c1">// true</span>

<span class="kd">let</span> <span class="p">{</span><span class="na">toString</span><span class="p">:</span> <span class="nx">s</span><span class="p">}</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">s</span> <span class="o">===</span> <span class="nb">Boolean</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。<code class="language-plaintext highlighter-rouge">由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错</code>。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="p">{</span> <span class="na">prop</span><span class="p">:</span> <span class="nx">x</span> <span class="p">}</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// TypeError</span>
<span class="kd">let</span> <span class="p">{</span> <span class="na">prop</span><span class="p">:</span> <span class="nx">y</span> <span class="p">}</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// TypeError</span>
</code></pre></div></div>

<h3 id="函数参数的解构赋值">函数参数的解构赋值</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]){</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">add</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="c1">// 3</span>

<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]].</span><span class="nx">map</span><span class="p">(([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="c1">// [ 3, 7 ]</span>
</code></pre></div></div>

<p>undefined就会触发函数参数的默认值:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">((</span><span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">);</span>
<span class="c1">// [ 1, 'yes', 3 ]</span>
</code></pre></div></div>

<h3 id="圆括号问题">圆括号问题</h3>
<p>建议只要有可能，就不要在模式中放置圆括号。
（不要自找麻烦）</p>

<h3 id="用途">用途</h3>
<p>遍历Map结构:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> is </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[,</span><span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输入模块的指定方法：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">SourceMapConsumer</span><span class="p">,</span> <span class="nx">SourceNode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">source-map</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="第4章-字符串的扩展">第4章 字符串的扩展</h2>
<p>JavaScript<code class="language-plaintext highlighter-rouge">允许采用\uxxxx形式表示一个字符</code>，其中“xxxx”表示字符的<code class="language-plaintext highlighter-rouge">码点</code>。但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="se">\</span><span class="s2">uD842</span><span class="se">\</span><span class="s2">uDFB7</span><span class="dl">"</span>
<span class="c1">// "𠮷"</span>

<span class="dl">"</span><span class="se">\</span><span class="s2">u20BB7</span><span class="dl">"</span>  <span class="c1">// 超过0xFFFF，ES5会理解成“\u20BB+7”，\u20BB是一个不可打印字符，所以只会显示一个空格</span>
<span class="c1">// " 7"</span>
</code></pre></div></div>

<p>ES6对Unicode字符的表示做出了改进，只要将码点放入大括号，就能正确解读4字节字符：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="se">\</span><span class="s2">u{20BB7}</span><span class="dl">"</span>
<span class="c1">// "𠮷"</span>
</code></pre></div></div>

<p>因此ES6共有6种方法可以表示一个字符：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="se">\</span><span class="s1">z</span><span class="dl">'</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span>  <span class="c1">// true</span>
<span class="dl">'</span><span class="se">\</span><span class="s1">172</span><span class="dl">'</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="dl">'</span><span class="se">\</span><span class="s1">x7A</span><span class="dl">'</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="dl">'</span><span class="se">\</span><span class="s1">u007A</span><span class="dl">'</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="dl">'</span><span class="se">\</span><span class="s1">u{7A}</span><span class="dl">'</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="字符串的遍历器接口">字符串的遍历器接口</h3>
<p>ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">codePoint</span> <span class="k">of</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">codePoint</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "f"</span>
<span class="c1">// "o"</span>
<span class="c1">// "o"</span>
</code></pre></div></div>

<h3 id="模板字符串">模板字符串</h3>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 普通字符串</span>
<span class="s2">`In JavaScript '\n' is a line-feed.`</span>

<span class="c1">// 多行字符串</span>
<span class="s2">`In JavaScript this is
 not legal.`</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`string text line 1
string text line 2`</span><span class="p">);</span>

<span class="c1">// 字符串中嵌入变量</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">,</span> <span class="nx">time</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">today</span><span class="dl">"</span><span class="p">;</span>
<span class="s2">`Hello </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">, how are you </span><span class="p">${</span><span class="nx">time</span><span class="p">}</span><span class="s2">?`</span>
</code></pre></div></div>

<h3 id="标签模板">标签模板</h3>
<p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">alert</span><span class="s2">`123`</span>
<span class="c1">// 等同于</span>
<span class="nx">alert</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
</code></pre></div></div>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。
如果模板字符里面有变量，会将模板字符串先处理成多个参数，再调用函数：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="nx">tag</span><span class="s2">`Hello </span><span class="p">${</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="p">}</span><span class="s2"> world </span><span class="p">${</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span> <span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="nx">tag</span><span class="p">([</span><span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1"> world </span><span class="dl">'</span><span class="p">,</span> <span class="dl">''</span><span class="p">],</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="api">API</h3>
<p>codePointAt()  // 能够正确处理4个字节储存的字符，返回一个字符的码点
String.fromCodePoint()  // 用于从码点返回对应字符
at()  // 可以识别Unicode编号大于0xFFFF的字符，返回正确的字符
normalize()  // 用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化（字符合成）
includes()  // 返回布尔值，表示是否找到了参数字符串。
startsWith()  // 返回布尔值，表示参数字符串是否在源字符串的头部。
endsWith()  // 返回布尔值，表示参数字符串是否在源字符串的尾部。
repeat() // 返回一个新字符串，表示将原字符串重复n次
padStart() // 头部补全
padEnd() // 尾部补全
String.raw()  // 往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>

<h2 id="第5章-正则的扩展">第5章 正则的扩展</h2>

<h3 id="构造函数的改变">构造函数的改变</h3>
<p>ES6改变了ES5中RegExp的构造函数的行为：构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="sr">/abc/ig</span><span class="p">,</span> <span class="dl">'</span><span class="s1">i</span><span class="dl">'</span><span class="p">).</span><span class="nx">flags</span>
<span class="c1">// "i"</span>
</code></pre></div></div>

<h3 id="字符串的正则方法">字符串的正则方法</h3>
<p>字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。</p>

<h3 id="u修饰符">u修饰符</h3>
<p>ES6对正则表达式添加了u修饰符，用来正确处理大于\uFFFF的Unicode字符</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/^</span><span class="err">\</span><span class="nx">uD83D</span><span class="o">/</span><span class="nx">u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="se">\</span><span class="s1">uD83D</span><span class="se">\</span><span class="s1">uDC2A</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// false</span>
<span class="o">/^</span><span class="err">\</span><span class="nx">uD83D</span><span class="o">/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="dl">'</span><span class="se">\</span><span class="s1">uD83D</span><span class="se">\</span><span class="s1">uDC2A</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// true</span>
</code></pre></div></div>

<h3 id="y修饰符">y修饰符</h3>
<p>ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符，y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">aaa_aa_a</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="sr">/a+/g</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="sr">/a+/y</span><span class="p">;</span>

<span class="nx">r1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// ["aaa"]</span>
<span class="nx">r2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// ["aaa"]</span>

<span class="nx">r1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// ["aa"]</span>
<span class="nx">r2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// null</span>
</code></pre></div></div>

<h3 id="sticky属性">sticky属性</h3>
<p>ES6的正则对象多了sticky属性，表示是否设置了y修饰符</p>

<h3 id="flags属性">flags属性</h3>
<p>新增了flags属性，会返回正则表达式的修饰符</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES5的source属性</span>
<span class="c1">// 返回正则表达式的正文</span>
<span class="o">/</span><span class="nx">abc</span><span class="o">/</span><span class="nx">ig</span><span class="p">.</span><span class="nx">source</span>
<span class="c1">// "abc"</span>

<span class="c1">// ES6的flags属性</span>
<span class="c1">// 返回正则表达式的修饰符</span>
<span class="o">/</span><span class="nx">abc</span><span class="o">/</span><span class="nx">ig</span><span class="p">.</span><span class="nx">flags</span>
<span class="c1">// 'gi'</span>
</code></pre></div></div>

<h3 id="regexpescape">RegExp.escape()</h3>
<p>ES7，（略）</p>

<h3 id="后行断言">后行断言</h3>
<p>ES7，（略）</p>

<h2 id="第6章-数值的扩展">第6章 数值的扩展</h2>

<h3 id="二进制和八进制表示法">二进制和八进制表示法</h3>
<p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mb">0b111110111</span> <span class="o">===</span> <span class="mi">503</span> <span class="c1">// true</span>
<span class="mo">0o767</span> <span class="o">===</span> <span class="mi">503</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="numberisfinite">Number.isFinite()</h3>
<p>用来检查一个数值是否为有限的（finite）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="o">-</span><span class="kc">Infinity</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="dl">'</span><span class="s1">15</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// false</span>
</code></pre></div></div>

<h3 id="numberisnan">Number.isNaN()</h3>
<p>用来检查一个值是否为NaN：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="dl">'</span><span class="s1">15</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="mi">9</span><span class="o">/</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="o">/</span><span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="numberparseint-numberparsefloat">Number.parseInt(), Number.parseFloat()</h3>
<p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Number</span><span class="p">.</span><span class="nb">parseInt</span> <span class="o">===</span> <span class="nb">parseInt</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">parseFloat</span> <span class="o">===</span> <span class="nb">parseFloat</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="numberisinteger">Number.isInteger()</h3>
<p>用来判断一个值是否为整数，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mf">25.0</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mf">25.1</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="dl">"</span><span class="s2">15</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div>

<h3 id="numberepsilon">Number.EPSILON</h3>
<p>新增的一个极小的常量：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Number</span><span class="p">.</span><span class="nx">EPSILON</span>
<span class="c1">// 2.220446049250313e-16</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">EPSILON</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="c1">// '0.00000000000000022204'</span>
</code></pre></div></div>

<h3 id="numberissafeinteger">Number.isSafeInteger()</h3>
<p>JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。
实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Number</span><span class="p">.</span><span class="nx">isSafeInteger</span><span class="p">(</span><span class="mi">9007199254740993</span><span class="p">)</span>
<span class="c1">// false</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">isSafeInteger</span><span class="p">(</span><span class="mi">990</span><span class="p">)</span>
<span class="c1">// true</span>
<span class="nb">Number</span><span class="p">.</span><span class="nx">isSafeInteger</span><span class="p">(</span><span class="mi">9007199254740993</span> <span class="o">-</span> <span class="mi">990</span><span class="p">)</span>
<span class="c1">// true</span>
<span class="mi">9007199254740993</span> <span class="o">-</span> <span class="mi">990</span>
<span class="c1">// 返回结果 9007199254740002</span>
<span class="c1">// 正确答案应该是 9007199254740003</span>
</code></pre></div></div>

<h3 id="math对象的扩展">Math对象的扩展</h3>
<p>Math.trunc()  // 用于去除一个数的小数部分，返回整数部分
Math.sign()  // 用来判断一个数到底是正数、负数、还是零
Math.cbrt()  // 用于计算一个数的立方根
Math.clz32()  // 返回一个数的32位无符号整数形式有多少个前导0
Math.imul()  // 返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数
Math.fround()  // 返回一个数的单精度浮点数形式
Math.hypot()  // 返回所有参数的平方和的平方根
（新增若干对数、指数、三角函数方法，略）</p>

<h3 id="指数运算符">指数运算符</h3>
<p>ES7新增了一个指数运算符（**）</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="c1">// 4</span>
<span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="c1">// 8</span>
</code></pre></div></div>

<h2 id="第7章-数组的扩展">第7章 数组的扩展</h2>

<h3 id="arrayfrom">Array.from()</h3>
<p>用于将两类对象转为真正的数组：</p>
<ol>
  <li>类似数组的对象（array-like object）</li>
  <li>可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map，只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组）
```javascript
let arrayLike = {
 ‘0’: ‘a’,
 ‘1’: ‘b’,
 ‘2’: ‘c’,
 length: 3
};</li>
</ol>

<p>// ES5的写法
var arr1 = [].slice.call(arrayLike); // [‘a’, ‘b’, ‘c’]</p>

<p>// ES6的写法
let arr2 = Array.from(arrayLike); // [‘a’, ‘b’, ‘c’]</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
扩展运算符（...）也可以将某些数据结构转为数组：
```javascript
// arguments对象
function foo() {
  var args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]
</code></pre></div></div>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是还支持类似数组的对象。<code class="language-plaintext highlighter-rouge">所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换</code>。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="c1">// [ undefined, undefined, undefined ]</span>
</code></pre></div></div>

<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>

<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">)</span>
<span class="c1">// [1, 4, 9]</span>
</code></pre></div></div>

<p>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</p>

<h3 id="arrayof">Array.of()</h3>
<p>用于将一组值，转换为数组：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// [3,11,8]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [3]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">length</span> <span class="c1">// 1</span>

<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">()</span> <span class="c1">// []</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// [undefined]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [1, 2]</span>
</code></pre></div></div>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异（只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">()</span> <span class="c1">// []</span>
<span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [, , ,]</span>
<span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// [3, 11, 8]</span>
</code></pre></div></div>

<h3 id="数组实例的copywithin">数组实例的copyWithin()</h3>
<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
Array.prototype.copyWithin(target, start = 0, end = this.length)</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// [4, 5, 3, 4, 5]</span>
</code></pre></div></div>

<h3 id="数组实例的find和findindex">数组实例的find()和findIndex()</h3>
<p>find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">].</span><span class="nx">find</span><span class="p">((</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// -5</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">})</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p>findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span>
<span class="c1">// -1</span>

<span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">y</span> <span class="o">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
<span class="c1">// 0</span>
</code></pre></div></div>

<h3 id="数组实例的fill">数组实例的fill()</h3>
<p>使用给定值，填充一个数组</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">].</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="c1">// [7, 7, 7]</span>

<span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="c1">// [7, 7, 7]</span>

<span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">].</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// ['a', 7, 'c']</span>
</code></pre></div></div>

<h3 id="数组实例的entrieskeys和values">数组实例的entries()，keys()和values()</h3>
<p>ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">index</span> <span class="k">of</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">].</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">elem</span> <span class="k">of</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">].</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 'a'</span>
<span class="c1">// 'b'</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="nx">elem</span><span class="p">]</span> <span class="k">of</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">].</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">elem</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 0 "a"</span>
<span class="c1">// 1 "b"</span>
</code></pre></div></div>

<h3 id="数组实例的includes">数组实例的includes()</h3>
<p>返回一个布尔值，表示某个数组是否包含给定的值：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>     <span class="c1">// true</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>     <span class="c1">// false</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="数组的空位">数组的空位</h3>
<p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [, , ,]</span>
</code></pre></div></div>
<p>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="k">in</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">]</span> <span class="c1">// true</span>
<span class="mi">0</span> <span class="k">in</span> <span class="p">[,</span> <span class="p">,</span> <span class="p">,]</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>ES5对空位的处理很不一致，大多数情况下会忽略空位:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// forEach方法</span>
<span class="p">[,</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span> <span class="c1">// 1</span>

<span class="c1">// filter方法</span>
<span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,,</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// ['a','b']</span>

<span class="c1">// every方法</span>
<span class="p">[,</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">].</span><span class="nx">every</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="o">===</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>

<span class="c1">// some方法</span>
<span class="p">[,</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">].</span><span class="nx">some</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// map方法</span>
<span class="p">[,</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [,1]</span>

<span class="c1">// join方法</span>
<span class="p">[,</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span><span class="kc">undefined</span><span class="p">,</span><span class="kc">null</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// "#a##"</span>

<span class="c1">// toString方法</span>
<span class="p">[,</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span><span class="kc">undefined</span><span class="p">,</span><span class="kc">null</span><span class="p">].</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// ",a,,"</span>
</code></pre></div></div>
<p>ES6则是明确将空位转为undefined。
由于空位的处理规则非常不统一，所以建议避免出现空位。</p>

<h2 id="第8章-函数的扩展">第8章 函数的扩展</h2>

<h3 id="函数参数的默认值">函数参数的默认值</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">World</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// Hello World</span>
<span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">China</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// Hello China</span>
<span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">,</span> <span class="dl">''</span><span class="p">)</span> <span class="c1">// Hello</span>
</code></pre></div></div>

<p>如果传入undefined，将触发参数等于默认值，null则没有这个效果:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span>
<span class="c1">// 5 null</span>
</code></pre></div></div>

<h3 id="函数的length属性">函数的length属性</h3>
<p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 1</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 0</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 2</span>
</code></pre></div></div>

<h3 id="rest参数">rest参数</h3>
<p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">val</span> <span class="k">of</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 10</span>
</code></pre></div></div>
<p>rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
函数的length属性，不包括rest参数。</p>

<h3 id="扩展运算符">扩展运算符</h3>
<p>将一个数组转为用逗号分隔的参数序列。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">// 1 2 3</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">...[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 1 2 3 4 5</span>

<span class="p">[...</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">)]</span>
<span class="c1">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span>

<span class="p">[...</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">]</span>
<span class="c1">// [ "h", "e", "l", "l", "o" ]</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">扩展运算符内部调用的是数据结构的Iterator接口</code>，因此只要具有Iterator接口的对象，都可以使用扩展运算符。</p>

<p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span> <span class="c1">// ES5的写法</span>
<span class="nx">f</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span> <span class="c1">// ES6的写法</span>
</code></pre></div></div>

<h3 id="name属性">name属性</h3>
<p>返回该函数的函数名：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "foo"</span>
</code></pre></div></div>
<p>如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">func1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>

<span class="c1">// ES5</span>
<span class="nx">func1</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// ""</span>

<span class="c1">// ES6</span>
<span class="nx">func1</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "func1"</span>
</code></pre></div></div>
<p>如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。</p>

<p>Function构造函数返回的函数实例，name属性的值为“anonymous”。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">).</span><span class="nx">name</span> <span class="c1">// "anonymous"</span>
</code></pre></div></div>

<p>bind返回的函数，name属性值会加上“bound ”前缀。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{};</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">({}).</span><span class="nx">name</span> <span class="c1">// "bound foo"</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){}).</span><span class="nx">bind</span><span class="p">({}).</span><span class="nx">name</span> <span class="c1">// "bound "</span>
</code></pre></div></div>

<h3 id="箭头函数">箭头函数</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">getTempItem</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">id</span><span class="p">:</span> <span class="nx">id</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Temp</span><span class="dl">"</span> <span class="p">});</span>
</code></pre></div></div>

<p>箭头函数有几个使用注意点：</p>
<ol>
  <li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
```javascript
function foo() {
  setTimeout(() =&gt; {
 console.log(‘id:’, this.id);
  }, 100);
}</li>
</ol>

<p>var id = 21;</p>

<p>foo.call({ id: 42 });
// id: 42</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。

箭头函数中this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。箭头函数转成ES5的代码如下：
```javascript
// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}
</code></pre></div></div>

<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">args:</span><span class="dl">'</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1">// args: [2, 4, 6, 8]</span>
</code></pre></div></div>
<p>由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>

<h3 id="函数绑定">函数绑定</h3>
<p>ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">foo</span><span class="p">::</span><span class="nx">bar</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>

<span class="nl">foo</span><span class="p">::</span><span class="nx">bar</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">hasOwnProperty</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">hasOwn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">::</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尾调用优化">尾调用优化</h3>
<p>尾调用（Tail Call）指某个函数的最后一步操作是返回另一个函数的调用。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不属于尾调用的情况：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 情况一</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// 调用后还有操作</span>
  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 情况二</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 调用后还有操作</span>
<span class="p">}</span>

<span class="c1">// 情况三</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// 相当于return undefined</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">尾调用优化</code>：函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。所有的调用帧，就形成一个“调用栈”（call stack）。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">();</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">();</span>

<span class="c1">// 等同于</span>
<span class="nx">g</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// 由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</span>
</code></pre></div></div>
<p>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>

<p>尾递归：如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身，做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) </span>
<span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 不属于尾调用</span>
<span class="p">}</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120</span>
</code></pre></div></div>
<p>阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数，改写成尾递归：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 复杂度 O(1)</span>
<span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 120</span>
</code></pre></div></div>
<p>“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，<code class="language-plaintext highlighter-rouge">在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存</code>。</p>

<p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈:func.arguments、func.caller尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>

<h3 id="函数参数的尾逗号">函数参数的尾逗号</h3>
<p>ES7有一个提案，允许函数的最后一个参数有尾逗号（trailing comma）,这样，当以后需要再添加新参数时，这一行代码在版本控制中不会有改变：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">clownsEverywhere</span><span class="p">(</span>
  <span class="nx">param1</span><span class="p">,</span>
  <span class="nx">param2</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="第9章-对象的扩展">第9章 对象的扩展</h2>

<h3 id="属性的简洁表示法">属性的简洁表示法</h3>
<p>ES6允许直接写入变量和函数，作为对象的属性和方法（允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量的值）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">birth</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">2000/01/01</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>

  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span>

  <span class="c1">//等同于birth: birth</span>
  <span class="nx">birth</span><span class="p">,</span>

  <span class="c1">// 等同于hello: function ()...</span>
  <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">我的名字是</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="p">}</span>

<span class="p">};</span>
</code></pre></div></div>
<h3 id="属性名表达式">属性名表达式</h3>
<p>ES6允许字面量定义对象时，用表达式作为属性名（或方法名），表达式必须放在方括号内：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">propKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">propKey</span><span class="p">]:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">bc</span><span class="dl">'</span><span class="p">]:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="p">[</span><span class="dl">'</span><span class="s1">h</span><span class="dl">'</span><span class="o">+</span><span class="dl">'</span><span class="s1">ello</span><span class="dl">'</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>属性名表达式与简洁表示法，不能同时使用:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 报错</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="p">};</span>

<span class="c1">// 正确</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]:</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">};</span>
</code></pre></div></div>

<h3 id="方法的name属性">方法的name属性</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="kd">get</span> <span class="nx">firstName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">Nicholas</span><span class="dl">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">.</span><span class="nx">name</span>   <span class="c1">// "sayName"</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">firstName</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "get firstName"</span>
</code></pre></div></div>
<p>有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">()).</span><span class="nx">name</span> <span class="c1">// "anonymous"</span>

<span class="kd">var</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
<span class="nx">doSomething</span><span class="p">.</span><span class="nx">bind</span><span class="p">().</span><span class="nx">name</span> <span class="c1">// "bound doSomething"</span>
</code></pre></div></div>

<p>如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">key1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">description</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">key2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">key1</span><span class="p">]()</span> <span class="p">{},</span>
  <span class="p">[</span><span class="nx">key2</span><span class="p">]()</span> <span class="p">{},</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key1</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// "[description]"</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key2</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// ""</span>
</code></pre></div></div>

<h3 id="objectis">Object.is()</h3>
<p>相等运算符（==）和严格相等运算符（===）都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span> <span class="c1">//true</span>
<span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span> <span class="c1">// false</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="objectassign">Object.assign()</h3>
<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">source1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">source2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source1</span><span class="p">,</span> <span class="nx">source2</span><span class="p">);</span>
<span class="nx">target</span> <span class="c1">// {a:1, b:2, c:3}</span>
</code></pre></div></div>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
属性名为Symbol值的属性，也会被Object.assign拷贝。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span> <span class="p">},</span> <span class="p">{</span> <span class="p">[</span><span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)]:</span> <span class="dl">'</span><span class="s1">d</span><span class="dl">'</span> <span class="p">})</span>
<span class="c1">// { a: 'b', Symbol(c): 'd' }</span>
</code></pre></div></div>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>

<p>对于嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="na">d</span><span class="p">:</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span> <span class="p">}</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">}</span> <span class="p">}</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span>
<span class="c1">// { a: { b: 'hello' } }</span>
</code></pre></div></div>

<p>Object.assign可以用来处理数组，但是会把数组视为对象：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="c1">// [4, 5, 3]</span>
</code></pre></div></div>

<h3 id="属性的可枚举性">属性的可枚举性</h3>
<p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="mi">123</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">//  {</span>
<span class="c1">//    value: 123,</span>
<span class="c1">//    writable: true,</span>
<span class="c1">//    enumerable: true,</span>
<span class="c1">//    configurable: true</span>
<span class="c1">//  }</span>
</code></pre></div></div>
<p>ES5有三个操作会忽略enumerable为false的属性。</p>
<ol>
  <li>for…in循环：只遍历对象自身的和继承的可枚举的属性</li>
  <li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
  <li>JSON.stringify()：只串行化对象自身的可枚举的属性
ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
这四个操作之中，只有for…in会返回继承的属性。
另外，ES6规定，所有Class的原型的方法都是不可枚举的。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="kd">class</span> <span class="p">{</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{}}.</span><span class="nx">prototype</span><span class="p">,</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">).</span><span class="nx">enumerable</span>
<span class="c1">// false</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="属性的遍历">属性的遍历</h3>
<p>ES6一共有5种方法可以遍历对象的属性。</p>
<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">for...in</code>
for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Object.keys(obj)</code>
Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertyNames(obj)</code>
Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Object.getOwnPropertySymbols(obj)</code>
Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Reflect.ownKeys(obj)</code>
Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p>
  </li>
</ol>

<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则：
首先遍历所有属性名为<code class="language-plaintext highlighter-rouge">数值</code>的属性，按照数字排序。
其次遍历所有属性名为<code class="language-plaintext highlighter-rouge">字符串</code>的属性，按照生成时间排序。
最后遍历所有属性名为<code class="language-plaintext highlighter-rouge">Symbol值</code>的属性，按照生成时间排序。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">({</span> <span class="p">[</span><span class="nb">Symbol</span><span class="p">()]:</span><span class="mi">0</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="na">a</span><span class="p">:</span><span class="mi">0</span> <span class="p">})</span>
<span class="c1">// ['2', '10', 'b', 'a', Symbol()]</span>
</code></pre></div></div>

<h3 id="__proto__属性objectsetprototypeofobjectgetprototypeof">__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h3>
<p><strong>proto__属性用来读取或设置当前对象的prototype对象,在实现上，__proto__调用的是Object.prototype.__proto</strong>。如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// es6的写法</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">someOtherObj</span><span class="p">;</span>

<span class="c1">// es5的写法</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">someOtherObj</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>
<p>无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p>

<h3 id="objectvaluesobjectentries">Object.values()，Object.entries()</h3>
<p>ES7有一个提案，引入了跟Object.keys配套的Object.values和Object.entries。
(略)</p>

<h3 id="对象的扩展运算符">对象的扩展运算符</h3>
<p>ES7有一个提案，将Rest解构赋值/扩展运算符（…）引入对象</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">4</span> <span class="p">};</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 2</span>
<span class="nx">z</span> <span class="c1">// { a: 3, b: 4 }</span>
</code></pre></div></div>

<p>Rest解构赋值不会拷贝继承自原型对象的属性：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kd">let</span> <span class="nx">o2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">o3</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">o2</span> <span class="p">};</span>
<span class="nx">o3</span> <span class="c1">// { b: 2 }</span>
</code></pre></div></div>

<p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">4</span> <span class="p">};</span>
<span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">z</span> <span class="p">};</span>
<span class="nx">n</span> <span class="c1">// { a: 3, b: 4 }</span>
</code></pre></div></div>
<p>这等同于使用Object.assign方法。</p>

<h3 id="objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors()</h3>
<p>ES7有一个提案，提出了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>

<p>可以用来实现Mixin（混入）模式：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">mix</span> <span class="o">=</span> <span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="na">with</span><span class="p">:</span> <span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">mixins</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
      <span class="nx">c</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">mixin</span><span class="p">)</span>
    <span class="p">),</span> <span class="nx">object</span><span class="p">)</span>
<span class="p">});</span>

<span class="c1">// multiple mixins example</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span><span class="na">c</span><span class="p">:</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="kd">with</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="第10章-symbol">第10章 Symbol</h2>
<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是<code class="language-plaintext highlighter-rouge">JavaScript语言的第七种数据类型</code>，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
Symbol值通过Symbol函数生成。这就是说，<code class="language-plaintext highlighter-rouge">对象的属性名现在可以有两种类型</code>，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>

<p>Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。<code class="language-plaintext highlighter-rouge">基本上，它是一种类似于字符串的数据类型</code>。
Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>

<span class="k">typeof</span> <span class="nx">s</span>
<span class="c1">// "symbol"</span>

<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">s1</span> <span class="c1">// Symbol(foo)</span>
<span class="nx">s2</span> <span class="c1">// Symbol(bar)</span>

<span class="nx">s1</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// "Symbol(foo)"</span>
<span class="nx">s2</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// "Symbol(bar)"</span>

<span class="c1">// 没有参数的情况</span>
<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>

<span class="nx">s1</span> <span class="o">===</span> <span class="nx">s2</span> <span class="c1">// false</span>

<span class="c1">// 有参数的情况</span>
<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">s1</span> <span class="o">===</span> <span class="nx">s2</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>Symbol值不能与其他类型的值进行运算，但是，Symbol值可以显式转为字符串，也可以转为布尔值，但是不能转为数值。：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">My symbol</span><span class="dl">'</span><span class="p">);</span>

<span class="dl">"</span><span class="s2">your symbol is </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">sym</span>
<span class="c1">// TypeError: can't convert symbol to string</span>
<span class="s2">`your symbol is </span><span class="p">${</span><span class="nx">sym</span><span class="p">}</span><span class="s2">`</span>
<span class="c1">// TypeError: can't convert symbol to string</span>

<span class="kd">var</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">My symbol</span><span class="dl">'</span><span class="p">);</span>

<span class="nb">String</span><span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="c1">// 'Symbol(My symbol)'</span>
<span class="nx">sym</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// 'Symbol(My symbol)'</span>

<span class="kd">var</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
<span class="nb">Boolean</span><span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="c1">// true</span>
<span class="o">!</span><span class="nx">sym</span>  <span class="c1">// false</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nb">Number</span><span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="c1">// TypeError</span>
<span class="nx">sym</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// TypeError</span>
</code></pre></div></div>

<h3 id="作为属性名的symbol">作为属性名的Symbol</h3>
<p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>

<span class="c1">// 第一种写法</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello!</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 第二种写法</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">mySymbol</span><span class="p">]:</span> <span class="dl">'</span><span class="s1">Hello!</span><span class="dl">'</span>   <span class="c1">// 在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中</span>
<span class="p">};</span>

<span class="c1">// 第三种写法</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">mySymbol</span><span class="p">,</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello!</span><span class="dl">'</span> <span class="p">});</span>

<span class="c1">// 以上写法都得到同样结果</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span> <span class="c1">// "Hello!"</span>
</code></pre></div></div>

<p>Symbol值作为对象属性名时，不能用点运算符:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">mySymbol</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello!</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span> <span class="c1">// undefined</span>
<span class="nx">a</span><span class="p">[</span><span class="dl">'</span><span class="s1">mySymbol</span><span class="dl">'</span><span class="p">]</span> <span class="c1">// "Hello!"</span>
</code></pre></div></div>

<h3 id="属性名的遍历">属性名的遍历</h3>
<p>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。</p>

<p>另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。</p>

<h3 id="symbolforsymbolkeyfor">Symbol.for()，Symbol.keyFor()</h3>
<p>Symbol.for方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">s1</span> <span class="o">===</span> <span class="nx">s2</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取到同一个值。</p>

<p>Symbol.keyFor方法返回一个已登记的Symbol类型值的key：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
<span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span> <span class="c1">// "foo"</span>

<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
<span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到，可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">size</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">class</span> <span class="nx">Collection</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="nx">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">add</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="k">this</span><span class="p">[</span><span class="nx">size</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">item</span><span class="p">;</span>
    <span class="k">this</span><span class="p">[</span><span class="nx">size</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">sizeOf</span><span class="p">(</span><span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">instance</span><span class="p">[</span><span class="nx">size</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Collection</span><span class="p">();</span>
<span class="nx">Collection</span><span class="p">.</span><span class="nx">sizeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 0</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">Collection</span><span class="p">.</span><span class="nx">sizeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 1</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// ['0']</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// ['0']</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// [Symbol(size)]</span>
</code></pre></div></div>

<h3 id="使用symbol实现模块的-singleton-模式">使用Symbol实现模块的 Singleton 模式</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mod.js</span>
<span class="kd">const</span> <span class="nx">FOO_KEY</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">global</span><span class="p">[</span><span class="nx">FOO_KEY</span><span class="p">])</span> <span class="p">{</span>
  <span class="nb">global</span><span class="p">[</span><span class="nx">FOO_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nb">global</span><span class="p">[</span><span class="nx">FOO_KEY</span><span class="p">];</span>
</code></pre></div></div>
<p>上面代码中，可以保证global[FOO_KEY]不会被其他脚本改写。</p>

<h3 id="内置的symbol值">内置的Symbol值</h3>
<p>ES6还提供了11个内置的Symbol值，指向语言内部使用的方法：</p>
<ol>
  <li>
    <p>Symbol.hasInstance：foo instanceof Foo在语言内部，实际调用的是Foo<a href="foo">Symbol.hasInstance</a></p>
  </li>
  <li>
    <p>Symbol.isConcatSpreadable：表示该对象使用Array.prototype.concat()时，是否可以展开
```javascript
let arr1 = [‘c’, ‘d’];
[‘a’, ‘b’].concat(arr1, ‘e’) // [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]
arr1[Symbol.isConcatSpreadable] // undefined</p>
  </li>
</ol>

<p>let arr2 = [‘c’, ‘d’];
arr2[Symbol.isConcatSpreadable] = false;
[‘a’, ‘b’].concat(arr2, ‘e’) // [‘a’, ‘b’, [‘c’,’d’], ‘e’]</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
3. Symbol.species:指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。

4. Symbol.match :指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值

5. Symbol.replace:指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。

6. Symbol.search:指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。

7. Symbol.split:指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。

8. Symbol.iterator:指向该对象的默认遍历器方法
```javascript
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
</code></pre></div></div>

<ol>
  <li>
    <p>Symbol.toPrimitive：指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
  </li>
  <li>
    <p>Symbol.toStringTag：指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。ES6新增内置对象的Symbol.toStringTag属性值如下：
JSON[Symbol.toStringTag]：’JSON’
Math[Symbol.toStringTag]：’Math’
Module对象M[Symbol.toStringTag]：’Module’
ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’
DataView.prototype[Symbol.toStringTag]：’DataView’
Map.prototype[Symbol.toStringTag]：’Map’
Promise.prototype[Symbol.toStringTag]：’Promise’
Set.prototype[Symbol.toStringTag]：’Set’
%TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等
WeakMap.prototype[Symbol.toStringTag]：’WeakMap’
WeakSet.prototype[Symbol.toStringTag]：’WeakSet’
%MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’
%SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’
%StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’
Symbol.prototype[Symbol.toStringTag]：’Symbol’
Generator.prototype[Symbol.toStringTag]：’Generator’
GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’</p>
  </li>
  <li>
    <p>Symbol.unscopables：指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p>
  </li>
</ol>

<h2 id="第11章-proxy和reflect">第11章 Proxy和Reflect</h2>
<p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。ES6原生提供Proxy构造函数，用来生成Proxy实例：
var proxy = new Proxy(target, handler);
target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
  <span class="na">get</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`getting </span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="na">set</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`setting </span><span class="p">${</span><span class="nx">key</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1">//  setting count!</span>
<span class="o">++</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span>
<span class="c1">//  getting count!</span>
<span class="c1">//  setting count!</span>
<span class="c1">//  2</span>
</code></pre></div></div>

<h3 id="proxy支持的拦截操作">Proxy支持的拦截操作</h3>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<ol>
  <li>
    <p>get(target, propKey, receiver)
拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。
参数receiver是一个对象，可选。</p>
  </li>
  <li>
    <p>set(target, propKey, value, receiver)
拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</p>
  </li>
  <li>
    <p>has(target, propKey)
拦截propKey in proxy的操作，以及对象的hasOwnProperty方法，返回一个布尔值。</p>
  </li>
  <li>
    <p>deleteProperty(target, propKey)
拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
  </li>
  <li>
    <p>ownKeys(target)
拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。</p>
  </li>
  <li>
    <p>getOwnPropertyDescriptor(target, propKey)
拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
  </li>
  <li>
    <p>defineProperty(target, propKey, propDesc)
拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
  </li>
  <li>
    <p>preventExtensions(target)
拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>
  </li>
  <li>
    <p>getPrototypeOf(target)
拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>
  </li>
  <li>
    <p>isExtensible(target)
拦截Object.isExtensible(proxy)，返回一个布尔值。</p>
  </li>
  <li>
    <p>setPrototypeOf(target, proto)
拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。
如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
  </li>
  <li>
    <p>apply(target, object, args)
拦截Proxy实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
  </li>
  <li>
    <p>construct(target, args)
拦截Proxy实例作为构造函数调用的操作，比如new proxy(…args)。</p>
  </li>
</ol>

<h3 id="proxyrevocable">Proxy.revocable()</h3>
<p>Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">let</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{};</span>

<span class="kd">let</span> <span class="p">{</span><span class="nx">proxy</span><span class="p">,</span> <span class="nx">revoke</span><span class="p">}</span> <span class="o">=</span> <span class="nb">Proxy</span><span class="p">.</span><span class="nx">revocable</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>

<span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// 123</span>

<span class="nx">revoke</span><span class="p">();</span>
<span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// TypeError: Revoked</span>
</code></pre></div></div>

<h3 id="reflect">Reflect</h3>
<p>Reflect对象的设计目的有这样几个：</p>
<ol>
  <li>
    <p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</p>
  </li>
  <li>
    <p>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p>
  </li>
  <li>
    <p>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
  </li>
  <li>
    <p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就<code class="language-plaintext highlighter-rouge">让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础</code>。也就是说，<code class="language-plaintext highlighter-rouge">不管Proxy怎么修改默认行为，总可以在Reflect上获取默认行为</code>：</p>
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">loggedObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
  <span class="kd">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">get</span><span class="dl">'</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
 <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">delete</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">);</span>
 <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">has</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">);</span>
 <span class="k">return</span> <span class="nb">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>    </div>
    <p>上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
  </li>
</ol>

<h3 id="reflect对象的方法">Reflect对象的方法</h3>
<p>Reflect.apply(target,thisArg,args)</p>

<p>Reflect.construct(target,args)
等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</p>

<p>Reflect.get(target,name,receiver)
查找并返回target对象的name属性，如果没有该属性，则返回undefined。
如果name属性部署了读取函数，则读取函数的this绑定receiver。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="p">},</span>
  <span class="na">bar</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 下面语句会让 this.bar()</span>
<span class="c1">// 变成调用 wrapper.bar()</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span> <span class="nx">wrapper</span><span class="p">);</span>


<span class="nb">Reflect</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="nx">name</span><span class="p">,</span><span class="nx">value</span><span class="p">,</span><span class="nx">receiver</span><span class="p">)</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="nx">name</span><span class="p">,</span><span class="nx">desc</span><span class="p">)</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="nx">name</span><span class="p">)</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="nx">name</span><span class="p">)</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
<span class="nb">Reflect</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>

<span class="nb">Reflect</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
</code></pre></div></div>
<p>读取对象的__proto__属性，对应Object.getPrototypeOf(obj)</p>

<p>Reflect.setPrototypeOf(target, prototype)</p>

<h2 id="第12章-二进制数组">第12章 二进制数组</h2>
<p>二进制数组允许开发者<code class="language-plaintext highlighter-rouge">以数组下标的形式，直接操作内存</code>，<code class="language-plaintext highlighter-rouge">使得开发者有可能通过JavaScript与操作系统的原生接口进行二进制通信</code>。</p>

<h3 id="二进制数组由三类对象组成">二进制数组由三类对象组成</h3>
<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ArrayBuffer</code>对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">TypedArray</code>视图：是一组不同类型视图的统称，共包括9种类型的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float32Array（32位浮点数）数组视图等等。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">DataView</code>视图：可以自定义复合格式的视图，比如第一个字节是Uint8（无符号8位整数）、第二、三个字节是Int16（16位整数）、第四个字节开始是Float32（32位浮点数）等等，此外还可以自定义字节序。</p>
  </li>
</ol>

<p>即，ArrayBuffer对象代表原始的二进制数据，TypedArray视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。</p>

<p><code class="language-plaintext highlighter-rouge">注意，二进制数组并不是真正的数组，而是类似数组的对象。</code></p>

<h3 id="arraybuffer对象">ArrayBuffer对象</h3>
<p>ArrayBuffer对象代表储存二进制数据的一段内存，它<code class="language-plaintext highlighter-rouge">不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写</code>，视图的作用是以指定格式解读二进制数据：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">dataView</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">DataView</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
<span class="nx">dataView</span><span class="p">.</span><span class="nx">getUint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 0</span>
</code></pre></div></div>

<p>TypedArray视图的构造函数，除了接受ArrayBuffer实例作为参数，还可以接受普通数组作为参数，直接分配内存生成底层的ArrayBuffer实例，并同时完成对这段内存的赋值:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">typedArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span>
<span class="nx">typedArray</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 3</span>

<span class="nx">typedArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">typedArray</span> <span class="c1">// [5, 1, 2]</span>
</code></pre></div></div>

<p>ArrayBuffer实例的<code class="language-plaintext highlighter-rouge">byteLength属性</code>，返回所分配的内存区域的<code class="language-plaintext highlighter-rouge">字节长度</code>：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
<span class="nx">buffer</span><span class="p">.</span><span class="nx">byteLength</span>
<span class="c1">// 32</span>
</code></pre></div></div>

<p>ArrayBuffer实例的<code class="language-plaintext highlighter-rouge">slice方法</code>，可以将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">newBuffer</span> <span class="o">=</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="c1">// 拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束）</span>
</code></pre></div></div>
<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>

<p>ArrayBuffer的静态方法<code class="language-plaintext highlighter-rouge">isView</code>，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="nb">ArrayBuffer</span><span class="p">.</span><span class="nx">isView</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span> <span class="c1">// false</span>

<span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Int32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
<span class="nb">ArrayBuffer</span><span class="p">.</span><span class="nx">isView</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="typedarray视图">TypedArray视图</h3>
<p>普通数组与TypedArray数组的差异主要在以下方面：</p>
<ol>
  <li>TypedArray数组的所有成员，都是同一种类型。</li>
  <li>TypedArray数组的成员是连续的，不会有空位。</li>
  <li>TypedArray数组成员的默认值为0。比如，new Array(10)返回一个普通数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个TypedArray数组，里面10个成员都是0。</li>
  <li>TypedArray数组只是一层视图，<code class="language-plaintext highlighter-rouge">本身不储存数据</code>，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li>
</ol>

<p>视图可以不通过ArrayBuffer对象，直接分配内存而生成：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">f64a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float64Array</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="nx">f64a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">f64a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="nx">f64a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f64a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">f64a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>
<p>普通数组的操作方法和属性，对TypedArray数组完全适用，除了concat方法。
<code class="language-plaintext highlighter-rouge">TypedArray数组只能处理小端字节序！DataView对象，可以设定字节序。</code></p>

<p>不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。TypedArray数组（除了Uint8ClampedArray）的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">uint8</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nx">uint8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="nx">uint8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// 0</span>

<span class="nx">uint8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nx">uint8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// 255</span>
</code></pre></div></div>
<p>Uint8ClampedArray规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即0。</p>

<p>buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。
set方法用于复制数组（普通数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。
subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。
(其他方法，略)</p>

<h3 id="dataview视图">DataView视图</h3>
<p>在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>

<p>DataView实例提供8个方法读取内存：
getInt8：读取1个字节，返回一个8位整数。
getUint8：读取1个字节，返回一个无符号的8位整数。
getInt16：读取2个字节，返回一个16位整数。
getUint16：读取2个字节，返回一个无符号的16位整数。
getInt32：读取4个字节，返回一个32位整数。
getUint32：读取4个字节，返回一个无符号的32位整数。
getFloat32：读取4个字节，返回一个32位浮点数。
getFloat64：读取8个字节，返回一个64位浮点数。
如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>

<h2 id="第13章-set和map数据结构">第13章 Set和Map数据结构</h2>

<h3 id="set">Set</h3>
<p>可以利用Set去除数组重复成员：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 去除数组的重复成员</span>
<span class="p">[...</span><span class="k">new</span> <span class="nb">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">)]</span>
</code></pre></div></div>

<p>Set的属性：
Set.prototype.constructor：构造函数，默认就是Set函数。
Set.prototype.size：返回Set实例的成员总数。</p>

<p>Set的操作方法：
add(value)：添加某个值，返回Set结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。</p>

<p>Set的遍历方法：
keys()：返回键名的遍历器，由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="kd">set</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="c1">// 2</span>
<span class="c1">// 4</span>
<span class="c1">// 6</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Set的遍历顺序就是插入顺序</code>。</p>

<p>使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>

<span class="c1">// 并集</span>
<span class="kd">let</span> <span class="nx">union</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">]);</span>
<span class="c1">// Set {1, 2, 3, 4}</span>

<span class="c1">// 交集</span>
<span class="kd">let</span> <span class="nx">intersect</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">)));</span>
<span class="c1">// set {2, 3}</span>

<span class="c1">// 差集</span>
<span class="kd">let</span> <span class="nx">difference</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">b</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">)));</span>
<span class="c1">// Set {1}</span>
</code></pre></div></div>

<h3 id="weakset">WeakSet</h3>
<p>WeakSet与Set有两个区别：</p>
<ol>
  <li>WeakSet的成员只能是对象，而不能是其他类型的值。</li>
  <li>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员（WeakSet没有size属性），因此WeakSet是不可遍历的。
WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</li>
</ol>

<h3 id="map">Map</h3>
<p>Map数据结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="na">p</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello World</span><span class="dl">'</span><span class="p">};</span>

<span class="nx">m</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="dl">'</span><span class="s1">content</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// "content"</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">m</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// false</span>
</code></pre></div></div>
<p>只有对同一个对象的引用，Map结构才将其视为同一个键，Map的键实际上是跟内存地址绑定的。</p>

<p>Map的操作方法和遍历方法与Set类似，略。</p>

<p>如果所有Map的键都是字符串，它可以转为对象：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">().</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">no</span><span class="dl">'</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">myMap</span><span class="p">)</span>
<span class="c1">// { yes: true, no: false }</span>
</code></pre></div></div>

<p>Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">strMapToJson</span><span class="p">(</span><span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">strMap</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">().</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">no</span><span class="dl">'</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">strMapToJson</span><span class="p">(</span><span class="nx">myMap</span><span class="p">)</span>
<span class="c1">// '{"yes":true,"no":false}'</span>
</code></pre></div></div>
<p>另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mapToArrayJson</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([...</span><span class="nx">map</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">().</span><span class="kd">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">7</span><span class="p">).</span><span class="kd">set</span><span class="p">({</span><span class="na">foo</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[</span><span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">]);</span>
<span class="nx">mapToArrayJson</span><span class="p">(</span><span class="nx">myMap</span><span class="p">)</span>
<span class="c1">// '[[true,7],[{"foo":3},["abc"]]]'</span>
</code></pre></div></div>

<h3 id="weakmap">WeakMap</h3>
<p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。
WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。
WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>

<p>WeakMap应用的典型场合就是DOM节点作为键名：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">logo</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">myWeakmap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>

<span class="nx">myWeakmap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">myElement</span><span class="p">,</span> <span class="p">{</span><span class="na">timesClicked</span><span class="p">:</span> <span class="mi">0</span><span class="p">});</span>

<span class="nx">myElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">logoData</span> <span class="o">=</span> <span class="nx">myWeakmap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">myElement</span><span class="p">);</span>
  <span class="nx">logoData</span><span class="p">.</span><span class="nx">timesClicked</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">myWeakmap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">myElement</span><span class="p">,</span> <span class="nx">logoData</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="第14章-iterator和forof循环">第14章 Iterator和for…of循环</h2>

<p>Iterator的作用有三个：</p>
<ol>
  <li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
  <li>使得数据结构的成员能够按某种次序排列；</li>
  <li>ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</li>
</ol>

<p>Iterator的遍历过程：</p>
<ol>
  <li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
  <li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
  <li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
  <li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。
每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</li>
</ol>

<p>由于Iterator只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 无限运行的遍历器对象</span>
<span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">idMaker</span><span class="p">();</span>

<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// '0'</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// '1'</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// '2'</span>
<span class="c1">// ...</span>

<span class="kd">function</span> <span class="nx">idMaker</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">next</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span><span class="na">value</span><span class="p">:</span> <span class="nx">index</span><span class="o">++</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="kc">false</span><span class="p">};</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="数据结构的默认iterator接口">数据结构的默认Iterator接口</h3>
<p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性。一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数。Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内。一个对象如果要有可被for…of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">RangeIterator</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stop</span> <span class="o">=</span> <span class="nx">stop</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>

  <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">{</span><span class="na">done</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">value</span><span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span><span class="na">done</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="kc">undefined</span><span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">RangeIterator</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。</p>

<p>对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的Iterator接口：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">iterable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span>
  <span class="mi">2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">length</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]:</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
<span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span> <span class="c1">// 'a', 'b', 'c'</span>
<span class="p">}</span>
</code></pre></div></div>
<p>注意，普通对象部署数组的Symbol.iterator方法，并无效果：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">iterable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">c</span><span class="p">:</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">length</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]:</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
<span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span> <span class="c1">// undefined, undefined, undefined</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="默认调用iterator接口即symboliterator方法的场合">默认调用Iterator接口（即Symbol.iterator方法）的场合</h3>
<ol>
  <li>解构赋值</li>
  <li>扩展运算符</li>
  <li>yield*</li>
  <li>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口，如：
for…of
Array.from()
Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）
Promise.all()
Promise.race()</li>
</ol>

<h3 id="字符串的iterator接口">字符串的Iterator接口</h3>
<p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">someString</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hi</span><span class="dl">"</span><span class="p">;</span>
<span class="k">typeof</span> <span class="nx">someString</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
<span class="c1">// "function"</span>

<span class="kd">var</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">someString</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>

<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: "h", done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: "i", done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: undefined, done: true }</span>
</code></pre></div></div>

<h3 id="iterator接口与generator函数">Iterator接口与Generator函数</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">*</span> <span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">yield</span> <span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// hello</span>
<span class="c1">// world</span>
</code></pre></div></div>

<h3 id="遍历器对象的returnthrow">遍历器对象的return()，throw()</h3>
<p>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。
return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">isAtEndOfFile</span><span class="p">())</span> <span class="p">{</span>
        <span class="nx">file</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
        <span class="k">return</span> <span class="p">{</span> <span class="na">done</span><span class="p">:</span> <span class="kc">true</span> <span class="p">};</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="k">return</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">file</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
      <span class="k">return</span> <span class="p">{</span> <span class="na">done</span><span class="p">:</span> <span class="kc">true</span> <span class="p">};</span>
    <span class="p">},</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">fileName</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// 触发return()方法</span>
  <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>throw方法主要是配合Generator函数使用，一般的遍历器对象用不到这个方法。</p>

<h3 id="forof循环">for…of循环</h3>
<p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。</p>

<h2 id="第15章-generator-函数">第15章 Generator 函数</h2>
<p>调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。必须调用遍历器对象的next方法，使得指针移向下一个状态，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">helloWorldGenerator</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">ending</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">hw</span> <span class="o">=</span> <span class="nx">helloWorldGenerator</span><span class="p">();</span>

<span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: 'hello', done: false }</span>

<span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: 'world', done: false }</span>

<span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: 'ending', done: true }</span>

<span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: undefined, done: true }</span>
</code></pre></div></div>

<h3 id="yield语句">yield语句</h3>
<p>遍历器对象的next方法的运行逻辑如下：</p>
<ol>
  <li>遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>
  <li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li>
  <li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>
  <li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li>
</ol>

<p>yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，<code class="language-plaintext highlighter-rouge">下一次再从该位置继续向后执行</code>，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值。</p>

<p>由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口(此时不再需要调用next方法)：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myIterable</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">myIterable</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[...</span><span class="nx">myIterable</span><span class="p">]</span> <span class="c1">// [1, 2, 3]</span>
</code></pre></div></div>

<h3 id="next方法的参数">next方法的参数</h3>
<p>yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="kc">true</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">reset</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">reset</span><span class="p">)</span> <span class="p">{</span> <span class="nx">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 0, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// { value: 0, done: false }</span>
</code></pre></div></div>
<p>通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>

<p>注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。</p>

<h3 id="generatorprototypethrow">Generator.prototype.throw()</h3>
<p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">内部捕获</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">外部捕获</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 内部捕获 a</span>
<span class="c1">// 外部捕获 b</span>
</code></pre></div></div>
<p>上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。
注意，<code class="language-plaintext highlighter-rouge">不要混淆遍历器对象的throw方法和全局的throw命令</code>。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。</p>

<p>如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">内部捕获</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">外部捕获</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 外部捕获 a</span>
</code></pre></div></div>

<p>throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// a</span>
<span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">()</span> <span class="c1">// b</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// c</span>
</code></pre></div></div>

<p>Generator函数体内抛出的错误，也可以被函数体外的catch捕获：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="o">*</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
  <span class="k">yield</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>

<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value:3, done:false }</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。</p>

<h3 id="generatorprototypereturn">Generator.prototype.return()</h3>
<p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>        <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// { value: "foo", done: true }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>        <span class="c1">// { value: undefined, done: true }</span>
</code></pre></div></div>

<p>如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">numbers</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">()</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { done: false, value: 1 }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { done: false, value: 2 }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="c1">// { done: false, value: 4 }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { done: false, value: 5 }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { done: true, value: 7 }</span>
</code></pre></div></div>

<h3 id="yield语句-1">yield*语句</h3>
<p>如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。yield*语句，用来在一个Generator函数里面执行另一个Generator函数。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">foo</span><span class="p">();</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">foo</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">v</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">bar</span><span class="p">()){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// "x"</span>
<span class="c1">// "a"</span>
<span class="c1">// "b"</span>
<span class="c1">// "y"</span>
</code></pre></div></div>
<p>yield<em>后面的Generator函数（没有return语句时），不过是for…of的一种简写形式，完全可以用后者替代前者。有return语句时，则需要用var value = yield</em> iterator的形式获取return语句的值。实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。</p>

<h3 id="作为对象属性的generator函数">作为对象属性的Generator函数</h3>
<p>如果一个对象的属性是Generator函数，可以简写成下面的形式：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">*</span> <span class="nx">myGeneratorMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="err">···</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="generator函数的this">Generator函数的this</h3>
<p>（略）</p>

<h3 id="generator与协程">Generator与协程</h3>
<p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。
从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>

<p>Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。
如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。</p>

<h3 id="generator的应用">Generator的应用</h3>
<p>（略）</p>

<h2 id="第16章-promise对象">第16章 Promise对象</h2>
<p>ES6原生提供了Promise对象。
Promise对象有以下两个特点。</p>
<ol>
  <li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
  <li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。
Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject：
```javascript
var promise = new Promise(function(resolve, reject) {
  // … some code</li>
</ol>

<p>if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数：
```javascript
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre></div></div>
<p>Promise新建后就会立即执行，然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以“Resolved”最后输出。</p>

<p>reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">fail</span><span class="dl">'</span><span class="p">)),</span> <span class="mi">3000</span><span class="p">)</span>
<span class="p">})</span>

<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">p2</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">))</span>
<span class="c1">// Error: fail</span>

</code></pre></div></div>
<p>这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行.</p>

<h3 id="promiseprototypethen">Promise.prototype.then()</h3>
<p>它的作用是为Promise实例添加状态改变时的回调函数。then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getJSON</span><span class="p">(</span><span class="dl">"</span><span class="s2">/posts.json</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">json</span><span class="p">.</span><span class="nx">post</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="promiseprototypecatch">Promise.prototype.catch()</h3>
<p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getJSON</span><span class="p">(</span><span class="dl">"</span><span class="s2">/posts.json</span><span class="dl">"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">发生错误！</span><span class="dl">'</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>
<p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。
建议总是使用catch方法，而不使用then方法的第二个参数。</p>

<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>

<h3 id="promiseall">Promise.all()</h3>
<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。
var p = Promise.all([p1, p2, p3]);  // p1、p2、p3都是Promise对象的实例，如果不是，就会先调用Promise.resolve方法，将参数转为Promise实例，再进一步处理</p>

<p>p的状态由p1、p2、p3决定，分成两种情况:</p>
<ol>
  <li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
  <li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
```javascript
// 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON(“/post/” + id + “.json”);
});</li>
</ol>

<p>Promise.all(promises).then(function (posts) {
  // …
}).catch(function(reason){
  // …
});</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### Promise.race()
Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例:
var p = Promise.race([p1,p2,p3]);
只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。
```javascript
// 处理超时
var p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error('request timeout')), 5000)
  })
])
p.then(response =&gt; console.log(response))
p.catch(error =&gt; console.log(error))
</code></pre></div></div>

<h3 id="promiseresolve">Promise.resolve()</h3>
<p>将现有对象转为Promise对象。参数分成四种情况：</p>
<ol>
  <li>
    <p>参数是一个Promise实例
如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>
  </li>
  <li>
    <p>参数是一个thenable对象
thenable对象指的是具有then方法的对象，Promise.resolve会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p>
  </li>
  <li>
    <p>参数不是具有then方法的对象，或根本就不是对象
Promise.resolve返回一个新的Promise对象，状态为Resolved。</p>
  </li>
  <li>
    <p>不带有任何参数
直接返回一个Resolved状态的Promise对象。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p>
  </li>
</ol>

<p>需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">three</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">two</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">one</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// one</span>
<span class="c1">// two</span>
<span class="c1">// three</span>
</code></pre></div></div>

<h3 id="promisereject">Promise.reject()</h3>
<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。</p>

<h3 id="done">done()</h3>
<p>(略)</p>

<h3 id="finally">finally()</h3>
<p>(略)</p>

<h3 id="generator函数与promise的结合">Generator函数与Promise的结合</h3>
<p>(略)</p>

<h2 id="第17章-异步操作和async函数">第17章 异步操作和Async函数</h2>

<h3 id="回调函数promise">回调函数、Promise</h3>
<p>（略）</p>

<h3 id="generator函数执行异步任务">Generator函数执行异步任务</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fetch</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">node-fetch</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">https://api.github.com/users/github</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="thunk函数">Thunk函数</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">m</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">传值调用</code>：即在进入函数体之前，就计算x + 5的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 传值调用时，等同于</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">传名调用</code>:即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 传名调用时，等同于</span>
<span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
</code></pre></div></div>

<p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">m</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>

<span class="c1">// 等同于</span>

<span class="kd">var</span> <span class="nx">thunk</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">thunk</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">thunk</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>凡是用到原参数的地方，对Thunk函数求值即可。这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p>

<h3 id="javascript语言的thunk函数">JavaScript语言的Thunk函数</h3>
<p>在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正常版本的readFile（多参数版本）</span>
<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>

<span class="c1">// Thunk版本的readFile（单参数版本）</span>
<span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fileName</span><span class="p">);</span>
<span class="nx">readFileThunk</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fileName</span><span class="p">){</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>
<p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Thunk函数转换器</span>
<span class="kd">var</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="thunkify模块">Thunkify模块</h3>
<p>$ npm install thunkify</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">thunkify</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">thunkify</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">read</span> <span class="o">=</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
<span class="nx">read</span><span class="p">(</span><span class="dl">'</span><span class="s1">package.json</span><span class="dl">'</span><span class="p">)(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">str</span><span class="p">){</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="generator-函数的流程管理">Generator 函数的流程管理</h3>
<p>ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">();</span>

  <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">next</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nx">run</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="co模块">co模块</h3>

<h3 id="async函数">async函数</h3>
<p>async函数就是Generator函数的语法糖。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fileName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div>
<p>写成async函数:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">asyncReadFile</span> <span class="o">=</span> <span class="k">async</span> <span class="kd">function</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/fstab</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">/etc/shells</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div>
<p>async函数对 Generator 函数的改进，体现在以下四点。</p>
<ol>
  <li>
    <p>内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。
  var result = asyncReadFile();
上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。</p>
  </li>
  <li>
    <p>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
  </li>
  <li>
    <p>更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
  </li>
  <li>
    <p>返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。可以用then方法指定下一步的操作。</p>
  </li>
</ol>

<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。</p>

<h3 id="async函数语法">async函数语法</h3>
<ol>
  <li>async函数返回一个Promise对象
async函数内部return语句返回的值，会成为then方法回调函数的参数:
```javascript
async function f() {
  return ‘hello world’;
}</li>
</ol>

<p>f().then(v =&gt; console.log(v))
// “hello world”</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。

2. async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。

3. 正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。

4. 如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。

### async函数的实现
async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里：
```javascript
async function fn(args){
  // ...
}

// 等同于

function fn(args){
  return spawn(function*() {
    // ...
  });
}
</code></pre></div></div>
<p>所有的async函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>

<hr />
<p>（略）</p>

<h2 id="第18章-class">第18章 Class</h2>
<p>基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。ES6的类，完全可以看作构造函数的另一种写法：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">typeof</span> <span class="nx">Point</span> <span class="c1">// "function"</span>
<span class="nx">Point</span> <span class="o">===</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="c1">// true</span>
</code></pre></div></div>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</p>

<p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(){</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">(){</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="nx">toValue</span><span class="p">(){</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>

<span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">toString</span><span class="p">(){},</span>
  <span class="nx">toValue</span><span class="p">(){}</span>
<span class="p">};</span>
</code></pre></div></div>
<p>在类的实例上面调用方法，其实就是调用原型上的方法：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class B {}
let b = new B();

b.constructor === B.prototype.constructor // true
</code></pre></div></div>
<p>prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Point</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与ES5的行为不一致：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES 6</span>
<span class="kd">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// []</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// ["constructor","toString"]</span>


<span class="c1">// ES 5</span>
<span class="kd">var</span> <span class="nx">Point</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// ["toString"]</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// ["constructor","toString"]</span>
</code></pre></div></div>

<h3 id="constructor方法">constructor方法</h3>
<p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。
类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>

<h3 id="类的实例对象">类的实例对象</h3>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//定义类</span>
<span class="kd">class</span> <span class="nx">Point</span> <span class="p">{</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">(</span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">, </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">)</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="nx">point</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// (2, 3)</span>

<span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false  !!!</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">toString</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>与ES5一样，类的所有实例共享一个原型对象：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="nx">p1</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">__proto__</span>
<span class="c1">//true</span>
</code></pre></div></div>

<p>不存在变量提升：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span> <span class="c1">// ReferenceError</span>
<span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{}</span>
</code></pre></div></div>

<p>与函数一样，类也可以使用表达式的形式定义：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="kd">class</span> <span class="p">{</span>
  <span class="nx">getClassName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Me</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>ES6的类不提供私有方法，可以利用Symbol来模拟：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">snaf</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">snaf</span><span class="dl">'</span><span class="p">);</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">myClass</span><span class="p">{</span>

  <span class="c1">// 公有方法</span>
  <span class="nx">foo</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="nx">bar</span><span class="p">](</span><span class="nx">baz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 私有方法</span>
  <span class="p">[</span><span class="nx">bar</span><span class="p">](</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">snaf</span><span class="p">]</span> <span class="o">=</span> <span class="nx">baz</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="this的指向">this的指向</h3>
<p>类的方法内部如果含有this，它默认指向类的实例，单独使用方法时容易出错：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Logger</span> <span class="p">{</span>
  <span class="nx">printName</span><span class="p">(</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">there</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">print</span><span class="p">(</span><span class="s2">`Hello </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">print</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Logger</span><span class="p">();</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">printName</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">logger</span><span class="p">;</span>
<span class="nx">printName</span><span class="p">();</span> <span class="c1">// TypeError: Cannot read property 'print' of undefined</span>
</code></pre></div></div>
<p>应该使用箭头函数：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Logger</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">there</span><span class="dl">'</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">print</span><span class="p">(</span><span class="s2">`Hello </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>类和模块的内部，默认就是严格模式。</p>

<h3 id="class的继承">Class的继承</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ColorPoint</span> <span class="kd">extends</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 调用父类的constructor(x, y)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">super</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// 调用父类的toString()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>

<h3 id="类的prototype属性和__proto__属性">类的prototype属性和__proto__属性</h3>
<p>Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</p>
<ol>
  <li>子类的__proto__属性，表示<code class="language-plaintext highlighter-rouge">构造函数的继承</code>，总是指向父类。</li>
  <li>子类prototype属性的__proto__属性，表示<code class="language-plaintext highlighter-rouge">方法的继承</code>，总是指向父类的prototype属性。
```javascript
class A {
}</li>
</ol>

<p>class B extends A {
}</p>

<p>B.<strong>proto</strong> === A // true
B.prototype.<strong>proto</strong> === A.prototype // true</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这样的结果是因为，类的继承是按照下面的模式实现的:
```javascript
class A {
}

class B {
}

// B的实例继承A的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B继承A的静态属性
Object.setPrototypeOf(B, A);
</code></pre></div></div>
<p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</p>

<h3 id="extends-的继承目标">Extends 的继承目标</h3>
<p>只要是一个有prototype属性的函数，就能被继承。由于函数都有prototype属性（除了Function.prototype函数），因此可以是任意函数。</p>

<p>子类继承Object类：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="nb">Object</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span> <span class="c1">// true</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div>
<p>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p>

<p>不存在任何继承:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">A</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</code></pre></div></div>
<p>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</p>

<p>子类继承null：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="kc">null</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="objectgetprototypeof">Object.getPrototypeOf()</h3>
<p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Object.getPrototypeOf(ColorPoint) === Point
// true
</code></pre></div></div>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>

<h3 id="super关键字">super关键字</h3>
<p>super这个关键字，有两种用法，含义不同。</p>
<ol>
  <li>作为函数调用时（即super(…args)），super代表父类的构造函数。</li>
  <li>作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</li>
</ol>

<h3 id="实例的__proto__属性">实例的__proto__属性</h3>
<p>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</p>

<h3 id="原生构造函数的继承">原生构造函数的继承</h3>
<p>ECMAScript的原生构造函数大致有下面这些：
Boolean()
Number()
String()
Array()
Date()
Function()
RegExp()
Error()
Object()
ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p>

<h3 id="class的取值函数getter和存值函数setter">Class的取值函数（getter）和存值函数（setter）</h3>
<p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>

<h3 id="class的静态方法">Class的静态方法</h3>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Foo</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="c1">// 'hello'</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span>
<span class="c1">// TypeError: foo.classMethod is not a function</span>
</code></pre></div></div>

<h3 id="class的静态属性和实例属性">Class的静态属性和实例属性</h3>
<p>ES6明确规定，Class内部只有静态方法，没有静态属性。
目前只有这种方法可行：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="c1">// 1</span>
</code></pre></div></div>

<h3 id="newtarget属性">new.target属性</h3>
<p>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。需要注意的是，子类继承父类时，new.target会返回子类。</p>

<h3 id="mixin模式的实现">Mixin模式的实现</h3>
<p>(略)</p>

<h2 id="第19章-修饰器">第19章 修饰器</h2>
<p>修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案。修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">testable</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">target</span><span class="p">.</span><span class="nx">isTestable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">testable</span>
<span class="kd">class</span> <span class="nx">MyTestableClass</span> <span class="p">{}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">MyTestableClass</span><span class="p">.</span><span class="nx">isTestable</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>
<p>修饰器本质就是编译时执行的函数。修饰器函数的第一个参数，就是所要修饰的目标类。</p>

<p>可以在修饰器外面再封装一层函数来为修饰器增加参数：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">testable</span><span class="p">(</span><span class="nx">isTestable</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">target</span><span class="p">.</span><span class="nx">isTestable</span> <span class="o">=</span> <span class="nx">isTestable</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">testable</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="kd">class</span> <span class="nx">MyTestableClass</span> <span class="p">{}</span>
<span class="nx">MyTestableClass</span><span class="p">.</span><span class="nx">isTestable</span> <span class="c1">// true</span>

<span class="p">@</span><span class="nd">testable</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{}</span>
<span class="nx">MyClass</span><span class="p">.</span><span class="nx">isTestable</span> <span class="c1">// false</span>
</code></pre></div></div>

<h3 id="方法的修饰">方法的修饰</h3>

<p>修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="p">@</span><span class="nd">nonenumerable</span>
  <span class="kd">get</span> <span class="nx">kidCount</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">nonenumerable</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">descriptor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="为什么修饰器不能用于函数">为什么修饰器不能用于函数？</h3>
<p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">@</span><span class="nd">add</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>
<p>因为函数提升，使得实际执行的代码是下面这样：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">counter</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">add</span><span class="p">;</span>

<span class="p">@</span><span class="nd">add</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="core-decoratorsjs">core-decorators.js</h3>
<p>（略）</p>

<h3 id="使用修饰器实现自动发布事件">使用修饰器实现自动发布事件</h3>
<p>（略）</p>

<h3 id="mixin">Mixin</h3>
<p>（略）</p>

<h3 id="trait">Trait</h3>
<p>（略）</p>

<h2 id="第20章-module">第20章 Module</h2>
<p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>

<p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。<code class="language-plaintext highlighter-rouge">CommonJS和AMD模块，都只能在运行时确定这些东西</code>。比如，CommonJS模块就是对象，输入时必须查找对象属性。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CommonJS模块</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readFile</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">_fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">stat</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">exists</span><span class="p">,</span> <span class="nx">readfile</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">readfile</span><span class="p">;</span>
</code></pre></div></div>
<p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>

<p>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES6模块</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readFile</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>
<p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为<code class="language-plaintext highlighter-rouge">“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高</code>。由于ES6模块是编译时加载，使得静态分析成为可能。</p>

<p>浏览器使用ES6模块的语法如下:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">module</span><span class="dl">"</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">foo.js</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<h3 id="es6的模块自动采用严格模式">ES6的模块自动采用严格模式</h3>
<p>严格模式主要有以下限制:
变量必须声明后再使用
函数的参数不能有同名属性，否则报错
不能使用with语句
不能对只读属性赋值，否则报错
不能使用前缀0表示八进制数，否则报错
不能删除不可删除的属性，否则报错
不能删除变量delete prop，会报错，只能删除属性delete global[prop]
eval不会在它的外层作用域引入变量
eval和arguments不能被重新赋值
arguments不会自动反映函数参数的变化
不能使用arguments.callee
不能使用arguments.caller
禁止this指向全局对象
不能使用fn.caller和fn.arguments获取函数调用的堆栈
增加了保留字（比如protected、static和interface）</p>

<h3 id="export命令">export命令</h3>
<p>export命令用于规定模块的对外接口。一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// profile.js</span>
<span class="kd">var</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Michael</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Jackson</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">year</span> <span class="o">=</span> <span class="mi">1958</span><span class="p">;</span>

<span class="k">export</span> <span class="p">{</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">,</span> <span class="nx">year</span><span class="p">};</span>
</code></pre></div></div>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</p>

<p>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写法一</span>
<span class="k">export</span> <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 写法二</span>
<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">export</span> <span class="p">{</span><span class="nx">m</span><span class="p">};</span>

<span class="c1">// 写法三</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">export</span> <span class="p">{</span><span class="nx">n</span> <span class="k">as</span> <span class="nx">m</span><span class="p">};</span>
</code></pre></div></div>
<p>它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。
export语句输出的接口，与其对应的值是动态绑定关系，即<code class="language-plaintext highlighter-rouge">通过该接口，可以取到模块内部实时的值</code>。
这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新。
export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p>

<h3 id="import命令">import命令</h3>
<p>import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>

<p>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">foo</span><span class="p">();</span> <span class="c1">// 不会报错，因为import的执行早于foo的调用</span>

<span class="k">import</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">my_module</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="模块的整体加载">模块的整体加载</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">circle</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./circle</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">圆面积：</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">area</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">圆周长：</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">circumference</span><span class="p">(</span><span class="mi">14</span><span class="p">));</span>
</code></pre></div></div>

<h3 id="export-default命令">export default命令</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// export-default.js</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// import-default.js</span>
<span class="k">import</span> <span class="nx">customName</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./export-default</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">customName</span><span class="p">();</span> <span class="c1">// 'foo'</span>
</code></pre></div></div>

<p>export default命令用于指定模块的默认输出。本质上，export default就是输出一个叫做default的变量或方法，然后系统允许导入时为它取任意名字。</p>

<p>export default也可以用来输出类:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MyClass.js</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// main.js</span>
<span class="k">import</span> <span class="nx">MyClass</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">MyClass</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="模块的继承">模块的继承</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="o">*</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">circle</span><span class="dl">'</span><span class="p">;</span>  <span class="c1">// 继承了circle模块</span>
<span class="k">export</span> <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="mf">2.71828182846</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</p>

<h3 id="es6模块加载的实质">ES6模块加载的实质</h3>
<p>CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。
ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>

<p>export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mod.js</span>
<span class="kd">function</span> <span class="nx">C</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">show</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">sum</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>

<span class="c1">// x.js</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">c</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./mod</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">add</span><span class="p">();</span>

<span class="c1">// y.js</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">c</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./mod</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>

<span class="c1">// main.js</span>
<span class="k">import</span> <span class="dl">'</span><span class="s1">./x</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">'</span><span class="s1">./y</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>
<p>$ babel-node main.js
1</p>

<h3 id="循环加载">循环加载</h3>
<p>CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>

<p>ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使用import从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。(即，可能会由于循环加载导致取到的值为undefined)</p>

:ET