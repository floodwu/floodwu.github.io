---
layout: post
title:  "《UNIX环境高级编程》"
date: 2017-06-16 00:00:01
categories: 读书
tags: Unix C
excerpt: ""
---

* content
{:toc}

# 第1章 UNIX基础知识
所有操作系统都向它们运行的程序提供服务。典型的服务有执行新程序、打开文件、读文 件、分配存储区、获得当前时间等等。

输入用户名、密码登录unix系统时，系统会在其口令文件/etc/passwd中查看登录名。该文件中的每一项记录由7个冒号分隔字段组成，如：
```
# 登录名，加密口令，数字用户ID，数字组ID(20)，注释字段，起始目录，以及shell程序。

root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
nginx:x:498:498:Nginx web server:/var/lib/nginx:/sbin/nologin
apache:x:48:48:Apache:/var/www:/sbin/nologin
www:x:500:500::/home/www:/bin/bash
redis:x:497:496:Redis Server:/var/lib/redis:/sbin/nologin
jenkins:x:496:495:Jenkins Continuous Integration Server:/var/lib/jenkins:/bin/false
dbus:x:81:81:System message bus:/:/sbin/nologin
elsearch:x:501:501::/home/elsearch:/bin/bash
...
```

shell是一个命令行解释器，它读取用户输入，然后执行命令，用户通常用终端，有时则通过文件(称为shell脚本)向shell进行输入。常用的shell有:
* Bourne shell, /bin/sh 
* C shell, /bin/csh
* KornShell, /bin/ksh
**系统从口令文件中登录项的最后一个字段中了解到应该执行哪一个shell。**


**列出目录下的文件列表**
myls.c
```c
#include <sys/types.h>
#include <dirent.h>
#include "ourhdr.h"

int main(int argc, char* argv[]){
  DIR *dp;
  struct dirent *dirp;

  if(argc != 2){
    err_quit("a single argument (the directory name) is required");
  }

  if((dp = opendir(argv[1])) == NULL){
  	err_sys("cant't open %s",argv[1]);
  }

  while((dirp = readdir(dp)) != NULL){
  	printf("%s\n", dirp->d_name);
  }

  closedir(dp);
  exit(0);
}
```

编译：
```
gcc myls.c
```

测试：
```
./a.out /
```
输出：
```
.
..
.DocumentRevisions-V100
.DS_Store
.file
.fseventsd
.PKInstallSandboxManager
.PKInstallSandboxManager-SystemSoftware
.Spotlight-V100
...
```

每个进程都有一个工作目录(working directory，有时称为当前工作目录(current working directory))。所有相对路径名都从工作目录开始解释。进程可以用chdir函数更改其工作目录。
登录时，工作目录设置为起始目录(homedirectory)，该起始目录从口令文件中的登录项中取得。

文字描述符是一个小的非负整数，内核用以标识一个特定进程正在存访的文件。当内核打 开一个现存文件或创建一个新文件时，它就返回一个文件描述符。当读、写文件时，就可使 用它。

每当运行一个新程序时，所有的shell都为其打开三个文件描述符:标准输入、标准输出以及标准出错。如果像简单命令ls那样没有做什么特殊处理，则这三个描述符都连向终端。大多数shell都提供一种方法，使任何一个或所有这三个描述符都能重新定向到某一个文件，如：
```
ls > file.list
```

函数open、read、write、lseek以及close提供了不用缓存的I/O。

**将标准输入复制到标准输出**
stdin2stdout.c
```c
#include "ourhdr.h"

#define BUFFSIZE 8192

int main(void){
	int n;
	char buf[BUFFSIZE];

	while((n = read(STDIN_FILENO,buf,BUFFSIZE))>0){
		if(write(STDOUT_FILENO,buf,n) != n){
			err_sys("write error");
		}
	}

	if(n < 0){
		err_sys("read error");
	}
	exit(0);
}
```
测试：
```
gcc stdin2stdout.c
./a.out > data
输入：abcdefg
cat data
```

程序(program)是存放在磁盘文件中的可执行文件。使用6个exec函数中的一个由内核将程序读入存储器，并使其执行。程序的执行实例被称为进程(process)。每个UNIX进程都一定有一个唯一的数字标识符，称为进程ID(processID)。

**获取进程ID**
```c
printf("processs ID %d\n", getpid());
```

有三个用于进程控制的主要函数：
* fork
* exec exec有6种变体，但经常把它们统称为exec函数
* waitpid

**从标准输入读入命令并执行**
simpleShell.c
```c
#include <sys/types.h>
#include <sys/wait.h>
#include "ourhdr.h"

int main(void){
	char buf[MAXLINE];
	pid_t pid;
	int status;

	int ret =0;
	int i = 0;

	printf("%% ");
	while(fgets(buf,MAXLINE,stdin) != NULL){  // Ctrl-D
		printf("%d\n", i++);
		// fgets返回的每一行都以新行符终止并后随一个null字节
		// 但是execlp函数要求的是以null结束的参数，而不是以新行符结束的参数
		buf[strlen(buf) - 1] = 0;

		// fork创建一个新进程，是“当前进程的复制品”
		// fork对父进程返回新子进程的ID
		// 对子进程则返回0
		// 所以说fork被调用一次，但返回2次（在父进程和子进程中）
		if((pid = fork()) < 0){
			err_sys("fork error!");
		}
		else if(pid == 0){  // in child process
			// 从PATH环境变量中查找文件并执行， 这就”用新的程序文件替换了子进程“
			// 所以在被执行文件存在的情况下不会执行下一句err_ret
			ret = execlp(buf,buf,(char*)0);
			printf("%d\n", ret);
			err_ret("couldn't execute: %s",buf);
			exit(127);
		}

		// status为waitid返回的子进程的终止状态，这里没有用到
		if((pid = waitpid(pid, &status, 0)) < 0){
			err_sys("waitpid error!");
		}
		printf("%% ");
	}
	exit(0);
}
```
关于fork的补充说明：
**fork函数其内部，在执行到一半时就已经创建了子进程，并不是返回之后才创建的子进程**；在子进程创建之后，父子进程会共享一份代码内容，即**子进程为父进程的拷贝，因此在父进程和子进程中程序都往下继续执行**，子进程的fork会返回一个值，而父进程的fork也会返回一个值，通过返回值的不同就可以区分父进程和子进程。


头文件<unistd.h>包含了许多UNIX系统服务的函数原型，例如read，write和getpid函数。unistd.h文件提供了这些函数的原型，这样编译程序在编译时就可以检查在调用这些函数时是否使用了正确的参数。

UNIX函数出错时（比如返回负值、null等），变量errno会被设为错误代码，比如open出错，大约有15种不同的errno值。可以使用strerror或者perror函数来输出详细的错误信息：
```
fprintf(stderr,"%s\n",strerror(EACCES));
errno = ENOENT;
perror[argv[0]];  // 将当期程序传给perror，即通过管道的方式执行。perror函数会在标准输出中打印错误信息
```
口令文件中的用户ID是不能更改的，0是root用户的ID，某些操作系统功能只限于向超级用户提供。
打印用户ID和组ID：
```c
printf("uid=%d,gid=%d\n",getuid(),getgid());
```

口令文件/etc/passwd存放了用户名和用户ID之间的关系，而组文件/etc/group则包含了组名和组ID之间的映射关系。ls -l命令使用口令文件将数值用户ID映射为登录名，从而打印文件所有者的登录名。

信号是通知进程已发生某种条件的一种技术。进程如何处理信息有3种选择：
* 忽略该信号；
* 按系统默认方式处理；
* 提供一个函数，信号发生时则调用该函数；
比如通过键盘按Ctrl-C，就会向当前进程发出中断信号。

在程序中添加信号处理逻辑：
```c
#include <signal.h>

static void sig_int(int);

int main(void){
	// ...
	if(signal(SIGINT,sig_int) == SIG_ERR){
		err_sys("signal error");
	}

	// ...
}

// 中断处理函数
void sig_int(int signo){
	printf("interrupt \n%% ");
}
```

Unix使用3种进程时间值来度量一个进程的执行时间：
* 时钟时间：也称墙上时钟时间，是进程运行的时间总量，与系统中同时运行的进程数有关（比如进程执行过程中会时钟中断去执行其他进程，那么当前进程从开始执行到执行完成的时间必然被拉长）；
* 用户CPU时间：执行用户指令所用的时间量；
* 系统CPU时间：为该进程执行内核所花费的时间；

使用time命令可以打印命令的上述执行时间：
```
time ls
```
输出：
```
...
real	0m0.020s
user	0m0.000s
sys	0m0.002s
```

所有的操作系统都提供多种服务的入口点，程序通过这些入口点向内核请求服务，这些入口点被称为系统调用（system call）。Unix为每个系统调用在标准C库中设置一个同名的函数，用户进程用标准C语言来调用这些函数，这些函数会使用系统所要求的技术调用相应的内核服务。标准库函数中还提供了许多其他函数，有些用到了系统调用，甚至组合使用了多种系统调用，而有些库函数则没有使用任何系统调用。应用程序可以调用库函数来间接地调用系统调用，**也可以直接调用系统调用**（所以可以封装自己的对库函数的替代方案）。


# Unix标准化及实现
ANSI即美国国家标准协会，是由制造商和用户组成的非盈利性组织，在国际标准化组织ISO中是代表美国的成员。该组织1989年定义了C语言的标准，即ANSIC标准，同时定义了C语言的标准库：按照该标准定义的头文件，可将该库分成15个区。
其他的标准：
* POSIX 由IEEE制定的标准族
* X/Open XPG3 一个国际计算机制造商组织
* FIPS 美国政府的标准
详略。

Unix不同实现的历史AT&T、BSD等等，其中SVR4和4.3+BSD都宣称是依从POSIX的，而XPG3是POSIX的超集。

读这本书的主要目的是加深对操作系统的理解，没必要在这些琐碎的兼容性细节上纠缠，详略。


# 第3章 文件I/O
大多数Unix文件I/O只需要用到5个函数：
* open 也可以用于创建文件，此外有一个create函数专门用于创建文件
* read
* write
* lseek
* close

当一个进程终止时，它所有的打开文件都由内核自动关闭，很多程序都使用这一功能而不是显式地用close关闭打开的文件。

在使用read函数时，有多种情况会使得读到的字节数少于要求读的字节数：
* 读普通文件时，在读到要求字节数之前已达到了文件尾段（下一次再调用read时，将返回0）；
* 当从终端设备读时，通常一次最多读一行；
* 当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数；
* 某些面向记录的设备，例如磁带，一次最多返回一个记录；
每个打开的文件都有一个与其相关的**当前文件位移量**。读操作从文件的当前位移量处开始，在成功返回之前，该位移量增加实际读得的**字节数**。

Unix支持在不同进程间共享打开文件，内核使用3种数据结构来支持这一行为：
* 每个进程在进程表中都有一个记录项用于记录已打开的文件的文件描述符表，这个文件描述符表中的每一项主要由2个字段组成：文件描述符标志（整数）以及一个指向文件表项的指针；
* 内核为所有打开的文件维持一张文件表，每个文件表项包含：文件状态标志（读、写、增加、同步、非阻塞等）、当前文件位移量、指向该文件v结点表项的指针；
* 每个打开的文件（或设备）都有一个v结点结构，其中包含了文件类型以及对此文件进行各种操作的函数的指针信息；对于大多数文件，v结点还包含了该文件的i节点（所以所有关于文件的信息都是快速可供使用的）；
基于以上数据结构可以实现不同进程使用不同的文件描述符打开同样的文件（比如fork后，父、子进程对于每一个打开的文件描述符共享同一个文件表项）。

在完成write操作后，在文件表项中当前文件的位移量即增加所写的字节数，如果write使当前文件位移量超过了当前文件长度，则在i节点表项中的当前文件长度被设置为当前文件位移量（即该文件加长了）。

***lseek函数只修改文件表项中的当前文件位移量，没有进行任何I/O操作*

任何一个多于1个函数调用的操作（比如先lseek再write）都不能成为原子操作，因为在两个函数调用之间内核有可能临时挂起该进程。

dup和dup2函数可用于复制现存的文件描述符，新得到的文件描述符与已有的文件描述符共享同一个文件表项（所以它们共享同一文件状态标识以及文件位移量），从而解决多个进程写同一个文件的冲突问题。

另一种复制文件描述符的方式是使用fcntl函数。fcntl函数可以改变已经打开的文件的性质，根据不同参数，该函数有5种功能：
* 复制一个现存的描述符；
* 获得/设置文件描述符标记；
* 获得/设置文件状态标志；
* 获得/设置异步I/O所有权；
* 获得/设置记录锁；

ioctl函数是I/O操作的杂物箱，它不是POSIX的一部分，但是SVR4和4.3+BSD用其进行很多杂项设备操作。

打开文件/dev/fd/n等效于复制文件描述符n（前提是描述符n是打开的）。
即：
```c
fd = open("/dev/fd/0",mode);
```
等价于：
```c
fd = dup(0);
```
/dev/fd目录下的文件主要由shell使用，这允许程序以对待其他路径名一样的方式使用路径名参数来处理标准输入和标准输出。


# 第4章 文件和目录
本章讨论的中心是3个stat函数：
* stat 返回与文件相关的信息结构；
* fstat 获得已在指定描述符上打开的文件的有关信息；
* lstat 类似于stat，但是当传入的是一个符号连接时，返回的是该符号连接的有关信息而不是由该符号连接引用的文件的信息；
其本质是对存储文件信息的stat结构体的操作。

Unix文件类型：
* 普通文件：包含了某种形式的数据，对普通文件内容的解释由处理该文件的应用程序进行；
* 目录文件：包含了其他文件的名字以及指向与这些文件有关信息的指针；比如/etc
* 字符特殊文件：用于系统中某些类型的设备；比如/dev/ttya
* 块特殊文件：典型地用于磁盘设备，系统中的所有设备必须是字符特殊文件或者块特殊文件；比如/dev/sd0a
* FIFO：用于进程间的通信，也称为命名管道；比如/var/spool/cron/FIFO
* 套接字（socket）：用于进程间的网络通信，也可以用于同一台机器上的进程之间的通信；比如/dev/printer
* 符号连接：这种文件指向另一个文件；

与一个进程相关联的ID有6个甚至更多：
* 实际用户ID
* 实际组ID
* 有效用户ID
* 有效组ID
* 添加组ID
* 保存设置-用户ID
* 保存设置-组ID
详略。

每个文件有9个存取许可权位：
* 用户-读
* 用户-写
* 用户-执行
* 组-读
* 组-写
* 组-执行
* 其他-读
* 其他-写
* 其他-执行
可以使用chmod命令对这些许可权位进行修改，其中u表示用户、g表示组、o表示其他用户；

例：为了打开文件/usr/dict/words，需要对目录/、/usr、/usr/dict都具有执行许可权，同时对于该文件本身也需要有适当的操作许可权（取决于以何种方式打开，比如只读、读写等）。

进程每次打开、创建或删除一个文件时，内核就进行文件存取许可权测试：
* 若进程的有效用户ID是0（root），则允许存取；
* 若进程的有效用户ID等于文件的所有者ID（即该进程拥有此文件），且适当的存取许可权位被设置，则允许存取；
* 若进程的有效组ID或进程的添加组ID之一等于文件的组ID，且适当的存取许可权位被设置，则允许存取；
* 若适当的其他用户存取许可位被设置，则允许存取；

新文件的用户ID设置为进程的有效用户ID，至于组ID，POSIX允许选择下列之一：
* 进程的有效组ID；
* 新文件所在目录的组ID；

access、umask、chmod、chown、link、ulink等函数，略。

Unix文件系统的基础介绍，略。

对某个目录具有存取许可权的任一用户都可读该目录，但是只有内核才可以写目录（防止文件系统发生混乱）。

每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当用户登录到Unix系统时，其当前工作目录取自口令文件中的配置。


# 第5章 标准I/O库
标准I/O库处理很多细节，例如优化缓存分配长度以优化I/O执行等。标准I/O库的操作围绕流进行，而不是围绕文件描述符进行。当用标准I/O库打开或者创建一个文件时已使一个流与一个文件相结合。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针，该对象包含了I/O库为管理该流所需的所有信息。

对一个进程预定义了3个流，它们自动地可为进程使用：标准输入、标准输出、标准错误。

标准I/O库提供缓存的目的是尽可能减少使用read和write调用的数量。同时也会对每个I/O流自动地进行缓存管理，避免了应用程序需要考虑这一点所带来的麻烦。

标准I/O提供了3种类型的缓存：
* 全缓存：当填满标准I/O缓存后才进行实际I/O操作；
* 行缓存：当在输入和输出中遇到新行符时，标准I/O库才执行I/O操作；
* 不带缓存；

ANSI C要求下列缓存特征：
* 当且仅当标准输入和标准输出并不涉及交互作用设备时，它们才是全缓存的；
* 标准错误绝不会是全缓存的；

对于任意一个给定的流，可以调用下列2个函数之一来改变缓存类型：
* setbuf
* servbuf 可以精确地说明所需的缓存类型

函数介绍，略。


# 第6章 系统数据文件和信息










































