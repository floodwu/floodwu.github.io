---
layout: post
title:  "《UNIX环境高级编程》"
date: 2017-00-00 00:00:01
categories: 读书
tags: Unix C
excerpt: ""
---

* content
{:toc}

# 第1章 UNIX基础知识
所有操作系统都向它们运行的程序提供服务。典型的服务有执行新程序、打开文件、读文 件 、 分 配 存 储 区 、 获 得 当 前 时 间 等 等。

输入用户名、密码登录unix系统时，系统会在其口令文件/etc/passwd中查看登录名。该文件中的每一项记录由7个冒号分隔字段组成，如：
```
# 登录名，加密口令，数字用户ID，数字组ID(20)，注释字段，起始目录，以及shell程序。

root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
nginx:x:498:498:Nginx web server:/var/lib/nginx:/sbin/nologin
apache:x:48:48:Apache:/var/www:/sbin/nologin
www:x:500:500::/home/www:/bin/bash
redis:x:497:496:Redis Server:/var/lib/redis:/sbin/nologin
jenkins:x:496:495:Jenkins Continuous Integration Server:/var/lib/jenkins:/bin/false
dbus:x:81:81:System message bus:/:/sbin/nologin
elsearch:x:501:501::/home/elsearch:/bin/bash
...
```

s h e l l是一个 命令行解释器，它读取用户输入，然后执行命令，用户通常用终端，有时则通过文件 (称为 s h e l l 脚本 ) 向 s h e l l进行输入。常用的 s h e l l有:
* Bourne shell, /bin/sh 
* C shell, /bin/csh
* KornShell, /bin/ksh
**系统从口令文件中登录项的最后一个字段中了解到应该执行哪一个 s h e l l。**



**列出目录下的文件列表**
myls.c
```c
#include <sys/types.h>
#include <dirent.h>
#include "ourhdr.h"

int main(int argc, char* argv[]){
  DIR *dp;
  struct dirent *dirp;

  if(argc != 2){
    err_quit("a single argument (the directory name) is required");
  }

  if((dp = opendir(argv[1])) == NULL){
  	err_sys("cant't open %s",argv[1]);
  }

  while((dirp = readdir(dp)) != NULL){
  	printf("%s\n", dirp->d_name);
  }

  closedir(dp);
  exit(0);
}
```

编译：
```
gcc myls.c
```

测试：
```
./a.out /
```
输出：
```
.
..
.DocumentRevisions-V100
.DS_Store
.file
.fseventsd
.PKInstallSandboxManager
.PKInstallSandboxManager-SystemSoftware
.Spotlight-V100
...
```

每个进程都有一个工作目录 (working directory，有时称为当前工作目录 (current working d i r e c t o r y ) ) 。所有相对路径名都从工作目录开始解释。进程可以用 c h d i r 函 数 更 改 其 工 作 目 录 。
登录时，工作目录设置为起始目录 ( h o m e d i r e c t o r y ) ，该起始目录从口令文件中的登录项中取得。

文字描述符是一个小的非负整数，内核用以标识一个特定进程正在存访的文件。当内核打 开一个现存文件或创建一个新文件时，它就返回一个文件描述符。当读、写文件时，就可使 用它。

每当运行一个新程序时，所有的 s h e l l 都 为 其 打 开 三 个 文 件 描 述 符 : 标 准 输 入 、 标 准输出以及标准出错。如果像简单命令 l s 那 样 没 有 做 什 么 特 殊 处 理 ， 则 这 三 个 描 述 符 都 连 向 终 端。大多数s h e l l 都 提 供 一 种 方 法 ， 使 任 何 一 个 或 所 有 这 三 个 描 述 符 都 能 重 新 定 向 到 某 一 个 文 件 ，如：
```
ls > file.list
```

函数 o p e n 、 r e a d 、 w r i t e 、 l s e e k 以及 c l o s e 提 供 了 不 用 缓 存 的 I / O 。

**将标准输入复制到标准输出**
stdin2stdout.c
```c
#include "ourhdr.h"

#define BUFFSIZE 8192

int main(void){
	int n;
	char buf[BUFFSIZE];

	while((n = read(STDIN_FILENO,buf,BUFFSIZE))>0){
		if(write(STDOUT_FILENO,buf,n) != n){
			err_sys("write error");
		}
	}

	if(n < 0){
		err_sys("read error");
	}
	exit(0);
}
```
测试：
```
gcc stdin2stdout.c
./a.out > data
输入：abcdefg
cat data
```

程序( p r o g r a m ) 是 存 放 在 磁 盘 文 件 中 的 可 执 行 文 件 。 使 用 6 个 e x e c 函 数 中 的 一 个 由 内 核 将 程序读入存储器，并使其执行。程 序 的 执 行 实 例 被 称 为 进 程 ( p r o c e s s )。每个 U N I X 进程都一定有一个唯一的数字标识符，称为进程 I D ( p r o c e s s I D )。

**获取进程ID**
```c
printf("processs ID %d\n", getpid());
```

有三个用于进程控制的主要函数：
* fork
* exec exec有6种变体，但经常把它们统称为exec函数
* waitpid

**从标准输入读入命令并执行**
simpleShell.c
```c
#include <sys/types.h>
#include <sys/wait.h>
#include "ourhdr.h"

int main(void){
	char buf[MAXLINE];
	pid_t pid;
	int status;

	int ret =0;
	int i = 0;

	printf("%% ");
	while(fgets(buf,MAXLINE,stdin) != NULL){  // Ctrl-D
		printf("%d\n", i++);
		// fgets返回的每一行都以新行符终止并后随一个null字节
		// 但是execlp函数要求的是以null结束的参数，而不是以新行符结束的参数
		buf[strlen(buf) - 1] = 0;

		// fork创建一个新进程，是“当前进程的复制品”
		// fork对父进程返回新子进程的ID
		// 对子进程则返回0
		// 所以说fork被调用一次，但返回2次（在父进程和子进程中）
		if((pid = fork()) < 0){
			err_sys("fork error!");
		}
		else if(pid == 0){  // in child process
			// 从PATH环境变量中查找文件并执行， 这就”用新的程序文件替换了子进程“
			// 所以在被执行文件存在的情况下不会执行下一句err_ret
			ret = execlp(buf,buf,(char*)0);
			printf("%d\n", ret);
			err_ret("couldn't execute: %s",buf);
			exit(127);
		}

		// status为waitid返回的子进程的终止状态，这里没有用到
		if((pid = waitpid(pid, &status, 0)) < 0){
			err_sys("waitpid error!");
		}
		printf("%% ");
	}
	exit(0);
}
```
关于fork的补充说明：
**fork函数其内部，在执行到一半时就已经创建了子进程，并不是返回之后才创建的子进程**；在子进程创建之后，父子进程会共享一份代码内容，即**子进程为父进程的拷贝，因此在父进程和子进程中程序都往下继续执行**，子进程的fork会返回一个值，而父进程的fork也会返回一个值，通过返回值的不同就可以区分父进程和子进程。


头文件 < u n i s t d . h > 包含了许多 U N I X 系统服务的函数原型，例如r e a d，w r i t e 和 getpid函数。u n i s t d . h文件提供了这些函数的原型，这样编译程序在编译时就可以检查在调用这些函数时是否使用了正确的参数。

UNIX函数出错时（比如返回负值、null等），变量errno会被设为错误代码，比如open出错，大约有15种不同的errno值。可以使用strerror或者perror函数来输出详细的错误信息：
```
fprintf(stderr,"%s\n",strerror(EACCES));
errno = ENOENT;
perror[argv[0]];  // 将当期程序传给perror，即通过管道的方式执行。perror函数会在标准输出中打印错误信息
```





























































































