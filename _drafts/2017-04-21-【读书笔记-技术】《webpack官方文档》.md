---
layout: post
title:  "《webpack官方文档》读书笔记"
date: 2017-04-21 00:00:01
categories: 读书笔记-技术
tags: 前端开发 webpack
excerpt: ""
---

# Concepts

## Introduction
webpack is a module bundler for modern JavaScript applications.

**Four Core Concepts**: entry, output, loaders, and plugins.

### Entry
webpack creates a graph of all of your application's dependencies. **The starting point** of this graph is known as an entry point. The entry point tells webpack where to start and follows the graph of dependencies to know what to bundle. 

### Output
tell webpack the name of our bundle and where we want it to be emitted to.

### Loaders
webpack treats every file (.css, .html, .scss, .jpg, etc.) as a module.Loaders in webpack transform these files into modules(as they are added to your dependency graph). They have two purposes:
* Identify what **files** should be transformed by a certain loader. (test property)
* Transform that **file** so that it can be added to your dependency graph (and eventually your bundle). (use property)

### Plugins
plugins are most commonly used performing actions and custom functionality on "compilations" or "chunks" of your bundled modules. 

**example:webpack.config.js**
```js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins
const path = require('path');

const config = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      {test: /\.(js|jsx)$/, use: 'babel-loader'}
    ]
  },
  plugins: [
    new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};

module.exports = config;
```


## Entry Points
there are multiple ways to define the entry property in your webpack configuration.

### Single Entry (Shorthand) Syntax
```js
const config = {
  entry: './path/to/my/entry/file.js'
};
```
Passing an array of file paths to the entry property creates what is known as a "multi-main entry". This is useful when you would like to inject multiple dependent files together and graph their dependencies into one "chunk".

### Object Syntax
```js
const config = {
  entry: {
    app: './src/app.js',
    vendors: './src/vendors.js'
  }
};
```
this is the **most scalable way** of defining entry/entries in your application.

### Scenarios
* 1.Separate App and Vendor Entries
```js
const config = {
  entry: {
    app: './src/app.js',
    vendors: './src/vendors.js'
  }
};
```
this tells webpack to create dependency graphs starting at both app.js and vendors.js. **These graphs are completely separate and independent of each other**.

* 2.Multi Page Application
```js
const config = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
```
telling webpack that we would like 3 separate dependency graphs.
Use `CommonsChunkPlugin` to create bundles of shared application code between each page.

## Output
tell webpack how to write the compiled files to disk.while there can be multiple entry points, **only one output configuration is specified**.

### Usage
The **minimum requirements** for the output property is to set its value to an object including **two things** :filename,path.
```js
const config = {
  output: {
    filename: 'bundle.js',
    path: '/home/proj/public/assets'
  }
};
```

### Options
* `output.chunkFilename` : The filename of non-entry chunks as a relative path inside the output.path directory.(非入口文件的命名规则,在按需加载（异步）模块的时候，这样的文件是没有被列在entry中的，如使用CommonJS的方式异步加载模块)
* `output.crossOriginLoading` : enables cross-origin loading of chunks.
* `output.devtoolLineToLine` : Enable line-to-line mapped mode for all/specified modules. 
* `output.filename` : Specifies the name of each output file on disk.filename is used solely for naming the individual files.（可以指定文件的hash值，如`filename: '[name].js',`，可选的项包括：`[name]`、`[hash]`、`[chunkhash]`）
* `output.hotUpdateChunkFilename` : The filename of the `Hot Update Chunks`. They are inside the output.path directory.Default: `"[id].[hash].hot-update.js"`.
* `output.hotUpdateFunction` : **The JSONP function used by webpack for async loading of hot update chunks**.Default: `"webpackHotUpdate"`.
* `output.hotUpdateMainFilename` : The filename of the Hot Update Main File. Default: `"[hash].hot-update.json"`.
* `output.jsonpFunction` : The JSONP function used by webpack for async loading of chunks. Default: `"webpackJsonp"`.(A shorter function may reduce the file size a bit. Use a different identifier when having multiple webpack instances on a single page.)
* `output.library` : If set, export the bundle as library. output.library is the name.
* `output.libraryTarget` : format to export the library : var,this,commonjs,commonjs2,amd,umd.
* `output.path` : The output directory as an absolute path (required).
```js
// config.js
output: {
    path: "/home/proj/public/assets",
    publicPath: "/assets/"
}

// index.html
<head>
  <link href="/assets/spinner.gif"/>
</head>
```
* `output.sourceMapFilename` : The filename of the SourceMaps for the JavaScript files.Default: `"[file].map"`.


## Loaders
Loaders are transformations that are applied on the source code of a module. 
the following specifications define the identical loader usage:
```js
{test: /\.css$/, loader: 'css-loader'}
// or equivalently
{test: /\.css$/, use: 'css-loader'}
// or equivalently
{test: /\.css$/, use: {
  loader: 'css-loader',
  options: {}
}}
```
### Configuration
There are **three ways to use loaders** in your application:
* via configuration
```js
module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          { loader: 'style-loader'},
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          }
        ]
      }
    ]
  }
```

* explicit in the require statement
```js
// Separate loaders from the resource with !
require('style-loader!css-loader?modules!./styles.css');
```
**It's possible to overwrite any loaders in the configuration by prefixing the entire rule with !**
Options can be passed with a query parameter, just like on the web (?key=value&foo=bar). It's also possible to use a JSON object (?{"key":"value","foo":"bar"}).

* via CLI
```
webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'
```

### Loader Features
* Loaders can be chained. They are applied in a pipeline to the resource. A chain of loaders are compiled chronologically. **The first loader in a chain of loaders returns a value to the next**. At the end loader, webpack expects JavaScript to be returned.
* Loaders can be synchronous or asynchronous.
* Loaders run in Node.js and can do everything that’s possible there.
* Loaders accept query parameters. This can be used to pass configuration to the loader.
* Loaders can also be configured with an options object.
* Normal modules can export a loader in addition to the normal main via package.json with the loader field.
* Plugins can give loaders more features.
* Loaders can emit additional arbitrary files.

### Resolving Loaders
Loaders **follow the standard module resolution**. In most cases it will be loaders from the module path (node_modules).
The loader name convention and precedence search order is defined by resolveLoader.moduleTemplates within the webpack configuration API.

## Plugins
Plugins are the backbone of webpack. **webpack itself is built on the same plugin system** that you use in your webpack configuration!
They also serve the purpose of **doing anything else that a loader cannot do**.

### Anatomy
A webpack plugin is a JavaScript object that has an apply property. This apply property is called by the webpack compiler, giving access to the entire compilation lifecycle.
```js
// ConsoleLogOnBuildWebpackPlugin.js
function ConsoleLogOnBuildWebpackPlugin() {

};

ConsoleLogOnBuildWebpackPlugin.prototype.apply = function(compiler) {
  compiler.plugin('run', function(compiler, callback) {
    console.log("The webpack build process is starting!!!");

    callback();
  });
};
```

### Usage
Since plugins can take arguments/options, you must pass a new instance to the plugins property in your webpack configuration.
```js
plugins: [
  new webpack.optimize.UglifyJsPlugin(),
  new HtmlWebpackPlugin({template: './src/index.html'})
]
```

## Configuration
webpack's configuration file is a JavaScript file that exports an object(it's a standard Node.js CommonJS module,).

You should NOT use the following things. Technically you could use them, but it's not recommended:
* Access CLI arguments, when using the webpack CLI (instead write your own CLI, or use --env)
* Export non-deterministic values (calling webpack twice should result in the same output files)
* Write long configurations (instead split the configuration into multiple files)

The Simplest Configuration,Multiple Targets,Using TypeScript,Using JSX.略。


## Modules
In modular programming, developers break programs up into discrete chunks of functionality called a module.

### What is a webpack Module
In contrast to Node.js modules, webpack modules can express their dependencies in a variety of ways：
* An ES2015 import statement
* A CommonJS require() statement
* An AMD define and require statement
* An @import statement inside of a css/sass/less file.
* An image url in a stylesheet (url(...)) or html (<img src=...>) file.

### Supported Module Types
略。

## Module Resolution
A resolver is a library which helps in locating a module by its absolute path. 

webpack can resolve three kinds of file paths：
* Absolute paths
```
import "/home/me/file";
import "C:\\Users\\me\\file";
```
* Relative paths
```
import "../src/file1";
import "./file2";
```
* Module paths
```
import "module";
import "module/lib/file";
```
Modules are searched for inside all directories **specified in resolve.modules**. You can replace the original module path by an alternate path by creating an alias for it using **resolve.alias configuration option**.Once the path is resolved based on the above rule, the resolver checks to see if the path points to a file or a directory. 

**If the path points to a file**:
* If the path has a file extension, then the file is bundled straightaway.
* Otherwise, the file extension is resolved using the `resolve.extensions` option, which tells the resolver which extensions (eg - .js, .jsx) are acceptable for resolution.

**If the path points to a folder**:
then the following steps are taken to find the right file with the right extension:
* If the folder contains a `package.json` file, then fields specified in `resolve.mainFields` configuration option are looked up in order, and the first such field in package.json determines the file path.
* If there is no package.json or if the main fields do not return a valid path, file names specified in the `resolve.mainFiles` configuration option are looked for in order, to see if a matching filename exists in the imported/required directory .
* The file extension is then resolved in a similar way using the resolve.extensions option.

### Resolving Loaders
This follows the same rules as those specified for file resolution. But the resolveLoader configuration option can be used to have separate resolution rules for loaders.

### Caching
Every filesystem access is cached, so that multiple parallel or serial requests to the same file occur faster. In watch mode, only modified files are evicted from the cache. If watch mode is off, then the cache gets purged before every compilation.


## Dependency Graph
Any time one file depends on another, webpack treats this as a dependency.(This allows webpack to take non-code assets, such as images or web fonts, and also provide them as dependencies).

When webpack processes your application, it starts from a list of modules defined on the command line or in its config file. Starting from these entry points, webpack recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into a small number of bundles - often, just one - to be loaded by the browser.

## Targets
webpack offers multiple deployment targets that you can set in your webpack configuration.
Each target has a variety of deployment/environment specific additions, support to fit its needs. 
```
module.exports = {
  target: 'node'
};
```
In the example above, using node webpack will compile for usage in a Node.js-like environment (uses Node.js require to load chunks and not touch any built in modules like fs or path).

## Hot Module Replacement
Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running without a page reload. 


### How It Works

**From The App View**
* The app code asks the **HMR runtime** to check for updates.
* The HMR runtime downloads the updates (asynchronously) and tells the app code that an update is available.
* The app code then asks the HMR runtime to apply the updates.
* The HMR runtime applies the update (synchronously).

**From The Compiler (webpack) View**
In addition to the normal assets, the compiler needs to **emit an "update" to allow updating from previous version to the new version**. The "update" consists of two parts:
* The update manifest (JSON)
* One or more update chunks (JavaScript)
The manifest contains the new compilation hash and a list of all update chunks.Each update chunk contains code for all updated modules in the respective chunk (or a flag indicating that the module was removed).The compiler makes sure that module IDs and chunk IDs are consistent between these builds. It typically stores these IDs in memory (for example, when using webpack-dev-server), but it's also possible to store them in a JSON file.

**From The Module View**
HMR is an opt-in feature that **only affects modules containing HMR code**. One example would be patching styling through the style-loader. **In order for patching to work, style-loader implements the HMR interface**; when it receives an update through HMR, it replaces the old styles with the new ones.
a single handler can handle an update to a complete module tree. If a single module in this tree is updated, the complete module tree is reloaded (only reloaded, not transferred).

**From The HMR Runtime View**
略。

### What It Can Be Used For
webpack-dev-server supports a hot mode in which it tries to **update with HMR before trying to reload the whole page**. 


# Guides

## Getting Started
webpack simplifies your workflow by quickly constructing a dependency graph of your application and bundling them in the right order. 

略。

## Installation
If you are using npm scripts in your project, npm will try to look for webpack installation in your local modules for which this installation technique is useful.
```js
"scripts": {
    "start": "webpack --config mywebpack.config.js"
}
```
**This is standard and recommended practice**.

 Note that a global webpack installation is not a recommended practice. This locks you down to a specific version of webpack and might fail in projects that use a different version.

## Migrating from v1 to v2
略。


## Code Splitting
split your code into various bundles which you can then **load on demand**.

### Resource splitting for caching and parallel loads
* Vendor code splitting : `CommonsChunkPlugin`.
* CSS splitting : `ExtractTextWebpackPlugin`.

### On demand code-splitting
While resource splitting of the previous kind requires the user to specify the split points upfront in the configuration, one can also **create dynamic split points in the application code**.
using import() or require.ensure().

## Code Splitting - CSS

### Importing CSS
```js
// Import the CSS file like a JavaScript module
import 'bootstrap/dist/css/bootstrap.css';
```

### Using css-loader
```js
module.exports = {
    module: {
        rules: [{
            test: /\.css$/,
            use: 'css-loader'
        }]
    }
}
```
As a result, the CSS is bundled along with JavaScript.This has the disadvantage that you will not be able to utilize the browser's ability to load CSS asynchronously and parallel. Instead, **your page will have to wait until your whole JavaScript bundle is loaded**, to style itself.

### Using ExtractTextWebpackPlugin
you can generate a new bundle specifically for all the CSS modules and add them as a separate tag in the index.html:
```js
var ExtractTextPlugin = require('extract-text-webpack-plugin');
module.exports = {
    module: {
         rules: [{
             test: /\.css$/,
             use: ExtractTextPlugin.extract({
                 use: 'css-loader'
             })
         }]
     },
     plugins: [
         new ExtractTextPlugin('styles.css'),
     ]
}
```

## Code Splitting - Libraries
略。

## Code Splitting - Async
split your bundle into chunks which can be downloaded asynchronously at a later time.

### Dynamic import: import()
The ES2015 Loader spec defines import() as method to load ES2015 modules dynamically on runtime.import() takes the module name as argument and **returns a Promise**: `import(name) -> Promise`.
webpack treats import() as a split-point and puts the requested module in a separate chunk. 

fully dynamic statements, such as import(foo), will fail because **webpack requires at least some file location information**. This is because foo could potentially be any path to any file in your system or project. The import() must contain at least some information about where the module is located, so bundling can be limited to a specific directory or set of files.
For example, import(`./locale/${language}.json`) will cause every .json file in the ./locale directory to be bundled into the split-point. 

### Chunk names
Since webpack 2.4.0, chunk names for dynamic imports can be specified using a "magic comment".
```js
import(/* webpackChunkName: "my-chunk-name" */ 'module');
```

### Usage with Babel
If you want to **use import with Babel**, you'll need to install/add the `syntax-dynamic-import` plugin .
```
npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es2015
```

webpack.config.js
```js
module.exports = {
  entry: './index-es2015.js',
  output: {
    filename: 'dist.js',
  },
  module: {
    rules: [{
      test: /\.js$/,
      exclude: /(node_modules)/,
      use: [{
        loader: 'babel-loader',
        options: {
          presets: [['es2015', {modules: false}]],
          plugins: ['syntax-dynamic-import']
        }
      }]
    }]
  }
};
````

### Usage with Babel and async/await
```
npm install --save-dev babel-plugin-transform-async-to-generator babel-plugin-transform-regenerator babel-plugin-transform-runtime
```

index-es2017.js
```js
async function determineDate() {
  const moment = await import('moment');
  return moment().format('LLLL');
}

determineDate().then(str => console.log(str));
```

webpack.config.js
```
module.exports = {
  entry: './index-es2017.js',
  output: {
    filename: 'dist.js',
  },
  module: {
    rules: [{
      test: /\.js$/,
      exclude: /(node_modules)/,
      use: [{
        loader: 'babel-loader',
        options: {
          presets: [['es2015', {modules: false}]],
          plugins: [
            'syntax-dynamic-import',
            'transform-async-to-generator',
            'transform-regenerator',
            'transform-runtime'
          ]
        }
      }]
    }]
  }
};

```

### require.ensure()
require.ensure() is specific to webpack and superseded by import().
略。


## Building for Production
Running:
```
webpack -p
```
or:
```
webpack --optimize-minimize --define process.env.NODE_ENV="'production'"
```
This performs the following steps:
* Minification(using UglifyJsPlugin)
* Runs the LoaderOptionsPlugin
* Sets the Node environment variable

Specifying --optimize-minimize on the command line, the following plugin configuration is added:
```
plugins:[
    new webpack.optimize.UglifyJsPlugin({
      sourceMap: options.devtool && (options.devtool.indexOf("sourcemap") >= 0 || options.devtool.indexOf("source-map") >= 0)
    })
]
```

We encourage you to have Source Maps enabled in production. They are useful for debugging and to run benchmark tests. webpack can generate inline Source Maps included in the bundles or separated files.

Running webpack -p (or --define process.env.NODE_ENV="'production'") invokes the `DefinePlugin` in the following way:
```js
plugins:[
  new webpack.DefinePlugin({
    'process.env.NODE_ENV': JSON.stringify('production')
  })
]
```
The DefinePlugin performs search-and-replace operations on the original source code. Any occurrence of process.env.NODE_ENV in the imported code is replaced by "production". Thus, checks like if (process.env.NODE_ENV !== 'production') console.log('...') are evaluated to if (false) console.log('...') and finally minified away using UglifyJS.


### The manual way: Configuring webpack for multiple environments
the easiest way is to write separate js files for each environment.
Have the following snippet in your webpack.config.js:
```
function buildConfig(env) {
  return require('./config/' + env + '.js')(env)
}

module.exports = buildConfig;
```
And from our package.json, where we build our application using webpack, the command goes like this:
```
"build:dev": "webpack --env=dev --progress --profile --colors",
"build:dist": "webpack --env=prod --progress --profile --colors",
```
we passed the environment variable to our webpack.config.js file. The environment variable is then passed to buildConfig method which simply loads the right js file for the build.

An advanced approach would be to have a base configuration file, put in all common functionalities, and then have environment specific files and simply use 'webpack-merge' to merge them. This would help to avoid code repetitions.

For example, you could have all your base configurations like resolving your js, ts, png, jpeg, json and so on.. in a common base file :
base.js
```js
module.exports = function() {
    return {
        entry: {
            'polyfills': './src/polyfills.ts',
            'vendor': './src/vendor.ts',
            'main': './src/main.ts'

        },
        output: {
            path: path.join(__dirname, '/../dist/assets'),
            filename: '[name].bundle.js',
            publicPath: publicPath,
            sourceMapFilename: '[name].map'
        },
        resolve: {
            extensions: ['.ts', '.js', '.json'],
            modules: [path.join(__dirname, 'src'), 'node_modules']

        },
        module: {
            rules: [{
                test: /\.ts$/,
                use: [
                    'awesome-typescript-loader',
                    'angular2-template-loader'
                ],
                exclude: [/\.(spec|e2e)\.ts$/]
            }, {
                test: /\.css$/,
                use: ['to-string-loader', 'css-loader']
            }, {
                test: /\.(jpg|png|gif)$/,
                use: 'file-loader'
            }, {
                test: /\.(woff|woff2|eot|ttf|svg)$/,
                use: {
                  loader: 'url-loader',
                  options: {
                    limit: 100000
                  }
                }
            }],
        },
        plugins: [
            new ForkCheckerPlugin(),

            new webpack.optimize.CommonsChunkPlugin({
                name: ['polyfills', 'vendor'].reverse()
            }),
            new HtmlWebpackPlugin({
                template: 'src/index.html',
                chunksSortMode: 'dependency'
            })
        ],
    };
}
```
And then merge this base config with an environment specific configuration file using 'webpack-merge'. 

prod.js
```js
const webpackMerge = require('webpack-merge');

const commonConfig = require('./base.js');

module.exports = function() {
    return webpackMerge(commonConfig(), {
        plugins: [
            new webpack.LoaderOptionsPlugin({
                minimize: true,
                debug: false
            }),
            new webpack.DefinePlugin({
                'process.env': {
                    'NODE_ENV': JSON.stringify('production')
                }
            }),
            new webpack.optimize.UglifyJsPlugin({
                beautify: false,
                mangle: {
                    screw_ie8: true,
                    keep_fnames: true
                },
                compress: {
                    screw_ie8: true
                },
                comments: false
            })
        ]
    })
}
```

## Caching












































