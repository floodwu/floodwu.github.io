---
layout: post
title:  "《深入浅出Node.js》"
date: 2017-11-00 00:00:01
categories: 技术书籍与文档阅读笔记
tags: JavaScript
excerpt: ""
---

* content
{:toc}


# 前言
虽然JavaScript的产生与Netscape Navigator浏览器的需求有关系，但它并非只是设计出来用于浏览器前端的。早在1994年，网景公司就公布了其Netscape Enterprise Server中的一种服务器端脚本实现，它的名字叫LiveWire，是最早的服务器端JavaScript，甚至早于浏览器中的JavaScript公布。对于这门图灵完备的语言，网景早就开始尝试将它用在后端。

Node凭借V8的高性能和异步I/O模型将JavaScript重新推向了一个高潮。现在，Node不仅满足JavaScript同时运行在前后端，而且性能还十分高效。前后端要跨语言开发的现状已经开始改变。Node的本意是提供一个高性能的面向网络的执行平台，但无意间促成了JavaScript社区的繁荣，并进而形成强大的生态系统。


# 第1章 Node简介
除了HTML、WebKit和显卡这些UI相关技术没有支持外，Node的结构与Chrome十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务I/O。Node不处理UI，但用与浏览器相同的机制和原理运行。

Chrome浏览器和Node的组件构成：
![image](/images/tech/srqcnj-1-1.png)

在Node中，绝大多数的操作都以异步的方式进行调用。这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。

Node的特点：
* 异步I/O：在Node中，绝大多数的操作都以异步的方式进行调用。
* 事件与回调函数：将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。代码的编写顺序与执行顺序并无关系。
* 单线程：Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。
* 跨平台：兼容Windows和*nix平台主要得益于Node在架构层面的改动，它在操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv。

单线程的弱点：
* 无法利用多核CPU；
* 错误会引起整个应用退出，应用的健壮性值得考验；
* 大量计算占用CPU导致无法继续调用异步I/O；
像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI的渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。为解决单线程的问题，HTML5定制了Web Workers的标准，能够创建工作线程来进行计算，以解决JavaScript大计算阻塞UI渲染的问题。工作线程为了不阻塞主线程，通过消息传递的方式来传递运行结果，这也使得工作线程不能访问到主线程中的UI。
Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的健壮性。

Node对于I/O密集型业务的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。

CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。Node提供了两种优化方式：
* CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。（实测性能可以超过Java）
* 如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。



# 第2章 模块机制

对于JavaScript自身而言，其规范是薄弱的，还有以下缺陷：
* 没有模块系统。
* 标准库较少。（ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。）
* 没有标准接口。
* 缺乏包管理系统。

CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。目前，它依旧在成长中，这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

Node借鉴CommonJS的Modules规范实现了一套非常易用的模块系统。

CommonJS的模块规范：
* 模块引用：
```
var math = require('math'); 
```

* 模块定义：在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式
```
// math.js
exports.add = function () {
  // ...
}; 

// program.js
var math = require('math');
exports.increment = function (val) {  
  return math.add(val, 1);
}; 
```

* 模块标识：模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。

CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。


Node的模块实现：Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性。

在Node中引入模块，需要经历如下3个步骤：
1. 路径分析；
2. 文件定位；
3. 编译执行；

核心模块与文件模块：
在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

模块优先从缓存加载：
与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。

模块路径分析：
* 核心模块：优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。
* 路径形式的文件模块：以.、..和/开始的标识符，都被当做文件模块来处理，在分析路径模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。
* 自定义模块：是一种特殊的文件模块，可能是一个文件或者包的形式。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止，当前文件的路径越深，模块查找耗时会越多。

模块路径：Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。(沿路径向上逐级递归，直到根目录下的node_modules目录)
```
console.log(module.paths);

[ 
  '/home/jackson/research/node_modules',
  '/home/jackson/node_modules',
  '/home/node_modules',
  '/node_modules' 
] 
```
从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。


模块文件定位：
* 文件扩展名分析：当标识符中不包含文件扩展名时，Node会按.js、.json、.node的次序补足扩展名，依次尝试。在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。
* 目录分析和包：require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，此时Node会将目录当做一个包来处理。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.node、index.json。


模块编译：
定位到具体的文件后，Node会新建一个模块对象（function Module(id, parent) {...}），然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同：
* .js 通过fs模块同步读取文件后编译执行。
* .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。
* .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。
* 其余扩展名文件都被当做.js文件载入。
每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。

如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions['.ext']的方式实现。官方不鼓励通过这种方式来进行自定义扩展名的加载，而是期望先将其他语言或文件编译成JavaScript文件后再加载，这样做的好处在于不将烦琐的编译加载等过程引入Node的执行过程中。


JavaScript模块的编译：
在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\n，在尾部添加了\n});。一个正常的JavaScript文件会被包装成如下的样子：
```
(function (exports, require, module, __filename, __dirname) {
  var math = require('math');
  exports.area = function (radius) {
    return Math.PI * radius * radius;
  };
}); 
```
所以在模块内部可以使用如下这些变量：require、exports、module、__filename、__dirname。
这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的function对象。最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。（这就是Node对CommonJS模块规范的实现）

C/C++模块的编译：
.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。

JSON文件的编译：
JSON文件在用作项目的配置文件时比较有用。如果你定义了一个JSON文件作为配置，那就不必调用fs模块去异步读取和解析，直接调用require()引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。

Node中核心模块其实分为C/C++编写的和JavaScript编写的两部分，其中C/C++文件存放在Node项目的src目录下，JavaScript文件存放在lib目录下。
细节略，大体的实现是将所有内置的JavaScript代码（src/node.js和lib/*.js）转换成C++里的数组，在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。与文件模块最重要的区别在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置。

C++模块主内完成核心，JavaScript主外实现封装的模式是Node能够提高性能的常见方式。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的。

其实.node的扩展名只是为了看起来更自然一点，不会因为平台差异产生不同的感觉。实际上，在Windows下它是一个.dll文件，在*nix下则是一个.so文件。为了实现跨平台，dlopen()方法在内部实现时区分了平台，分别用的是加载.so和.dll的方式。普通的扩展模块与内建模块的区别在于无须将源代码编译进Node，而是通过dlopen()方法动态加载。

Node内建模块的编写，略。

包的出现，则是在模块的基础上进一步组织JavaScript代码。包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下这些文件：
* package.json：包描述文件。
* bin：用于存放可执行二进制文件的目录。
* lib：用于存放JavaScript代码的目录。
* doc：用于存放文档的目录。
* test：用于存放单元测试用例的代码。

包描述文件package.json的必备字段：
* name：包名。
* description：包简介。
* version：版本号。
* keywords：键词数组，NPM中主要用来做分类搜索。
* maintainers：包维护者列表。
* contributors：贡献者列表。
* bugs：一个可以反馈bug的网页地址或邮件地址。
* licenses：当前包所使用的许可证列表。
* repositories：托管源代码的位置列表。
* dependencies：使用当前包所需要依赖的包列表。
* homepage：当前包的网站地址。
* os：操作系统支持列表。
* cpu：CPU架构的支持列表。
* engine：支持的JavaScript引擎列表。
* builtin：标志当前包是否是内建在底层系统的标准组件。
* directories：包目录说明。
* implements：实现规范的列表。标志当前包实现了CommonJS的哪些规范。
* scripts：脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。

包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现。NPM一开始是独立的工具，后来整合进了Node中。NPM实际需要的字段还有另外4个：
* author：包作者。
* bin：一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。
* main：模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。
* devDependencies：一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包。

CommonJS包规范是理论，NPM是其中的一种实践。对于Node而言，NPM帮助完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。


全局安装：全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用到它。全局模式这个称谓其实并不精确，存在诸多误导。实际上，-g是将一个包安装为全局可用的可执行命令。它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下：
```
"bin": {
  "express": "./bin/express"
}, 
```
事实上，通过全局模式安装的所有模块包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来：
```
path.resolve(process.execPath, '..', '..', 'lib', 'node_modules'); 
```
如果Node可执行文件的位置是/usr/local/bin/node，那么模块目录就是/usr/local/lib/node_modules。最后，通过软链接的方式将bin字段配置的可执行文件链接到Node的可执行目录下。


本地安装：可以通过将包下载到本地，然后以本地安装。本地安装只需为NPM指明package.json文件所在的位置即可：它可以是一个包含package.json的存档文件，也可以是一个URL地址，也可以是一个目录下有package.json文件的目录位置。

通过镜像源安装：--registry=http://registry.url


发布包：
* 注册仓库账号：
```
$ npm adduser
Username: (jacksontian) 
Email: (shyvo1987@gmail.com) 
```
* 上传包：
```
$ npm publish .
npm http PUT http://registry.npmjs.org/hello_test_jackson
...
```
在这个过程中，NPM会将目录打包为一个存档文件，然后上传到官方源仓库中。


分析包：分析出当前路径下能够通过模块路径找到的所有包，并生成依赖树
```
$ npm ls
/Users/jacksontian
├─┬ connect@2.0.3 
│ ├── crc@0.1.0 
│ ├── debug@0.6.0 
│ ├── formidable@1.0.9 
│ ├── mime@1.2.4 
│ └── qs@0.4.2 
├── hello_test_jackson@0.0.1 
└── urllib@0.2.3 
```

局域NPM，略。

鉴于网络的原因，CommonJS为后端JavaScript制定的规范并不完全适合前端的应用场景（Node的模块引入过程，几乎全都是同步的）。经过一段争执之后，AMD规范最终在前端应用场景中胜出。

AMD规范：
```
define(id?, dependencies?, factory); 
```
模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容。

CMD规范：与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中，与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义，在依赖部分，CMD支持动态引入，示例如下：
```
define(function(require, exports, module) {
  // The module code goes here
}); 
```

兼容Node、AMD、CMD以及常见的浏览器环境：
```
;(function (name, definition) {
  // 检测上下文环境是否为AMD或CMD
  var hasDefine = typeof define === 'function',
    // 检查上下文环境是否为Node
    hasExports = typeof module !== 'undefined' && module.exports;

  if (hasDefine) {
    // AMD环境或CMD环境
    define(definition);
  } else if (hasExports) {
    // 定义为普通Node模块
    module.exports = definition();
  } else {
    // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象
    this[name] = definition();
  }
})('hello', function () {
  var hello = function () {};
  return hello;
}); 
```


# 第3章 异步I/O









































































