# 创建应用窗口的过程

1）每个应用类窗口都对应一个Activity对象，因此，创建应用类窗口首先需要创建一个Activity对象。当AmS决定启动某个Activity时，会通知客户端进程，而每个客户端进程都对应一个ActivityThread类，任何Activity都必须隶属于一个应用程序，因此，启动Activity的任务最终由ActivityThread完成。启动某个Activity的代码本质是构造一个Activity对象：

```java
Activity activity = null;
try{
  java.lang.ClassLoader cl = r.packageInfo.getClassloader();
  activity = mInstrumentation.newActivity( cl, component.gelClassName(), r.intent );
  r.intent.setExtrasClassLoader(cl);
  if(r.state!=null){
    r.state.setClassLoader(cl);
  }
  ...
```
以上代码使用ClassLoader从程序文件中装载指定的Activity对应的Class文件。
2）构造好指定的Acitvity对象后，接着调用Activity的attach()方法，其代码如下：
activity.attach( appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embededID, r.lastNonConfigurationInstance, r.lastNonConfigurationChildInstances, config);
attach()的作用是为刚刚构造好的Activity设置内部变量，这些变量是以后进行Activity调度所必需的。其中：
appContext将作为Activity的BaseContext，该对象使用new ContextImpl()方法创建；
this就是指当前ActivityThread对象；
r.token，r是一个ActivityRecord对象，其内部变量token的含义是AmS中的一个HistroyRecord对象；
r.parent，一个Activity可以有一个父Activity，这种理念是为了允许把一个Activity嵌入到另一个Activity内部执行，在应用程序使用时，常用ActivityGroup类，而ActivityGroup功能的内部支持的正是该变量；
3）在attach()方法内部，除了进行重要变量赋值外，另一件重要的事就是为该Activity创建Window对象，这通过调用PolicyManager的静态方法makeNewWindow()完成；PolicyManager会根据com.android.internal.policy.impl.Policy的配置创建不同产品类型的窗口。其代码最终实现的是创建了一个PhoneWindow对象。当创建好Window对象后，将其赋值给Activity的内部变量mWindow，并设置该Window的Callback接口为当前的Activity对象，这也是为什么用户消息能够传递到Activity中的原因：
```java
final void attach( Context context,...){
attachBaseContext( context );
mWindow = PolicyManager.makeNewWindow( this );
mWindow.setCallback( this );
```
4)创建好Window对象后，需要给Window对象中的mWindowManager变量赋值，该变量的类型为WindowManager类。事实上WindowManager类是一个接口，真正实现该接口的有两个类，一是Window.LocalWindowManager子类，另一个是WindowManagerImpl类。LocalWindowManager仅仅是一个壳，本身虽然也提供了WindowManager接口的全部功能，但是真正实现这些功能的确实壳里的WindowManager对象，这就是WindowManagerImpl类。
```java
mWindow.setWindowManager( null, mToken, mComponent...
if( mParent != null ){
  mWindow.setContainer( mParent.getWindow() );
}
mWindowManager = mWindow.getWindowManager();
```
setWindowManager()方法的第一个参数为null，而在Window类该方法实现中，如果第一个参数为null，其内部就会创建一个LocalWindowManager对象，第二个参数正是AmS中Activity对应的HistroyRecord的Binder引用，该变量将作为Window中的mAppToken的值。
5）配置好了Activity和Window对象后，接下来就需要给该窗口中添加真正的显示元素View或者ViewGroup。这是从performLaunchActivity()内部调用callActivityOnCreate()开始的，并会辗转调用到Activity的onCreate()方法中。
其实在Activity的onCreate()方法中调用setContentView()方法为其添加界面方式，该方法实际上却又调用了其所对应的Window对象的setContentView()方法：
```java	
public void setContentView( int layoutResID){
  getWindow().setContentView( layoutResID );
}
```
6）PhoneWinow的setContentView()方法如下所示：
```java
public void setContentView( int layoutResID ){
  if( mContentParent == null ){
    installDecor(); //安装一个窗口修饰，窗口修饰就是界面上常见的标题栏。程序中指定的layout.xml界面将被包含在窗口修饰中，称为窗口内容。窗口修饰也是一个ViewGroup，窗口修饰及其内部的窗口内容加起来就是通常所说的窗口，或者叫做Window的界面。
  }
  else{
    mContentParent.removeAllViews();
  }
  mLayoutInflater.inflate( layoutResID, mContentParent ); //安装完窗口修饰后，就可以把用户界面layout.xml文件添加到窗口修饰中。
  final Callback cb = getCallback();
  if( cb!=null ){
    cb.onContentChanged(); //回调，通知应用程序窗口内容发生了改变。cb正是Activity自身，因为Activity实现了Window.CallBack接口，并且在attach()方法中将自身作为Window对象的Callback接口实现。
  }
  Framework中定义了多种窗口修饰，installDecor()代码如下：
  private void installDecor(){
  if( mDecor == null ){
    mDecor = generateDecor(); //创建一个DecorView对象，该变量并不完全等同于窗口修饰，窗口修饰是mDecor内部的唯一一个子视图
    mDecor.setDescendantFocusability( 
      ViewGroup.FOCUS_AFTER_DESCENDANTS);
      mDecor.setIsRootNamespace( true );
  }
  if( mContentParent == null ){
    mContentParent = generateLayout( mDecor ); // 在generateLayout()方法中会调用mDecor..addView()根据用户指定的参数选择不同的窗口修饰，并把该窗口修饰作为mDector的子窗口。此外generateLayout()方法中返回的值的获取方式为：ViewGroup contentParent = (ViewGroup)findViewById( ID_ANDROID_CONTENT )，ID_ANDROID_CONTENT正是id=content的FrameLayout
		说明：generateLayout()方法内部所谓“根据用户指定的参数”中“用户指定”有两个地方可以指定：一是在Activity的onCreate()方法中调用得到当前Window，然后调用requestFeature()指定，另一个是在AndroidManifest.xml中Activity元素内部使用android:theme=”xxx”指定，generateLayout()方法中使用getWindowStyle()方法获取这些值。
		}
	不同的窗口修饰的区别不大，比如是否有标题栏，是否显示左右进度条等，这些修饰窗口共同的特点是其内部必须包含一个id=content的FrameLayout，因为内容窗口正是被包含在该FrameLayout之中。常见的窗口修饰对应的XML文件存放在路径frameworks/base/core /res/res/layout中，如R.layout.dialog_title_icons、R.layout.screen_title_icons、R.layout.   screen_progress等等。
	7）给Window类设置完其视图元素后，需要把创建的这个窗口告诉给WmS来把该窗口显示在屏幕上。当Activity准备好后会通知AmS，然后AmS经过各种条件的判断，并最终调用到Activity的makeVisible()方法，该方法及后续的各种调用将完成真正的把窗口添加进WmS之中，其代码如下：
	void  makeVisible(){
		if( !mWindowAdded ){
			ViewManager wm = getWindowManager();
			wm.addView( mDecor, getWindow().getAttributes());
			mWindowAdded = true;
		}
		mDecor.setVisibility(View.VISIBLE);
	}
```
8）在makeVisible()方法中，首先获得该Activity内部的WindowManager对象，这实际上就是Window.LocalWindowManager对象（而不是WindowManagerImpl类的addView()方法），然后调用addView()。第一个参数mDecor是一个DecorView对象，也就是用户所能看得到的、一个Activity对应的全部界面内容；第二个参数是在构造Window对象时默认构造的WindowManager.LayoutParams对象，由其构造函数中可以看到在默认情况下窗口参数的类型是一个TYPE_APPLICATION类型，即应用程序类型的窗口。
addView()的重要代码如下：
```java
if( wp.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&
  wp.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW
  if( wp.token == null ){
    View decor = peekDecorView();
    if ( decor !=null ){
      wp.token = decor.getWindowToken();
    }
  }
```
如果添加的是子窗口，就会检查params中的token，如果token为空，则把Activity对应的窗口的token赋值给params的token。如果添加的不是子窗口，则把mAppToken赋值给params的token。如果该Activity被某个Activity包含，则把父Activity的mAppToken赋值给params的token，如下：
```java
if( wp.token == null ){
  wp.token = mContainer == null ? mAppToke ：mContainer..mAppToken;
}
```
9）过了LocalWindowManager的addView()关卡之后，即调用WindowManagerImpl的addView()方法，一个应用程序内部无论有多少个Activity，但只有一个WindowManagerImpl对象，在WindowManagerImpl类中维护三个数组用于保存该应用程序中所拥有的窗口状态：
View[] mViews，这里每一个View对象都将成为WmS所认为的一个窗口；
ViewRoot[] mRoots，所有的ViewRoot对象，mViews中每个View对象都对应的ViewRoot对象；
WindowManager.LayoutParams[] mParams，当把mViews中的View对象当做一个窗口添加进WmS中，WmS要求每个被添加的窗口都要对应一个LayoutParams对象，mParams正是保存了每一个窗口对应的参数对象；
addView()的执行流程如下：
①检查所添加的窗口是否已经添加过；
②如果所添加的窗口为子窗口类型，找到其父窗口，并保存在内部临时变量panelParentView中，该变量将作为后面调用ViewRoot的setView()的参数；
③创建一个新的ViewRoot，因为每一个窗口都对应一个ViewRoot对象；
④调用ViewRoot的setView()方法，完成最后的、真正意义上的添加工作；
10）把新建的ViewRoot对象添加到mRoots对象中，添加的逻辑是：新建三个长度都加1的数组，然后把原来三个数组的内容都复制到新建数组，并把新创建的View、ViewRoot及WindowManager.LayoutParams对象保存到三个数组的最后：
11）调用ViewRoot对象的setView方法完成最后的窗口添加工作。方法的三个参数意义如下：
View view，是WindowManagerImpl中mViews数组的一个元素，也就是新建的窗口界面；
WindowManager.LayoutParams attrs，即为添加窗口的参数，该参数描述窗口的呈现风格、大小、位置等，尤其是其内部变量token，指明了该窗口和相关Activity的关系；
View panelParent View，也是WindowManagerImpl中mViews数组的一个元素，仅当该窗口有父窗口时才有意义；
setView()的执行流程如下：
①给ViewRoot的重要变量赋值，包括mView、mWindowAttributes及mAttachInfo：
```java
mView  = view;
mWindowAttributes.copyFrom(attrs);
mSoftInputMode = attrs.softInputMode;
mWindowAttributesChanged = true;
mAttachInfo.mRootView = view;
...
if( panelParentView != null ){
  mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
}
```
②调用requestLayout()，发出界面重绘请求。该方法仅仅是发出一个异步消息，以便UI线程下一个消息处理是界面重绘，从而让该窗口在响应任何其他用户消息之前首先变得可见；
③调用sWindowSession.add()，通知WmS添加窗口：
```java
res = sWindowSession.add( mWindow, mWindowAttributes, getHostVisibility(), mAttachInfo.mContentInsets);
```
sWindowSession是ViewRoot中的一个静态变量，每一个应用程序仅有一个sWindowSession对象，该对象类型为I WindowSession，即为一个Binder引用，该引用对应WmS中Session子类，WmS为每一个应用程序分配一个Session对象。
只要能够获得sWindowSession的引用就可以任意创建窗口，而无需经过以上冗长的步骤，然而sWindowSession这个变量的访问权限为包内访问，其定义未添加任何权限修饰符：
static IWindowSession sWindowSession;
因此应用程序无法直接获取该对象。sWindowSession变量是在ViewRoot的构造函数中通过调用getWindowSession()方法获取的，而getWindowSession()方法内部是通过IWindowManager.Stub.asInterface()来给sWindowSession赋值的，asInterface()的参数实际上是一个WindowManager对象，但是IWindowManager类在源码中是@hide的，这意味着SDK中将不包含该类，因此试图在不修改Framework代码的情况下不经过ViewRoot类添加窗口是行不通的。