# Android布局之屏幕自适应

Android系统中，默认的单位是像素(px)。也就是说，在没有明确说明的情况下，所有的大小设置都是以像素为单位。
如果以像素设置大小，会导致不同分辨率下出现不同的效果。
Android布局之屏幕自适应
字体的自适应
这里又有关于Android下表示大小的单位的相关知识。
下面列出几种表示单位：
dp（密度无关的尺寸单位）：一种基于屏幕密度的抽象单位，在不同屏幕密度的设备上获得同样大小的尺寸，Android能够自动将这种单位转换成像素单位。在每英寸160点的显示器上，1dp = 1px。
dip: device independent pixels(设备独立像素，即：是和像素密度无关的). 与dp相同。不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA （WVGA=800x480，HVGA=480x320, QVGA=320x240）推荐使用这个，不依赖像素。密度可以理解为每英寸包含的像素个数（单位是dpi）,1dp实际上相当于密度为160dpi的屏上的一个点(可否理解为物理尺寸？)。也就是说，如果屏幕物理密度是160dpi时，dp和px是等效的。
举例说明： 
一块拥有320*480分辨率的手机屏幕，如果宽度是2英寸，高度是3英寸，这块屏幕的密度就是160dpi。 
一块拥有480*800分辨率的手机屏幕，如果宽度是2英寸，高度是3英寸，这块屏幕的密度就不是160dpi了。这时屏幕的物理密度就变大了（大于160dpi）。这就意味着屏幕每英寸可以显示更多的像素点，屏幕的显示效果就更细腻了。
假设一个按钮的宽度使用dp作为单位，在160dpi时设为160，而在更高的dpi下（如320dpi)，按钮的宽度看上去和160dpi时的屏幕一样。这是由于系统在发现屏幕的密度不是160dpi时，会计算一个转换比例，然后用这个比例与实际尺寸相乘就得出新的尺寸。计算比例的方法是目标屏幕的密度除以160.如果目标屏幕的密度是320dpi,那么这个比例就是2。如果按钮的宽度是160dp，那么在320dpi的屏幕上的宽度就是320个像素点（dp是抽象单位，在实际的屏幕上应转换成像素点）。从这一点可以看出，dp可以自适应屏幕的密度。不管屏幕密度怎样变化，只要屏幕的物理尺寸不变，实际显示的尺寸就不会变化。如果将按钮的宽度设成160px，那么在320dpi的屏幕上仍然会是160个像素点，看上去按钮的宽度只是160dpi屏幕的一半。
公式：px = dip * density / 160，则当屏幕密度为160时，px = dip。
dpi是归一化后的dpi，可能值只有120(low)、160(medium)、240(high)、 320(xhigh)四种。
例：G7的真实dpi是252，根据我以前的理解，310dp换算成px应该是：310 * (252 / 160) = 488像素，而G7水平方向是480px，310dp在这上面绝对满屏都不止了，事实上Android系统并没有拿252作为dpi来计算，而是将G7视 作hdpi设备，然后使用240dpi来计算最终像素，所以在G7上320dp刚好是：320 * (240 / 160) = 480像素，刚好满屏了，310dp确实要差一点点。 

px: pixels(像素). 屏幕上的点。
pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业；
sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。可以根据用户的字体大小首选项进行缩放，即其实际大小取决于当前设置的字体大小。
根据上面对单位的分析，使用sp为单位就可以实现自适应字体大小。
Sp仅用于表示文字大小。
手机上的文字大小，取决于sp的值和用户在系统设置中设置的字体大小。当字体大小设置为普通（默认如此）时，sp=dp。
查看TextView的源码可知Android默认使用sp作为字号单位。将dip作为其他元素的单位。  

在你的res文件夹中创建一个文件夹，叫做values-320x240。其中320x240是你手机屏幕的分辨率，根据你手机屏幕的情况做不同的命名，例如values-800x480。在该文件夹下创建一个dimens.xml文件，定义各种字体的大小。那么系统就会自动根据你手机屏幕的分辨率去调用响应的文件夹。
另外，值得提醒的是，记得在你默认的values文件下的dimens.xml文件中也要写上相应的字体大小哦，因为当系统无法认识你手机屏幕大小的时候，它会自动去找你默认文件中的东西，没有写的话程序会崩溃。

布局自适应
Android手机屏幕大小不一，有480x320,640x360, 800x480,854x480.怎样才能让App自动适应不同的屏幕呢？ 其实很简单，只需要在res目录下创建不同的layout文件夹，比如layout-640x360,layout-800x480,所有的layout文件在编译之后都会写入R.java里，而系统会根据屏幕的大小自己选择合适的layout进行使用。 但是需要注意的是根据分辨率添加layout文件时，layout这个原来的文件夹及资源一定要存在，否则会出现错误。同时在命名layout文件夹时,必须遵守这样的规则.layout-640x360 大数放在小数的前面,否则会报错。下图为需要定义的文件夹和文件：
drawable-hdpi、drawable-mdpi、drawable-ldpi的区别： 
(1)drawable-hdpi里面存放高分辨率的图片,如WVGA (480x800),FWVGA (480x854) 
(2)drawable-mdpi里面存放中等分辨率的图片,如HVGA (320x480) 
(3)drawable-ldpi里面存放低分辨率的图片,如QVGA (240x320) 
备注：三者的解析度不一样，就像你把电脑的分辨率调低，图片会变大一样，反之分辨率高，图片缩小。
利用weight属性
保证页面的布局随着屏幕的大小变化而变化，最好使用相对布局方式，少使用绝对赋值。
将你控件的layout中的width、height设置为fill-parent，不要使用wrap——content。因为wrap-content的大小是不固定的。而weight（权重）这个属性很好的解决了这个问题。当包裹在控件外面的Layout的width、height属性都设置为fill-parent时，可以利用weight的反比特性。即如果控件A设置weight为9，控件B设置weight为20，那么A所占的空间为20/（9+20），B所占的空间为9/（9+20）。这样的反比属性对任何分辨率下的手机都是合适的。
这种方法虽然解决了自适应问题，但是在我使用的时候发现我有需要使用wrap_content属性的时候，就会出现layout无法填满的现象。（也有可能是我的布局有问题）。
2.3         在程序中制定
获得屏幕的大小，在程序中设置height和width属性。
//得到屏幕的高度
Int heigh = (Activity)m_context).getWindowManager().getDefaultDisplay().getHeight();
textview.setHeight((int)( heigh /14);
这种方法感觉不太适合复杂布局，但是我正在编写的应用时够了~
Android 中的排布也类似于普通的盒式模型，用margin来规定 View 和父 ViewGroup 以及兄弟 View 之间的间距，用padding来表述内容或者子 View 的位置：

![image](https://github.com/woojean/woojean.github.io/blob/master/images/java_1.png)