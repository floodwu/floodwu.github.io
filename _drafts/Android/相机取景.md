# 相机取景

可以通过隐式Intent来与照相机进行交互，相机应用会自动侦听MediaStore.ACTION_IMAGE_CAPTURE创建的Intent。
 ![image](https://github.com/woojean/woojean.github.io/blob/master/images/android_4.png)
Surface对象代表原始像素数据的缓冲区。SurfaceView类实现了SurfaceHolder接口，通过该接口来操作Surface。SurfaceView出现在屏幕上时，会创建Surface对象，当SurfaceView从屏幕上消失时，Surface对象即被销毁。不同于其他对象，SurfaceView不会自我绘制内容，任何想将内容绘制到Surface缓冲区的对象，都称为Surface的客户端，如Camera。SurfaceHolder提供了一个接口SurfaceHolder.Callback，该接口监听Surface生命周期中的事件，以此控制Surface与其客户端协同工作。

创建一个Fragment布局，包含一个SufaceView、一个Button和一个进度条ProgressBar：
<FrameLayout>
<LinearLayout>
<SurfaceView />
<Button />
<FrameLayout
android:id=”@+id/crime_camera_progressContainer”
android:layout_width=”match_parent”
android:layout_height=”match_parent”
android:clickable=”true”  //  截获点击、触摸事件，这样，当该FrameLayout显示时，可以阻止用户与LinearLayout组件包含的子组件交互，如点击拍照
/>
<ProgressBar
style=”@android:style/Widget.ProgressBar.Large”
...
/>

创建Fragment：
```java
public class CrimeCameraFragment extends Fragment{
private Camera mCamera; 
private SurfaceView mSufaceView;
private View mProgressContainer;

// 在相机捕获图像时调用，显示进度条
private Camera.ShutterCallback mShutterCallback = new Camera.ShutterCallback(){
public void onShutter(){
mProgressContainer.setVisibility(View.VISIBLE);
}
}

// 在JPEG格式的图像可用时调用：保存图像为文件
private Camera.PictureCallback mJpegCallback = new Camera.PictureCallback(){
public void onPictureTaken(byte[] data, Camera camera){
		String filename = UUID.randomUUID().toString()+“.jpg”；
FileOutputStream os = null;
boolean success = true;
try{
os = getActivity().openFileOutput(filename,Context.MODE_PRIVATE);
os.write(data);
}
catch(Exception e){
success = false;
}
finally{
try{
if(os!=null)
os.close();
}catch(Exception e){
success = false;
}
}
if(success){
...
}
getActivity().finish();
}

@Override
@SuppressWarning(“deprecation”)
public View onCreateView(LayoutInflater infalter,ViewGroup parent,Bundle savedInstanceState){
View v = inflater.inflate(R.layout.fragment_crime_camera,parent,false);
mProgressContainer = v.findViewById(R.id.crime_camera_progressContainer);
mProgressContainer.setVisibility(View.INVISIBLE);  //  进度条初始不可见
Button takePictureButton = (Button)v.findViewById(R.is.crime_camera_takePictureButton);

takePictureButton.setOnclickListener(new View.OnClickListener(){
public void onClick(View v){
if(mCamera != null){
// Camera的takePicture方法：
public final void takePicture(
Camera.ShutterCallback shutter,  在相机捕获图像时调用
Camera.PictureCallback raw,  在原始图像数据可用时调用
Camera.PictureCallback jpeg  在JPEG版本的图像可用时调用
)
mCamera.takePicture(mShutterCallback,null,mJpegCallback); // 设置相机回调方法
}
});
mSurfaceView = (SurfaceView)v.findViewById(R.id.crime_camera_surfaceView);
SurfaceHolder holder = mSurfaceView.getHolder();
holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);

// 实现SurfaceHolder.Callback接口，使得相机预览与Surface生命周期方法能够协同工作
holder.addCallBack(new SurfaceHolder.Callback(){
public void surfaceCreated(SurfaceHolder holder){
try{
if(mCamera != null ){
mCamera.setPreviewDisplay(holder); // 连接camera与surface
}
}
catch(IOException exception){
...
}
}

public void surfaceDestroyed(SurfaceHolder holder){
if(mCamera != null ){
mCamera.stopPreview();// 停止在surface上绘制
}
}

// surface首次显示在屏幕上时调用
public void surfaceChanged(SurfaceHolder holder,int format,int w,int h){
if(mCamera == null ) return;
Camera.Parameters parameters = mCamera.getParmeters();
Size s = ...; // 计算最合适尺寸的逻辑略去
parameters.setPreviewSize(s.width,s.height);
try{
mCamera.startPreview();  // 在surface上绘制帧
}
catch(Exception exception){
mCamera.release();
mCamera = null;
}
}

return v;
}

@Target(9)
@Override
public void onResume(){ // 在onResume中打开相机
if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD){
mCamera = Camera.open(0); // 0打开后置相机，1打开前置相机
}
else{
mCamera = Camera.open(); // API9之前的设备不支持带int参数的open方法
}
}

@Override
public void onPause(){ // 在onPause中释放相机资源
super.onPause();
if(mCamera != null){
mCamera.release();
mCamear = null;
}
}

}
```
创建一个托管该Fragment的Activity：
```java
public class CrimeCameraActivity extends SingleFragmentActivity{
@Override
public void onCreate(Bundle savedInstanceState){
// 隐藏操作栏和状态栏的操作只能在Activity中实现，而不能再Fragment中实现，因为它们必须在setContentView()方法调用之前调用。当然这里的Activity根本没有调用setContentView()方法，它是一个SingleFragmentActivity，通过覆盖createFragment()方法来设置自己视图
requestWindowFeature(window.FEATURE_NO_TITLE);  // 隐藏状态栏
getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);  // 全屏
super.onCreate(savedInstanceState);

@Override 
protected Fragment createFragment(){
return new CrimeCameraFragment();
}
}
```
修改Manifest文件，增加新的Activity的定义，以及使用相机的权限：

```
<manifest

...

<uses-permission android:name=”android.permission.CAMERA” />  //  需要相机权限

<uses-feature android:name=”android.hardware.camera” />  //  只有带相机的设备才能使用该APP

<application

...

<activity

android:name=”.CrimeCameraActivity”

android:screenOrientation=”landscape”  //  强制始终横屏显示

android:label=”@string/app_name”>

</activity>

```

