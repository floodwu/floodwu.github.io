# 互斥信号量和计数信号量

## 信号量
Linux中的`信号量是一种睡眠锁`，如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。此时处理器就可以执行其他代码，当持有的信号量可用后，处于等待队列中的那个任务将被唤醒，并获得该信号量。

## 互斥信号量和计数信号量
不同于自旋锁，信号量可以同时允许任意数量的锁持有者，同时允许的持有者数量在声明信号量的时候指定，这个值称为使用者数量。使用者为1的信号量和自旋锁一样，在一个时刻仅允许一个锁持有者，这样的信号量称为二值信号量或者互斥信号量。初始化时使用者数量大于1的信号量被称为`计数信号量`。

信号量支持两个原子操作P()和V()，P操作通过对信号量计数减1来获得一个信号量，如果结果是0或大于0，则获得信号量锁，任务就可以进入临界区，如果结果是负数，任务会被放入等待队列。当临界区执行完成后，V操作用来释放信号量，即将信号量计数加1。

信号量用struct semaphore表示：
/* 创建一个名为mr_sem的信号量 */
struct semaphore mr_sem;	
sema_init(&mr_sem,count);	

创建互斥信号量可以使用如下快捷方式：
static DECLARE_MUTEX(mr_sem);
之后可以使用down_interruptible(&mr_sem)函数（即P操作）和up(&mr_sem)函数（即V操作）进行控制。