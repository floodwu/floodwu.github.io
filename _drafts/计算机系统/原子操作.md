# 原子操作

## 原子操作
原子操作是其他同步方法的基石，可以保证指令以原子的方式执行，即执行过程中不会被打断。因此不会引起竞争条件。内核提供了两组原子操作接口，一组针对整数进行操作，另一组针对单独的位进行操作。

## 原子整数操作
针对整数的原子操作只能对atomic_t类型的数据进行处理，之所以引入这样一个特殊的类型而不是直接使用C语言，主要有以下原因：
让原子函数只接受atomic_t类型的操作数，可以确保原子操作只与这种特殊类型的数据一起使用；
使用atomic_t类型确保编译器不对相应的值进行访问优化，使得原子操作最终接收到正确的内存地址，而不只是一个别名；
使用atomic_t可以屏蔽在不同体系结构上实现原子操作时的差异；

atomic_t在32位int类型的低8位嵌入了一个锁，因为对原子操作缺乏指令级的支持，所以只能用锁来避免对原子类型数据的并发访问，因此尽管Linux支持的所有机器上的int型数据都是32位的，但是使用atomic_t的代码只能将该类型的数据当做24位来用。

原子操作通常是内联函数，往往是通过内嵌汇编指令来实现的。原子整数操作列表如下：


在64位体系结构上需要使用atomic64_t类型（对long的封装，而不是int）。

## 原子位操作
原子位操作是对普通的内存地址进行操作，它的参数是一个指针和一个位号，第0位是给定地址的最低有效位。由于原子位操作是对普通的指针进行的操作，所以不像原子整型对应atomic_t，这里没有特殊的类型，只要指针指向任何数据，就可以对它进行操作。标准原子位操作列表如下：


内核还提供了一组与上述操作对应的非原子位函数，其操作与对应的原子位函数相同，但是不保证原子性（速度更快），且名字前缀多两个下划线，如test_bit()对应的非原子形式是__test_bit()。如果代码本身已经避免了竞争条件，就可以使用非原子位操作。