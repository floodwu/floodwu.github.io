# 进程与进程控制

## 进程
进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的，包括存放在存储器中的程序的代码和数据，它的栈、通用目的存储器的内容、程序计数器、环境变量以及打开的文件描述符的集合。进程也能够创建新进程，且在这个新进程的上下文中运行它们自己的代码。

进程为程序提供了两个关键的抽象：
1.一个独立的逻辑控制流：造成程序独占地使用处理器的假象；
2.一个私有的地址空间：造成程序独占地使用存储器系统的假象；

进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（挂起），然后轮到其他进程。一个逻辑流的全部执行时间与另一个流重叠，称为并发（即使它们运行在同一个处理器上）。一个进程和其他进程轮流执行称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片。

操作系统内核使用上下文切换（一种较高形式的异常控制流）来实现多任务：上下文就是内核重启一个被抢占的进程所需的状态，它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如页表、进程表、文件表等。内核为每个进程维持一个上下文，在程序执行的某些时刻（比如发生系统调用、中断等），内核可以决定抢占当前进程，并重新开始一个之前被抢占的进程，这被称为调度，由内核中的调度器执行。总之上下文切换执行3步操作：
1.保存当前进程的上下文；
2.恢复某个之前被抢占的进程被保存的上下文；
3.将控制传递给这个新恢复的进程；

## 进程控制
描述了Unix中通过C操作进程的系统调用，即一些C函数，略。

通过fork()创建的子进程会得到与父进程用户级虚拟地址空间相同的一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还会获得与父进程任何打开的文件描述符相同的拷贝，即子进程可以读写父进程中打开的任何文件。父进程与子进程之间最大的区别是它们的PID不同。

## 信号
Unix信号允许进程中断其他进程。信号是一条消息，通知进程系统中发生了一个某种类型的系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下对用户进程而言是不可见的，信号则提供了一种机制通知用户进程发生了这些异常。

一个只发出而没有被接收的信号称为待处理信号，一种类型至多只会有一个待处理信号。如果一个进程已经有了一个特定类型的待处理信号，那么任何接下来发送到这个进程的同样类型的信号都不会排队等待，而是被直接丢弃。

内核通过更新目的进程上下文中的某个状态来发送一个信号给目的进程。发送信号可能有2个原因：
1.内核检测到一个系统事件，比如除零或者子进程终止；
2.一个进程调用了kill函数显示地要求内核发送一个信号给目的进程（也可以发送给自己）；
当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略信号，也可以通过执行信号处理程序来捕获这个信号（有些信号，比如SIGKILL既不能被捕获，也不能忽略）。

kill程序可以向另外的进程发送任意的信号，比如向PID为15213的进程发送SIGKILL（编号为9）信号：
kill -9 15213
键盘输入ctrl+c会发送一个SIGINT信号到shell，shell捕获到该信号后会发送SIGINT到这个前台进程组中的每个进程，在默认情况下会终止前台作业。

## 非本地跳转
C语言通过setjmp和longjmp函数提供了一种称为非本地跳转的用户级异常控制流，实现直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。非本地跳转的一个重要应用是允许从一个深层嵌套的函数调用中立即返回。另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号中断了的指令的位置。