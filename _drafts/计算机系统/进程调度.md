# 进程调度

进程调度程序是多任务系统在可运行态进程之间分配有限的处理器时间资源的内核子系统。

## 调度器类
Linux调度器以模块方式提供，因此允许不同类型的进程可以有针对性地选择调度算法，这种模块化的结构被称为`调度器类`。每个调度器都有一个优先级，基础的调度器代码会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那一个程序。
CFS是一个针对普通进程的调度类。

## 完全公平调度算法（CFS）
Linux自2.6.23内核版本开始使用称为`完全公平调度算法`的进程调度算法，该算法不直接分配时间片到进程，而是`将处理器的使用比划分给进程`，因此进程所获得的处理器时间和系统的负载密切相关。nice值（-20到+19）不再像标准Unix系统那样用来表示优先级，而是作为权重来影响进程的处理器使用比例，具有高nice值的进程将被赋予低权重，从而丧失一小部分处理器使用比。
Linux系统是抢占式的，其抢占时机取决于新的可运行程序消耗了多少处理器使用比，如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。否则将推迟其运行。

`时间记账`：CFS不再有时间片的概念，但是也必须维护每个进程运行时间的记账，以此确保每个进程只在公平分配给它的处理器时间内运行。CFS使用调度器实体结构struct sched_entity来跟踪进程运行并记账。sched_entity在task_struct中以一个名为se的成员变量被嵌入。在sched_entity中有一个名为vruntime的变量用来`存放进程的虚拟运行时间`，该运行时间称为`虚拟实时`，其值的计算是经过了所有可运行进程总数的标准化，即被加权的，单位为ns，因此和定时器的节拍不相关。CFS使用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。

`进程选择`：CFS试图利用一个简单规则去均衡进程的虚拟运行时间，当要选择下一个运行进程时，`它会挑一个具有最小vruntime的进程`，这也是CFS调度算法的核心。`CFS使用红黑树（rbtree）来组织可运行的进程队列`，并利用其找到最小vruntime值的进程。

`睡眠和唤醒`：睡眠即被阻塞，此时进程处于一个特殊的不可执行的状态，进程把自己标志成睡眠状态，从可执行红黑树中移除，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程则相反，进程被设置为可执行状态，然后再从等待队列中移到可执行二叉树中。

## 上下文切换
上下文切换，即`从一个可执行进程切换到另一个可执行进程`，由context_switch()函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用该函数，它完成两项基本的工作：
调用switch_mm()，把虚拟内存从上一个进程映射切换到新进程中；// `切换虚拟内存`
调用switch_to()，从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息，以及其他任何与体系结构相关的状态信息。 // `切换处理器`

`抢占时机`
每个进程都包含一个need_resched标志，用来表明是否需要重新执行一次调度。当某个进程应该被抢占时，scheduler_tick()会设置这个标志；当一个优先级高的进程进入可执行状态时，try_to_wake_up()也会设置这个标志。`内核会检查该标志`（如返回用户空间以及从中断返回的时候），确认其被设置，然会调用schedule()来切换到一个新的进程。

`用户抢占`
在从系统调用或者中断处理程序返回用户空间时，如果need_resched标志被设置，会导致schedule()被调用，内核会选择一个其他（更合适的）进程投入运行，即发生用户抢占。即用户抢占发生在：
从系统调用返回用户空间时；
从中断处理程序返回用户空间时；

`内核抢占`
Linux支持内核抢占，前提是重新调度是安全的。只要进程没有持有锁，就是安全的。具体实现就是在每个进程的thread_info中引入preempt_count计数器，初试为0，每当使用锁的时候+1，释放锁的时候-1，当数值为0时，内核就可以抢占。从中断返回内核空间时，内核会检查need_resched和preempt_count的值，以决定是调用调度程序（内核抢占）还是返回执行进程。如果内核中的进程被阻塞了，或者它显式地调用了schedule()，内核抢占也会显式地发生。即内核抢占会发生在：
中断处理程序正在执行，且返回内核空间之前；
内核代码再一次具有可抢占性的时候；
内核中的任务显式调用schedule()；
内核中的任务阻塞（这同样也会导致调用schedule()）；

`实时调度策略`
Linux提供了两种实时调度策略：SCHED_FIFO、SCHED_RR。而普通的、非实时的调度策略是SCHED_NORMAL。
实时调度策略不使用CFS来管理，而是被一个特殊的实时调度器管理。
SCHED_FIFO实现了一种简单的先入先出的调度算法，不使用时间片，处于可运行态的SCHED_FIFO进程会比任何SCHED_NORMAL级的进程都先得到调度，一旦一个SCHED_FIFO级进程处于可执行状态，就会一直执行，直到它自己受阻或者显式地释放处理器。
SCHED_RR与SCHED_FIFO大体相同，区别在于SCHED_RR带有时间片，在执行完预先分配的时间后就不能再继续执行了。