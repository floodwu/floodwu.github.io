# 静态库与共享库

链接是将各种代码和数据收集起来并组合成一个单一文件的过程，这个文件可被加载到存储器并执行。链接可以执行于编译时，也可以执行于加载时，甚至可以执行于运行时。链接器使得分离编译成为可能：不用将一个大型的应用程序组织为一个巨大的源文件，而是可以将它分解为更小、更好管理的模块，并可以独立地修改和编译这些模块。

## 静态链接
静态链接器（比如ld）以一组可重定位目标文件和命令行参数为输入，生成一个完全链接的、可以加载和运行的可执行目标文件。
为了构造可执行文件，链接器必须完成两个主要任务：符号解析和重定位。


## 静态库
所有的编译系统都提供一种机制：将所有相关的目标模块打包成一个单独的文件，称为静态库，它可以用作链接器的输入，当链接器构造一个可执行文件时，它只拷贝静态库里被应用程序引用的目标模块。在Unix系统中静态库以存档（archive）格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置，后缀为.a。
如：
```c
// addvec.c
void addvec(int *x, int *y, int *z, int n){
    int i;
    for(i=0; i<n; i++){
        z[i] = x[i] + y[i];
    }
}

// multvec.c
void addvec(int *x, int *y, int *z, int n){
    int i;
    for(i=0; i<n; i++){
        z[i] = x[i] * y[i];
    }
}
```
使用ar工具基于以上两个文件创建一个名为libvector.a的静态库：
gcc -c addvec.c multvec.c
ar rcs libvector.a addvec.o multvec.o

假设该库的头文件为vector.h（定义了库中的函数的原型），则可以如下使用该库：
```c
// main.c
\#include <stdio.h>
\#include "vector.h"

int x[2] = {1,2};
int y[2] = {3,4};
int z[2];

int main(){
	addvec(x,y,z,2);
	printf("z = [%d %d]\n",z[0],z[1]);
	return 0;
}
```

为了创建可执行文件，需要编译和链接输入文件main.o和libvector.a：
gcc -O2 -c main.c
gcc -static -o p main.o ./libvector.a
-static指明链接器应该构建一个完全链接的可执行目标文件，即它可以加载到存储器并运行，在加载时无需更进一步的链接。当链接时，它判定addvec.o定义的addvec符号是被main.o引用的，所以会拷贝addvec.o到可执行文件。因为程序不引用任何由multvec.o定义的符号，所以链接器就不会拷贝这个模块到可执行文件。
此外，链接器还会拷贝libc.a中的printf.o模块，以及许多C运行时系统中的其他模块。

在符号解析阶段链接器从左到右扫描可重定位目标文件和存档文件，因此命令行上的库和目标文件的顺序非常重要。（具体解析过程略）


## 共享库
共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来，这个过程称为动态链接，由动态链接器来执行。在Unix中，共享库的后缀通常为.so。共享库以两种不同的形式来共享，首先在给定的文件系统中对于一个库只有一个.so文件的情况，所有引用该库的可执行目标文件都共享这个.so文件中的代码和数据，而不是像静态库的内容那样被拷贝和嵌入到引用它们的可执行的文件中。其次，在存储器中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。

创建共享库形式的libvector.a，并使用：
gcc -shared -fPIC -o libvector.so addvec.c multvec.c
gcc -o p main.c ./libvector.so
-fPIC指示编译器生成与位置无关的代码，-shared指示链接器创建一个共享的目标文件。
如上创建的可执行目标文件p的形式使得它在运行时可以和libvector.so链接。链接器拷贝了一些重定位和符号信息，它们使得运行时可以解析对libvector.so中代码和数据的引用。当加载器加载已部分链接的可执行文件p时，它发现p中包含的.interp节，这个节包含动态链接器的路径名，动态链接器本身就是一个共享目标，加载器不再像通常那样将控制传递给应用，而是加载和运行这个动态链接器。然后动态链接器通过执行以下重定位来完成链接：
1.重定位libc.so的文本和数据到某个存储器段；
2.重定位libvector.so的文本和数据到另一个存储器段；
3.重定位p中所有对由libc.so和libvector.so定义的符号的引用；

## 运行时加载和链接共享库
应用程序可以在它运行时要求动态链接器加载和链接任意共享库，而无需在编译时链接那些库到应用中。
现代高性能的Web服务器可以使用基于动态链接的方式来生成动态内容，其思路是将生成动态内容的每个函数打包在共享库中，当一个来自Web浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用fork和execve在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。
Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库：
```C
#include <dlfcn.h>
void *dlopen(const char *filename, int flag);
```
（详略）