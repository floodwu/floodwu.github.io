# 进程终结

当一个进程终结时，内核必须释放它所占有的资源，并通知其父进程。一般发生在进程自身调用exit()系统调用的时候，既可能是显式的，也可能是隐式的（C语言编译器会在main()函数的返回点后面放置调用exit()的代码）。此外，当进程接受到它既不能处理也不能忽略的信号或异常时，也可能被动终结。不管是如何终结的，该任务最重都要靠do_exit()来完成，该函数需要做很多繁琐的工作，主要包括：
将task_struct中的标志成员设置为PF_EXITING；
调用del_timer_sync()删除任一内核定时器，根据返回结果确保没有定时器在排队，也没有定时处理程序在运行；
调用acct_update_integrals()输出记账信息；
调用exit_mm()释放进程占用的mm_struct，如果没有别的进程使用它们，就彻底释放它们；
调用sem__exit()，如果进程排队等待IPC信号，它则离开队列；
调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数，如果其中某个引用计数的数值降为0，就可以释放；
根据exit()提供的退出代码（或其他内核机制规定的退出动作）设置task_struct中的exit_code，供父进程随时检索；
调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者init进程，并把进程状态（exit_code）设为EXIT_ZOMBIE；
do_exit()调用schedule()切换到新的进程，因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程所执行的最后一段代码，do_exit()永不返回；
处于EXIT_ZOMBIE退出状态的进程不可运行，它所占用的所有内存就是内核栈、thread_info、task_struct结构，此时进程存在的唯一目的就是向它的父进程提供信息（进程描述符还在），父进程检索到信息后，由进程所持有的剩余内存被释放，归还给系统使用。

## 删除进程描述符
在调用了do_exit()后，`尽管线程已经僵死不能再运行，但是系统还保留了它的进程描述符`，`这样使父进程有办法在子进程终结后仍然能够获得它的信息`。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct才可被释放，即调用release_task()函数：
调用_exit_signal()，该函数调用_unhash_process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务列表中删除该进程；
_exit_signal()释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录；
如果这个进程是线程组的最后一个进程，并且领头进程已经死掉，那么release_task()就要通知僵死的领头进程的父进程；
release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab高速缓存；
至此，进程描述符和所有进程独享的资源就全部被释放。

## 孤儿进程
如果父进程在子进程之前退出，必须有机制来保证子进程能够找到一个新的父进程，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白耗费内存。对于这个问题解决方法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做其父进程。init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。