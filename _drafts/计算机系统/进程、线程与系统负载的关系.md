# 进程、线程与系统负载的关系

## 进程
进程是CPU多执行流的实现方式。多进程的好处不仅仅在于对CPU时间的轮流使用，还在于对CPU计算和I/O操作进行了很好的重叠利用。
进程的调度由内核进行，从内核的观点看，进程就是担当分配系统资源的实体，也可以理解为记录程序实例当前运行到什么程度的一组数据。
每个进程都有自己的独立内存地址空间和生命周期，当子进程被父进程创建后便将父进程地址空间的所有数据复制到自己的地址空间，完全继承父进程的所有上下文信息。
进程的创建使用fork()系统调用。

## 轻量级进程
由于进程之间相对独立，各自维护其庞大的地址空间和上下文信息，所以采用大量进程的Web服务器在处理大量并发请求时内存的大量消耗有时候会成为性能提升的制约因素。但是，进程的优越性也恰恰体现在其相互独立所带来的稳定性和健壮性。
Linux2.0之后提供对轻量级进程的支持，由新的系统调用clone()来创建，由内核直接管理，像普通的进程一样独立存在，拥有自己的进程描述符。但是这些进程已经允许共享一些资源，比如地址空间、打开的文件等，从而减少了内存的开销。当然，其上下文切换的开销在所难免。

## 线程
Linux线程的接口定义为pthread，它有多种实现，有些只是在普通的进程中由用户态通过一些库函数模拟实现的多执行流，这种情况下多线程的管理完全在用户态完成，线程的切换开销相比于进程和轻量级进程要少，但是在多处理器的服务器中表现较差。另一种实现是内核级的线程库，通过clone()来创建线程，即每个线程实际上就是一个轻量级进程，这使得线程完全由内核的进程调度器来管理，对多处理器服务器支持较好，但线程切换的开销也比用户态线程多。

## 进程调度器
内核中的进程调度器维护着各种状态的进程队列，其中包括所有可运行进程的队列称为运行队列。如果运行队列中有不止一个进程，进程调度器的一项主要工作就是决定下一个运行的进程，这项工作基于每个进程的进程优先级进行。
进程优先级除了可以由进程自己决定，进程调度器在进程运行时也可以动态调整它们的优先级。Linux对进程的动态调整体现在进程的nice属性中，在top命令中，进程的优先级属性为PR，优先级的动态调整值用NI表示。
PR所代表的值其实就是进程调度器分配给进程的时间片长度，单位是时钟个数。



## 系统负载
通过查看/proc/loadavg可以了解到运行队列的情况：
```
cat /proc/loadavg
1.63 0.48 0.21 10/200 17145
```
其中：
1.63 0.48 0.21是不同时间内（最近1分钟、5分钟、15分钟）的系统负载，是单位时间内运行队列中就绪等待的进程数的平均值，如果值为0，说明每个进程只要就绪后就可以马上获得CPU，无需等待，这时系统的响应速度最快。
10/200中的10代表此时运行队列中的进程个数，而200代表此时的进程总数。
17145代表最后创建的一个进程ID。
也可以通过top命令或者w命令来获得系统负载，它们其实仍然来自于/proc/loadavg。

## 进程切换
一个进程被挂起的本质就是将它在CPU寄存器中的数据拿出来暂存在内核态堆栈中，而一个进程恢复工作的本质就是将它的数据重新装入CPU寄存器中，这些移出和装入的数据称为进程的硬件上下文。
可以使用Nmon工具监视系统的平均上下文切换情况。