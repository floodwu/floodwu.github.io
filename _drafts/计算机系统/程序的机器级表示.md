# 程序的机器级表示

对于机器级编程来说，有两种抽象尤为重要：
第一种是**机器级程序的格式和行为**，定义为指令集体系结构（Instruction set architecture），它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA把程序的行为描述成好像每条指令是按顺序执行的，实际处理器硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行完全一致。
第二种是**机器级程序使用的存储器地址是虚拟地址**，提供的存储器模型看上去是一个非常大的字节数组，存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

编译器会将C语言提供的相对比较抽象的执行模型表示的程序转化为处理器执行的非常基本的指令，即汇编代码。汇编代码的表示非常接近于机器代码，如下C语言代码：
```C
int accum = 0 ;
int sum(int x, int y){
int t = x + y;
accum += t;
return t;
}
```
执行`gcc -O1 -S code.c`将产生一个如下内容的code.s文件：
```
sum:
  pushl %ebp
  movl  %esp,%ebp
  movl  12(%ebp),%eax
  addl  8(%ebp),%eax
  addl  %eax,accum
  popl  %ebp
  ret
```
这段代码中已经去除了所有关于局部变量名或数据类型的信息，且代码中有一个对全局变量accum的引用，这是因为编译器还不能确定这个变量会放在存储器中的哪个位置。
如果使用gcc -O1 -c code.c，将生产一个目标文件code.o，它是一个二进制文件，在文件中可以找到一段字节序列：
55 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 5d c3
这段字节序列就是上面汇编代码对应的目标代码，`由此可见机器实际执行的程序只是对一系列指令进行编码的字节序列`。
在Linux上可以使用反汇编器objdump来生成目标代码对应的字节序列：
objdump -d code.o
生成结果如下：
```
00000000 <sum>:
 0:55                     pushl %ebp
 1:89 e5                  movl  %esp,%ebp
 3:8b 45 0c               movl  12(%ebp),%eax
 6:03 45 08               addl  8(%ebp),%eax
 9:01 05 00 00 00 00      addl  %eax,accum
 f:5d                     popl  %ebp
10:c3                     ret
```
生成实际可执行的代码需要对一组目标代码文件运行链接器，这一组目标代码文件中必须含有一个main函数。链接器将代码的地址移到一段地址范围中，且会确定全局变量的地址：
```
08048394 <sum>:
 8048394:55                     pushl %ebp
 8048395:89 e5                  movl  %esp,%ebp
 8048397:8b 45 0c               movl  12(%ebp),%eax
 804839a:03 45 08               addl  8(%ebp),%eax
 804839d:01 05 00 00 00 00      addl  %eax,0x804a018
 80483a3:5d                     popl  %ebp
 80483a4:c3                     ret
```
最终链接后生成的文件会比较大，是因为它不仅包含了多个文件的代码，还包含了用来启动和终止程序的信息，以及用来与操作系统交互的信息。