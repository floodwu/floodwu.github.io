# 虚拟内存区域

内存区域由vm_area_struct结构体表示，描述了指定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都有一致的属性，比如访问权限等，相应的操作也都一致。vm_start、vm_end分别用来表示内存区域的首、尾地址，内存区域的位置就在[vm_start,vm_end]之间。vm_mm域指向对应的mm_struct，所以两个独立的进程将同一个文件映射到各自的地址空间，它们分别都会有一个vm_area_struct来标志自己的内存区域，而如果两个线程共享一个地址空间，那么它们也同时共享其中所有的vm_area_struct结构体。

## VMA标志
VMA标志包含在vm_area_struct的vm_flags域内，是一种位标志，表示内存区域所包含的页面的行为和信息。反映了内核处理页面所需要遵守的行为准则，而不是硬件要求，如VM_READ、VM_WRITE、VM_EXEC分别标志了内存区域中页面的读、写和执行权限。当访问内存区域时，需要查看其访问权限，比如只读文件数据段的映射区域仅标志为VM_READ，而进程的代码映射区则会标志为VM_READ和VM_EXEC。

## 查看进程地址空间中的全部内存区域
cat /proc/<pid>/maps
如：vi test
然后用ps -aux查看pid：
 ![image](https://github.com/woojean/woojean.github.io/blob/master/images/linux_3.png)

## 用pid查看该进程的所有内存区域
 ![image](https://github.com/woojean/woojean.github.io/blob/master/images/linux_4.png)

## 操作内存区域
find_vma()：找到一个给定的内存地址属于哪一个内存区域；
do_mmap()：创建一个新的线性地址区间，如果所创建的地址区间和一个已存在的地址区间相邻，并且它们具有相同的访问权限，则两个区间将合并为一个；
do_mummap()：从特定的进程地址空间中删除指定地址区间；

## 页表
当程序访问一个虚拟地址时，必须将其转化为物理地址，然后处理器才能解析地址并访问请求。地址的转换工作需要通过查询页表才能完成：将虚拟地址分段，使每段虚拟地址都作为一个索引指向页表，而页表项则指向下一级别的页表或指向最终的物理页面。Linux中使用三级页表完成地址转换：
 ![image](https://github.com/woojean/woojean.github.io/blob/master/images/linux_5.png)

## 页高速缓存和页回写
`页高速缓存`是Linux内核实现的磁盘缓存，通过把磁盘中的数据缓存到物理内存中，以此减少对磁盘的I/O操作。页高速缓存由内存中的物理页组成，其内容对应磁盘上的物理块。页高速缓存大小能动态调整。Linux页高速缓存使用address_space结构体管理。

`页回写`则是将高速缓存中的变更数据刷新回磁盘的操作。程序执行写操作直接写到缓存中，后端存储（磁盘、块设备文件等等）不会立即直接更新，而是将页高速缓存中被写入的页面标记成“脏”，并且被加入到脏页链表中，然后由一个进程（回写进程）周期性地将脏页链表中的页写回到磁盘。

之所以要使用磁盘高速缓存，主要源自两个因素：
访问磁盘的速度要远远低于访问内存的速度：ms和ns的差距；
数据一旦被访问，就很可能在短期内再次被访问到：临时局部原理；