# 上半部与下半部

中断处理程序运行需要快速执行（因为不可阻塞），同时要能完成尽可能多的工作，这里存在矛盾。因此把中断处理切分为两个部分，上半部分（top half）接收到一个中断后立即执行，但是只做有严格时限的工作，例如对接收到的中断进行应答或复位硬件。能够被允许稍后完成的工作会推迟到下半部分（bottom half）去，此后`在合适的时机`下半部分会被中断执行，Linux提供了实现下半部分的各种机制。

## 下半部和推后执行的工作
划分工作为上半部或下半部的基本规则：
如果一个任务对时间非常敏感，将其放在上半部；
如果一个任务和硬件相关，将其放在上半部；（例如从网卡的缓存中拷贝数据）
如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在上半部；
其他所有任务考虑放在下半部；

## 下半部的环境
下半部执行的关键在于当它们运行的时候，允许响应所有的中断。至于具体的执行时间并不确定，只是为了把一些任务推迟一点，让它们在系统不太繁忙并且中断恢复后执行就可以了。通常下半部在中断处理程序一返回就会马上运行。

和上半部只能通过中断处理程序实现不同，`下半部可以通过多种机制实现`：
最早的`BH机制`：提供一个静态创建、由32个bottom halves组成的链表，上半部通过一个32位整数中的一位来标识出哪个bottom half可以执行；这种机制简单但不够灵活，存在性能瓶颈；
`任务队列`：内核定义一组队列，其中每个队列都包含一个由等待调用的函数组成的链表，驱动程序可以把自己的下半部注册到合适的队列上去；这种机制无法替代整个BH接口，对于性能要求较高的子系统（比如网络）也不能胜任；
`软中断和tasklet`：这里的软中断指一组静态定义的下半部接口，共32个，可以在所有处理器上同时执行，软中断必须在编译期间就进行静态注册（最多只能注册32个，当前内核已使用9个）。tasklet是一种基于软中断实现的灵活性强、动态创建的下半部实现机制，其实是一种在性能和易用性之间寻求平衡的产物，对于大部分下半部处理来说，使用tasklet就足够了，对于网络这种性能要求较高的情况才需要使用软中断；
`定时器`：不同于其他实现方式，定时器可以把操作推迟到某个确定的时间段之后执行；