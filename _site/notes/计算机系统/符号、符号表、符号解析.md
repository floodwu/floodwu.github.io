# 符号、符号表、符号解析

## 符号和符号表
对于任意一个目标模块m，在链接器的上下文中有3种不同的符号：
1.由模块m定义并能被其他模块引用的全局符号，对应非静态的C函数和被定义为不带C static属性的全局变量；
2.由其他模块定义并被模块m引用的全局符号，这些符号称为外部符号，对应定义在其他模块中的C函数和变量；
3.只被模块m定义和引用的本地符号。对应带static属性的C函数和全局变量（不含本地非静态程序变量的任何符号，因为它们在运行时由栈管理）。

注：C源代码文件扮演模块的角色，任何声明带有static属性的全局变量或者函数都是模块私有的，类似地，任何声明为不带static属性的全局变量和函数都是公有的，可以被其他模块访问。定义为带有C static属性的本地过程变量不是在栈中管理，编译器在.data和.bss中为每一个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。

.symtab节中包含符号表，其条目的结构为Elf_Symbol。（详略）

如下程序main.c程序：
```C
void swap();
int buf[2] = {1,2};

int main(){
	swap();
	return 0;
}
```
编译得到的main.o的符号表的最后3个条目（开始的8个条目是链接器内部使用的本地符号，没有显示出来）如下：
```
Num   Value   Size   Type        Bind     Ot   Ndx   Name
8       0      8     Object      GLOBAL   0     3     buf
9       0      17    FUNC        GLOBAL   0     1     main
10      0      0     NOTYPE      GLOBAL   0    UND    swap  <- 对外部符号的引用
```

## 符号解析
符号解析即将每个符号引用与输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。
对于引用和定义处于相同模块中的本地符号的引用，符号解析是非常简单明了的：编译器只允许每个模块中的每个本地符号仅有一个定义。此外编译器还保存静态本地变量，它们也会有本地链接器符号，且拥有唯一的名字。

对于全局符号，在编译时编译器向汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。据此，Unix链接器使用如下规则来处理多重定义的符号：
1.不允许有多个强符号；
2.如果有一个强符号和多个弱符号，那么选择强符号；
3.如果有多个弱符号，那么从这些弱符号中任意选择一个；

如：
```C
// foo1.c
int main(){
	return 0;
}

// bar1.c
int main(){
	return 0;
}
```
当试图编译和链接如上两个C模块时，链接器将生成一条错误信息，因为强符号main被定义了多次。

再比如：
```C
// foo2.c
#include <stdio.h>
void f(void);

int x = 15213;

int main(){
   f();
   printf("x = %d\n",x);
   return 0;
}

// bar2.c
int x;

void f(){
	x = 15212;
}
```
当编译和链接以上两个文件时，因为bar2中的x未被初始化，链接器将选择定义在foo2中的强符号x，函数f会将x的值由15213改成15212，由此可能会造成一些不易察觉的运行时错误（链接器通常不会表明它检测到了多个x的定义）。