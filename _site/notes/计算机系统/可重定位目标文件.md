# 可重定位目标文件

## 目标文件
目标文件有3种形式：
1.可重定位目标文件：可以在编译时与其他可重定位目标文件合并以创建一个可执行目标文件。
2.可执行目标文件：可以被直接拷贝到存储器并执行。
3.共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。
可重定位目标文件（包括共享目标文件）由编译器和汇编器生成，可执行目标文件由链接器生成。

## 可重定位目标文件
一个目标文件就是一个字节序列，不同系统上的目标文件格式不同，以下是ELF（Unix可执行和可链接）格式的目标文件的结构：
```
+-------------+
-   ELF头     - 
+-------------+
-   .text     -
+-------------+
-   .rodata   -
+-------------+
-   .data     -
+-------------+
-   .bss      -
+-------------+
-   .symtab   -
+-------------+
-   .rel.text -
+-------------+
-   .rel.data -
+-------------+
-   .debug    -
+-------------+
-   .line     -
+-------------+
-   .strtab   -
+-------------+
```
`ELF头`：描述了生成该文件的系统的字的大小和字节顺序，以及帮助链接器语法分析和解释目标文件的信息；
`.text`：已编译程序的机器代码；
`.rodata`：只读数据；
`.data`：已初始化的全局C变量（不含静态变量和局部变量）；
`.bss`：未初始化的全局C变量，不占据实际的磁盘空间，仅仅是一个占位符；
`.symtab`：符号表，存放在程序中定义和引用的函数和全局变量的信息；
`.rel.text`：.text节中位置的列表，当和其他目标文件结合时，链接器需要修改这些位置。任何调用外部函数或者引用全局变量的指令都需要修改，调用本地函数的指令则不需要修改。可执行目标文件中并不需要重定位信息，因此通常省略。
`.rel.data`：被模块引用或定义的任何全局变量的重定位信息，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改；
`.debug`：调试符号表，只有以-g选项编译时才会生成。其条目是程序中定义的局部变量和类型定义、程序中定义和引用的全局变量以及原始的C源文件；
`.line`：原始C程序中的行号和.text节中机器指令之间的映射，只有以-g选项编译时才会生成。
`.strtab`：一个字符串表，包括.symtab和.debug节中的符号表，以及节头部中的节名字；

## 重定位
符号解析完成后，代码中的每个符号引用就和一个符号定义联系起来，因此链接器就知道了输入目标模块中的代码节和数据节的确切大小，因而可以进行重定位操作：合并输入模块，并为每个符号分配运行时地址。重定位具体分为两步：
1.重定位节和符号定义：将所有相同类型的节点合并为同一个类型的新的聚合节，然后将运行时存储器地址赋给新的聚合节，从而赋给输入模块定义的每个节、每个符号。当这一步完成时，程序中每个指令和全局变量都有唯一的运行时存储器地址了。
2.重定位节中的符号引用：修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。这一步的执行依赖于可重定位目标模块中名为重定位条目的数据结构。当汇编器生成目标模块时，因为它并不知道数据和代码最终将存放在存储器中的什么位置，也不知道这个模块引用的任何外部定义的函数或者全局变量的位置，所以当汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，以告诉链接器将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。（ELF定义了11种不同的重定位类型，详略）