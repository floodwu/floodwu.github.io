# Unix I/O

I/O是在主存和外设（磁盘驱动器、终端、网络等）之间拷贝数据的过程。编程语言都提供了执行I/O的库，如C标准库中的I/O库（包含printf和scanf等），C++中的<<和>>。在Unix系统上它们都是通过由内核提供的系统级Unix I/O函数来实现这些较高级别的I/O函数的，大多数情况下没有必要直接使用Unix I/O），但是在某些重要的情况下使用高级I/O函数不太可能，或者不太合适，比如标准I/O库没有提供读取文件元数据的方式（文件大小、创建时间等），此外I/O库也存在一些问题使得用它来进行网络编程非常冒险。

## Unix I/O
所有的I/O设备都被模型化为文件，所有的输入、输出操作都被当做对相应文件的读和写来执行。一个Unix文件就是一个字节的序列，Unix使用Unix I/O来使得所有的输入、输出都能以一种统一且一致的方式执行，Unix I/O的操作包括：
1.打开文件：内核返回一个非负整数，叫做文件描述符，后续对此文件的所有操作都通过这个文件描述符进行（应用程序只要记住这个描述符，内核记录有关这个已打开文件的所有信息）；Unix Shell创建的每个进程开始时都有3个打开的文件：标准输入（0）、标准输出（1）、标准错误（2）；
2.改变当前的文件位置：对于每个打开的文件内核都维持了一个当前位置，记录了从文件开头起始的字节偏移量，初始为0。应用程序能够通过执行seek操作显式地设置文件的当前位置；
3.读写文件：一个读操作就是从文件拷贝若干字节到存储器，当当前位置超过文件大小时，会触发一个EOF事件。写操作就是从存储器拷贝若干字节到一个文件；
4.关闭文件：内核会释放文件打开时创建的数据结构，并将文件描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止，内核都会关闭所有打开的文件并释放它们的存储器资源；

## 打开和关闭文件
```c
/* 打开文件
filename 文件名
flags 打开方式：只读、只写、读写
mode 指定新文件的访问权限位（umask）
*/
int open(char *filename, int flags, mode_t mode);
```
如：
```c
umask(DEF_UMASK);
fd = open('foo.txt', O_CREAT|O_TRUNC|O_WRONLY, DEF_MODE);
...

// 关闭文件
int close(int fd);
关闭一个已关闭的描述符会出错（返回-1）。
```

## 读和写文件
```c
ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
```
如：
```c
char c;
while( read(STDIN_FILENO, &c, 1) != 0 ){
	write(STDOUT_FILENNO, &c, 1);
}
exit(0);
```
在某些情况下read和write传送的字节比应用程序要求的要少，这些不足值不表示有错误，可能由如下原因引起：
1.读文件时遇到EOF；
2.从终端读文本行，这种情况下read函数将一次传送一个文本行；
3.读和写网络套接字时，内部的缓冲约束和较长的网络延迟都会引起read和write返回不足值；
4.对Unix管道调用read和write时也有可能出现不足值；