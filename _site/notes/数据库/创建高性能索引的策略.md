# 创建高性能索引的策略

## 索引的优点
1.减少服务器需要扫描的数据量；
2.避免排序和临时表；
3.将随机I/O变为顺序I/O；

## 高性能的索引策略
1.如果查询中的列不是独立的，而是表达式的一部分，MySQL将不会使用索引；
```
 # 如下情况下不会使用索引
 SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

2.索引的选择性越高则查询的效率越高；（索引选择性 = 列取值基数/表记录总数）
```
 # 计算列的选择性
 SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
```

3.可以使用前缀索引来替代对很长的字符列做索引；
```
 # 计算不同前缀长度的索引的选择性
 SELECT 
   COUNT(DISTINCT LEFT(city,3))/COUNT(*) AS sel3,
   COUNT(DISTINCT LEFT(city,4))/COUNT(*) AS sel4,
   ...
   COUNT(DISTINCT LEFT(city,7))/COUNT(*) AS sel7,
FROM sakila.city_demo;

 # 添加前缀索引
ALTER TABLE sakila.city_demo ADD KEY(city(7));
```
MySQL不能使用前缀索引做ORDER BY和GROUP BY查询，也无法使用前缀索引做覆盖扫描。


4.在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能：
（1）当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的多列索引；
（2）当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要消耗大量的CPU和内存资源用在缓存、排序和合并操作上。而且优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取，这会导致查询的成本被低估，`甚至该执行计划还不如直接走全表扫描`。这样的查询通常通过改写成UNION查询来优化：
```
 # 假设actor_id和film_id这两列上都有独立的索引
SELECT film_id,actor_id FROM sakila.film_actor
  WHERE actor_id = 1 OR film_id = 1;
```
改写成：
```
SELECT film_id,actor_id FROM sakila.film_actor
  WHERE actor_id = 1
UNION ALL
SELECT film_id,actor_id FROM sakila.film_actor
  WHERE actor_id <> 1 AND film_id = 1;
```

5.多列索引的列顺序非常重要，在一个多列的B-Tree索引中，索引总是先按照最左列进行排序，其次是第二列，等等。
经验：一般的选择是将选择性最高的列放到索引最前列，但是避免随机IO和排序通常更为重要，所以要优先结合值的分布情况及频繁执行的查询场景来考虑。