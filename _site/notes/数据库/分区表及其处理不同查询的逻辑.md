# 分区表及其处理不同查询的逻辑

## 分区表
分区表是一个独立的逻辑表，但是底层由多个物理子表组成（意味着可以分布在不同的物理设备上）。对分区表的请求都会通过句柄对象转化成对存储引擎的接口调用，对应用来说是透明的。
MySQL中索引也是按照分区的子表定义的，而没有全局索引。

一个表最多只能有1024个分区。
如果分区表字段中有主键或者唯一索引的列，那么所有的主键列和唯一索引列都必须包含进来。
分区表中无法使用外键约束。

## 分区表上操作的逻辑
SELECT：分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据；
INSERT：分区层先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录写入对应底层表；
DELETE：分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作；
UPDATE：分区层先打开并锁住所有的底层表，先确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作。
虽然每个操作都会先打开并锁住所有的底层表，但这并不意味着分区表在处理过程中是锁住全表的，如果存储引擎能够实现行级锁，则会在分区层释放对应表锁。

## 分区表达式要返回一个整数
```
CREATE TABLE sales(
  order_date DATETIME NOT NULL,
  ...
)ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date))(
  PARTITION p_2010 VALUES LESS THAN(2010),
  PARTITION p_2011 VALUES LESS THAN(2011),
  PARTITION p_2012 VALUES LESS THAN(2012),
  PARTITION p_catchall VALUES LESS MAXVALUE
);
```

在数据量超大时，B-Tree索引就无法起作用了，除非是索引覆盖查询，否则需要根据索引扫描的结果回表查询所有符合条件的记录，如果数据量巨大，将产生大量随机I/O，从而导致数据库的响应时间大到不可接受的程度。