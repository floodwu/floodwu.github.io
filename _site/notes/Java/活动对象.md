# 活动对象

每个活动对象都维护着它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中一个。有了活动对象就可以串行化消息而不是方法，意味着不需要再防备一个任务在其循环的中间被中断这种问题。

当向一个活动对象发送消息时，这条消息会被转变为一个任务，该任务会被插入到这个对象的队列中，等待在以后的某个时刻运行。
```java
public class ActiveObjectDemo {
  private ExecutorService ex =
    Executors.newSingleThreadExecutor();  // 单线程执行器
  private Random rand = new Random(47);
  // Insert a random delay to produce the effect
  // of a calculation time:
  private void pause(int factor) {
    try {
      TimeUnit.MILLISECONDS.sleep(
        100 + rand.nextInt(factor));
    } catch(InterruptedException e) {
      print("sleep() interrupted");
    }
  }

  // 返回一个Future对象以响应调用（意味着把方法调用转变为消息，方法调用可以立即返回，调用者可以使用Feture来发现任务何时完成并收集返回值）
  public Future<Integer>
  calculateInt(final int x, final int y) {
    return ex.submit(new Callable<Integer>() {
      public Integer call() {
        print("starting " + x + " + " + y);
        pause(500);
        return x + y;
      }
    });
  }
  public Future<Float>
  calculateFloat(final float x, final float y) {
    return ex.submit(new Callable<Float>() {
      public Float call() {
        print("starting " + x + " + " + y);
        pause(2000);
        return x + y;
      }
    });
  }
  public void shutdown() { ex.shutdown(); }
  public static void main(String[] args) {
    ActiveObjectDemo d1 = new ActiveObjectDemo();
    // Prevents ConcurrentModificationException:
    List<Future<?>> results =
      new CopyOnWriteArrayList<Future<?>>();
    for(float f = 0.0f; f < 1.0f; f += 0.2f)
      results.add(d1.calculateFloat(f, f));
    for(int i = 0; i < 5; i++)
      results.add(d1.calculateInt(i, i));
    print("All asynch calls made");
    while(results.size() > 0) {
      for(Future<?> f : results)
        if(f.isDone()) {
          try {
            print(f.get());
          } catch(Exception e) {
            throw new RuntimeException(e);
          }
          results.remove(f);
        }
    }
    d1.shutdown();
  }
}
```
因为从一个活动对象到另一个活动对象的消息只能被排队时的延迟所阻塞，并且因为这个延迟总是非常短且独立于任何其他对象，所以发送消息实际上是不可阻塞的。由于一个活动对象系统只是经由消息来通信，所以两个对象在竞争调用另一个对象上的方法时，是不会被阻塞的，这意味着不会发生死锁。因为在活动对象中的工作器线程在任意时刻只执行一个消息，所以就不存在任何资源竞争，因而也不用操心如何同步方法。（实际上同步仍然发生，但是它是通过将方法调用排队，使得任意时刻都只能发生一个调用，从而将同步控制在消息级别上发生）