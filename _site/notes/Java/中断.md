# 中断

Thread类的interrupt()方法可以终止被阻塞的任务（设置线程的中断状态），如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么该操作将抛出InterruptedException。抛出该异常后，中断状态将被复位。
当调用Thread.interrupted()方法时，中断状态也将被复位（提供了离开run()循环而不抛出异常的方式）。

如果在Executor上调用shutdownNow()，那么它将发送一个interrupt()调用给它启动的所有线程。如果对单个线程进行操作，那么应该通过调用submit()而不是executor()来启动任务，submit()将返回一个Future，可以通过它调用cancel()从而中断某个特定任务。

可以中断对sleep()的调用，但是`不能中断正在试图获取synchronize锁或试图执行I/O操作的线程`。对于这类问题有一个比较挫但是有效的解决方案：关闭任务在其上发生阻塞的底层资源。
```java
class SleepBlocked implements Runnable {
  public void run() {
    try {
      TimeUnit.SECONDS.sleep(100);
    } catch(InterruptedException e) {   // 可中断
      print("InterruptedException");
    }
    print("Exiting SleepBlocked.run()");
  }
}

class IOBlocked implements Runnable {
  private InputStream in;
  public IOBlocked(InputStream is) { in = is; }
  public void run() {
    try {
      print("Waiting for read():");
      in.read();
    } catch(IOException e) {
      if(Thread.currentThread().isInterrupted()) {  // isInterrupted()
        print("Interrupted from blocked I/O");
      } else {
        throw new RuntimeException(e);
      }
    }
    print("Exiting IOBlocked.run()");
  }
}

class SynchronizedBlocked implements Runnable {
  public synchronized void f() {
    while(true) // Never releases lock
      Thread.yield();
  }
  public SynchronizedBlocked() {
    new Thread() {
      public void run() {
        f(); // Lock acquired by this thread
      }
    }.start();
  }
  public void run() {
    print("Trying to call f()");
    f();
    print("Exiting SynchronizedBlocked.run()");
  }
}

public class Interrupting {
  private static ExecutorService exec =
    Executors.newCachedThreadPool();
  static void test(Runnable r) throws InterruptedException{
    Future<?> f = exec.submit(r);
    TimeUnit.MILLISECONDS.sleep(100);
    print("Interrupting " + r.getClass().getName());
    f.cancel(true); // 中断
    print("Interrupt sent to " + r.getClass().getName());
  }
  public static void main(String[] args) throws Exception {
    test(new SleepBlocked());  // 可以中断
    test(new IOBlocked(System.in));  // 无法中断
    test(new SynchronizedBlocked()); // 无法中断
    TimeUnit.SECONDS.sleep(3);
    print("Aborting with System.exit(0)");
    System.exit(0); // ... since last 2 interrupts failed
  }
}
```

如果想中断被互斥阻塞的任务，应该使用ReentrantLock（synchronize不可中断）。

nio类提供了更加人性化的I/O中断，被阻塞的nio通道会自动地响应中断。

可以通过调用interrupted()来检查中断状态，这个方法同时会清除中断状态以确保并发结构不会就某个任务被中断这个问题通知多次

## 检查中断
```
class NeedsCleanup {
  private final int id;
  public NeedsCleanup(int ident) {
    id = ident;
    print("NeedsCleanup " + id);
  }

  // 发生异常时必须执行的清理操作
  public void cleanup() {
    print("Cleaning up " + id);
  }
}

class Blocked3 implements Runnable {
  private volatile double d = 0.0;
  public void run() {
    try {
      while(!Thread.interrupted()) {
        // 如果在从这里到sleep()之前或调用过程中interrupt()被调用（即在阻塞操作之前或者阻塞过程中），那么这个任务就会在第一次试图调用阻塞操作之前经由InterruptedException退出
        NeedsCleanup n1 = new NeedsCleanup(1);
        try {  // 在定义了“发生异常需要清理”的对象之后，要紧接着就写try语句，以此来保证该对象可以被正常清理
          print("Sleeping");
          TimeUnit.SECONDS.sleep(1);  // ！阻塞操作
          // 如果interrupt()在这里被调用（在非阻塞的操作过程中），那么interrupted()会检测到，while循环会退出
          NeedsCleanup n2 = new NeedsCleanup(2);
          try { // 紧跟着定义语句，道理同上
            print("Calculating");
            // A time-consuming, non-blocking operation:
            for(int i = 1; i < 2500000; i++)
              d = d + (Math.PI + Math.E) / d;
            print("Finished time-consuming operation");
          } finally {
            n2.cleanup();
          }
        } finally {
          n1.cleanup();
        }
      }
      print("Exiting via while() test");
    } catch(InterruptedException e) {
      print("Exiting via InterruptedException");
    }
  }
}

public class InterruptingIdiom {
  public static void main(String[] args) throws Exception {
    if(args.length != 1) {
      print("usage: java InterruptingIdiom delay-in-mS");
      System.exit(1);
    }
    Thread t = new Thread(new Blocked3());
    t.start();
    TimeUnit.MILLISECONDS.sleep(new Integer(args[0]));
    t.interrupt();
  }
}
```