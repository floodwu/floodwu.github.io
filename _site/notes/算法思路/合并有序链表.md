# 合并有序链表

递归算法所体现的“重复”一般有三个要求： 
一是每次调用在规模上都有所缩小(通常是减半)； 
二是相邻两次重复之间有紧密的联系，前一次要为后一次做准备(通常前一次的输出就作为后一次的输入)； 
三是在问题的规模极小时必须用直接给出解答而不再进行递归调用，因而每次递归调用都是有条件的(以规模未达到直接解答的大小为条件)，无条件递归调用将会成为死循环而不能正常结束。

如何设计递归算法
1.确定递归公式 
2.确定边界(终了)条件递归实现：

算法思想：
递归终止条件：若head1为空，返回head2指针（head）；若head2为空，返回head1指针（head）
递归过程：
1.若head1->data > head2->data; head 指针应该指向head2所指向的节点，而且head->next应该指向head1和head2->next两个链表的合成序列的头指针；
2.否则head 指针应该指向head1所指向的节点，而且head->next应该指向head->next和head2两个链表的合成序列的头指针；

实现代码：  
```c++
#include <iostream>
using namespace std;
    
// 节点的类定义
class Node{
  public:
  int data;
  Node * next;
  Node(int data){
    this->data=data;
  }
};

// 链表的类定义
class LinkedList{
  public:
    Node * head;
    
    // 用一个整形数组作为参数的构造函数
    LinkedList(int array[]){
      head=new Node(array[0]);
      Node * temp = head;
      int i;
      for(i=1;i<3;i++){
        temp->next=new Node(array[i]);
        temp=temp->next;
      }
      temp->next=NULL;
    }
};

// 递归的合并两个有序链表
Node * mergeLinkedList(Node * head1, Node * head2){   
  Node *p=NULL;   
  if(head1==NULL && head2==NULL){   
    return p;   
  }
  else if( head1==NULL ){   
    return head2;
  }   
  else if( head2==NULL ){   
    return head1;
  }   
  else{   
    if( head1->data < head2->data ){   
      p = head1;   
      p->next = mergeLinkedList( head1->next,head2 );   
    }   
    else{
      p = head2;   
      p->next = mergeLinkedList( head1,head2->next );   
    }   
    return p;   
  }   
} 

// 打印链表的所有元素
void printList(Node * head){
  Node * temp=head;
  while(temp!=NULL){
    cout<<temp->data<<"  ";
    temp=temp->next;
  }
}

int main(){
  int array1[3]={2,5,8};
  int array2[3]={1,6,7};

  // 构造两个有序链表--list1和list2
  LinkedList list1(array1);
  LinkedList list2(array2);

  // 递归的将这两个有序链表合并成一个有序链表
  Node * new_head = mergeLinkedList(list1.head, list2.head);
    
  // 打印有序链表
  printList(new_head);
  return 0;
}
```