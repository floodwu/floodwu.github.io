# 计算字符串的相似度

分析：两个字符串的距离肯定不超过它们的长度之和。
考虑如何才能把这个问题转化成规模较小的同样的问题：
如果两个串A和B的第一个字符是相同的，则只要计算A[2，…lenA]和B[2，…lenB]的距离就可以了。但是如果两个串的第一个字符不相同，那么进行如下操作：
1.删除A串的第一个字符，然后计算A[2，…lenA]和B[1，…lenB]的距离；
2.删除B串的第一个字符，然后计算A[1，…lenA]和B[2，…lenB]的距离；
3.修改A串的第一个字符为B串的第一个字符，然后计算A[2，…lenA]和B[2，…lenB]的距离；
4.修改B串的第一个字符为A串的第一个字符，然后计算A[2，…lenA]和B[2，…lenB]的距离；
5.增加B串的第一个字符到A串的第一个字符之前，然后计算A[1，…lenA]和B[2，…lenB]的距离；
6.增加A串的第一个字符到B串的第一个字符之前，然后计算A[2，…lenA]和B[1，…lenB]的距离；

由题意知，并不在乎两个字符串变得相等之后的字符串是怎样的，所以可以将上面的6个操作合并为：
1.一步操作之后，再将A[2，…lenA]和B[1，…lenB]变成相同的字符串；
2.一步操作之后，再将A[1，…lenA]和B[2，…lenB]变成相同的字符串；
3.一步操作之后，再将A[2，…lenA]和B[2，…lenB]变成相同的字符串；
实现代码：
```C++
int CalculateStringDistance( string strA, int pABegin, int pAEnd, string strB, int pBBegin, int pBEnd)
{
	if(pABegin > pAEnd)
	{
		if( pBBegin > pBEnd)
			return 0;
		else
			return pBEnd – pBBegin +1;
	}

	if(pBBegin > pBEnd)
	{
		if(pABegin > pAEnd)
			return 0;
		else
			return pAEnd – pABegin + 1;
	}
	
	if( strA[pABegin] == strB[pBBegin])
		return CalculateStringDistance( strA, pABegin +1, pAEnd, strB, pBBegin +1, pBEnd);
	else
	{
		int t1 = CalculateStringDistance( strA, pABegin, pAEnd, strB, pBBegin +1, pBEnd);
		int t2 = CalculateStringDistance( strA, pABegin +1, pAEnd, strB, pBBegin, pBEnd);
		int t3 = CalculateStringDistance( strA, pABegin +1, pAEnd, strB, pBBegin +1, pBEnd);
		return minValue( t1, t2, t3) + 1;
	}
}
```