# 大数相加问题

实现A+B=C,其中A、B位数超过100位 
算法思想：大数使用字符串存储，每一个单元存储操作数的每一位，之后执行位相加。
基本思路：字符串反转、字符变数字、位运算、反序输出
C语言代码：

```c++
#include <stdio.h>   
#include<string.h>   
#define Max 101   

void print(char sum[], int result_len);  
int bigNumAdd(char a[],char b[],char sum[]);  
  
int main()  {  
  char a[Max]={0};  
  char b[Max]={0};  
  char sum[Max]={0};  
  puts("input a:");  
  gets(a);             /*  char* gets(char*buffer); 头文件stdio.h .gets(s)函数与scanf("%s",s)相似，但不完全相同，使用scanf("%s",s) 函数输入字符串时存在一个问题，就是如果输入了空格会认为字符串结束，空格后的字符将作为下一个输入项处理，但gets()函数将接收输入的整个字符串直到遇到换行为止 */
  puts("input b:");  
  gets(b);  
  print(sum, bigNumAdd(a,b,sum));  
  return 0;  
}  
  
int bigNumAdd(char a[], char b[], char sum[]){  
  int i=0;  
  int c=0;  // 表示进位   
  
  char m[Max]={0};  
    char n[Max]={0};  
    memset(sum,0,Max*sizeof(char));  // 重要
  
    // 字符串反转且字符串变数字   
    int lenA=strlen(a);  
    int lenB=strlen(b);  
      
    int result_len = (lenA > lenB)?lenA:lenB;  
    for (i=0;i<lenA;i++){  
        m[i]=a[lenA-i-1]-'0';  
    }  

    for (i=0;i<lenB;i++){  
        n[i]=b[lenB-i-1]-'0';  
    }  
  
    // 按位运算   
    for (i=0;i<lenA||i<lenB;i++){  
        sum[i]=(m[i]+n[i]+c)%10+'0';  // 得到末位   
        c=(m[i]+n[i]+c)/10;  // 得到进位   
    }  
  
    if (c){  
        result_len++;// 最后一次有进位，长度+1   
    }  
    return result_len;  
}  
  
void print(char sum[], int result_len){  
  int j=0;  
  int i=0;  
  
  for(j=result_len-1; j>=0; j--){  
    i++;  
    printf("%c",sum[j]);  
  }  
  puts("\n");  
} 
```