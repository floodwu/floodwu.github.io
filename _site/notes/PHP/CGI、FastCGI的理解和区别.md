# CGI、FastCGI的理解和区别

CGI：CGI叫“公共网关接口”(Common Gateway Interface), CGI描述了客户端和服务器程序之间传输数据的一种标准,就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。总之，`CGI是一种标准，一种协议`。

CGI程序：CGI程序确保CGI协议的顺利执行，并且返回结果，用来沟通程序(如PHP, Python, Java)和Web服务器(Apache2, Nginx), 充当桥梁的作用。即CGI程序是介于Web服务器与Web程序之间的，用来保证CGI协议的程序。如php-fpm。

web server（比如说nginx）只是内容的分发者。比如，如果客户端(比如浏览器)请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，那它就要找到相应的CGI程序来处理了，根据配置，找到了php-cgi这个程序（也就是PHP解析器）,那么他会把这个请求交个php-cgi（PHP解析器）。`nginx会启动CGI程序,然后会根据CGI协议，把需要的数据传给全部丢给php-cgi`，比如请求的url，查询字符串，POST数据，HTTP header等等。php-cgi(PHP解析器)会解析php.ini文件，初始化执行环境，然后找到index.php，编译，执行,把执行结果返回给客户端。
CGI执行过程的特点是：每次请求过来，再启动CGI程序，去处理请求。所以就会造成，如果50个请求过来，就得启动50个CGI程序的进程来处理，处理完之后，就销毁相应的线程。
但是启动一个进程，肯定是需要时间的，这样大量的启动、销毁，造成了大量的浪费。

FastCGI会启动FastCGI进程管理器（简称`master`），解析配置文件，初始化执行环境，master再启动多个CGI程序(简称`worker`)在那里等候。master的职责是：请求过来，把请求传递给到空闲的worker,然后立即可以接受下一个请求，再传递。worker的职责是：每个worker都一直在等候，接到从master传递过来的请求之后，立即执行并返回，但是执行完毕后，不销毁，而且继续等待下个请求。当然，master还时时刻刻监控着worker的情况，如果worker不够了，master会启动多几个，如果空闲的太多了，停掉一些。这样一种方法，`比起老的CGI执行，省去了大量的启动、销毁线程的时间和节约了大量的资源`。

修改php.ini后，FastCgi可以平滑的重启,执行php-fpm reload。php-cgi进程是没办法平滑重启的，需要restart。

CGI 的工作方式，从 Web 服务器的角度看，是在特定的位置（位置指url，比如：http://www.example.com/wiki.cgi）定义了可以运行的CGI 程序（比如一个脚本，但也可能不是脚本，比如用C实现CGI）。当收到一个匹配URL的请求，相应的程序就会被调用（如果是脚本，则应该调用脚本解释器进行解释），并将客户端发送的数据作为输入。程序的输出会由 Web 服务器收集，并加上合适的档头，再发送回客户端。
一般每次的 CGI 请求都需要新生成一个程序的副本来运行，这样大的工作量会很快将服务器压垮，因此一些更有效的技术可以让脚本解释器直接作为模块集成在 Web 服务器（例如：Apache，mod_php）中，这样就能避免重复载入和初始化解释器。不过这只是就那些需要解释器的高级语言（即解释语言）而言的，使用诸如C一类的编译语言则可以避免这种额外负荷。由于 C 及其他编译语言的程序与解释语言程序相比，前者的运行速度更快、对操作系统的负荷更小，使用编译语言程序是可能达到更高执行效率的，然而因为开发效率等原因，在目前解释性语言还是最合适的。
与为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。这些进程由FastCGI服务器管理，而不是web服务器。 当进来一个请求时，web服务器把环境变量和这个页面请求通过一个socket比如FastCGI进程与web服务器(都位于本地）或者一个TCP connection（FastCGI进程在远端的server farm）传递给FastCGI进程。Apache通过mod_fcgid以及较早的第三方mod_fastcgi模块来实现。 