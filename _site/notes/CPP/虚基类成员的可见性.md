# 虚基类成员的可见性

假定通过多个派生路径继承名为 X 的成员，有下面三种可能性：
1）如果在每个路径中 X 表示同一虚基类成员，则没有二义性，因为共享该成员的单个实例。
2）如果在某个路径中 X 是虚基类的成员，而在另一路径中 X 是后代派生类的成员，也没有二义性——特定派生类实例的优先级高于共享虚基类实例。
3）如果沿每个继承路径 X 表示后代派生类的不同成员，则该成员的直接访问是二义性的。
像非虚多重继承层次一样，这种二义性最好用在派生类中提供覆盖实例的类来解决。
特殊的初始化语义：通常，每个类只初始化自己的直接基类。如果使用常规规则，就可能会多次初始化虚基类。类将沿着包含该虚基类的每个继承路径初始化。为了解决这个重复初始化问题，从具有虚基类的类继承的类对初始化进行特殊处理。在虚派生中，由最低层派生类的构造函数初始化虚基类。虽然由最低层派生类初始化虚基类，但是任何直接或间接继承虚基类的类一般也必须为该基类提供自己的初始化式。只要可以创建虚基类派生类类型的独立对象，该类就必须初始化自己的虚基类，这些初始化式只有创建中间类型的对象时使用。