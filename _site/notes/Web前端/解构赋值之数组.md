# 解构赋值之数组

```
var [a, b, c] = [1, 2, 3];

let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []


// 支持不完全结构
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4

// 允许指定默认值
var [foo = true] = [];
foo // true

[x, y = 'b'] = ['a']; // x='a', y='b'
[x, y = 'b'] = ['a', undefined]; // x='a', y='b'

// ES6内部使用严格相等运算符（===），判断一个位置是否有值
var [x = 1] = [undefined];
x // 1

var [x = 1] = [null];
x // null

```

如果等号的右边不是`可遍历`的结构，那么将会报错:
```
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

如果默认值是一个表达式，那么这个表达式是惰性求值的：
```
// 因为x能取到值，所以函数f根本不会执行
function f() {
  console.log('aaa');
}

let [x = f()] = [1];
```