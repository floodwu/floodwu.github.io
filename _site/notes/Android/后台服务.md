# 后台服务

服务就是Android应用的后台，即使前台关闭，activity长时间停止运行，后台服务依然可以持续不断地执行工作任务。
Service不是独立的线程，运行在主线程中。IntentService运行在单独的线程中。服务的Intent也称命令，IntentService接收到首个命令时，即完成启动，并触发一个后台线程，然后将命令放入队列。IntentService逐个执行命令队列里的命令，为每一条命令在后台线程上调用onHandleIntent方法。执行完队列中全部命令后，服务也随即停止并被销毁。

服务按启动方式可分为两种：
1.Started：即通过startService()方式启动的服务。将单独在后台运行，即使启动它的Component已经被销毁。一般用来执行一个单独的操作，操作执行结束后，Service即销毁，比如上传文件。
2.Bound即通过bindService()绑定到特定Component的方式来启动，提供了一个C/S方式的交互通道，使得所绑定的Component可以与Service进行交互：即可以发送request，接收result，甚至实现跨进程通信。多个Component可以绑定到同一个Service，一旦它们全部unbind，则该Service将自动销毁。
两种方式启动Service的生命周期：
  ![image](https://github.com/woojean/woojean.github.io/blob/master/images/android_5.png)

服务的类型由onStartCommand()方法的返回值决定，可能的返回值包括：Service.START_NOT_STICKY，START_REDELIVER_INTENT，START_STICK。

non-sticky服务：IntentService是一种non-sticky服务，在服务自己认为已完成任务时停止。no-sticky服务包括：START_NOT_STICKY,START_REDELIVER_INTENT，区别在于：如果系统要在服务完成任务之前关闭它，则服务的具体表现会有所不同，STRAT_NOT_STICK型服务会被关闭，而START_REDELIVER_INTENT型服务会在可用资源不再吃紧时，尝试再次启动服务。IntentService默认是START_NOT_STICK型服务，但是可以通过调用IntentService.setIntentRedelivery(true)方法来切换使用START_REDELIVER_INTENT。

sticky服务：会持续运行，直到外部组件调用Context.stopService(Intent)方法让它停止为止。适用于长时间运行，直到用户主动停止的服务。

延迟运行服务：
延迟运行服务的一种方式是调用Handler的sendMessageDelayed(...)或者postDelayed(...)方法。但如果用户离开当前应用，进程就会停止，Handler消息也会随之消亡，因此该解决方案不可靠。
应该使用AlarmManager结合PendingIntent来实现延迟运行服务：创建一个启动特定服务的Intent，然后用PendingIntent进行打包，并发送给AlarmManager。
即使进程停止了（如通过按后退键退出应用），AlarmManager依然会不断地发送intent，以反复启动服务。
一个PendingIntent只能登记一个定时器。

例：在后台查询新的搜索结果，一旦有了新的搜索结果，用户即可在状态栏收到通知信息。
创建一个IntentService：
```java
public class PollService extends IntentService{
private static final POLL_INTERVAL = 1000*15;

public PollService(){
}

@Override
protected void onHandleIntent(Intent intent){
// 检查后台网络是否可用：因为Android为用户提供了关闭后台应用网络连接的功能（节省流量、电量）
ConnectivityManager cm = 
(ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);

@SuppressWarning(“deprecation”)
// getBackgroundDataSetting()用于旧版本系统
// 要使用getActiveNetworkInfo()方法，需要添加：
<uses-permission android:name=”android.permission.ACCESS_NETWORK_STATE” />
boolean isNetworkAvailable = 
cm.getBackgroundDataSetting() && cm.getActiveNetworkInfo() != null;
if(!isNetworkAvailable) return;

// SharedPreferences中保存了最近一次的加载记录，可能有两种情况，一是没有使用查询条件，二是使用了查询条件。如果最近一次的加载记录（即SharedPreferences中当前存储的值）是使用了查询条件的，那么query就代表其查询关键字，而lastRequestId就是查询结果中的第一条记录的ID。
SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
String query = prefs.getString(FlickrFetchr.PREF_SEARCH_QUERY,null);
String lastRequestId = prefs.getString(FlickrFetchr.PREF_LAST_RESULT_ID,null);

ArrayList<GalleryItem> items;
if(query != null ){
items = new FlickrFetchr().search(query); // 加载所有（其实就是第一页）
}else{
items = new FlickrFetchr().fetchItems(); // 根据关键字加载
}

if(items.size() == 0) return;  

String resultId = items.get(0).getId(); // 取查询结果中的第一条记录的ID，用于判断是否有新的查询结果

if(!resultId.equals(lastResultId)){
		// 得到一个新的查询结果，发出通知
Resources r = getResources();
PendingIntent pi = PendingIntent.getActivity(
this,
0,
new Intent(this,PhotoGalleryActivity.class),
0);
Notification notification = new NotificationCompat.Builder(this)
.setTicker(r.getString(R.string.new_pictures_title))
.setSmallIcon(android.R.drawable.ic_menu_report_image)
.setContentTitle(r.getString(R.string.new_pictures_title))
.setContentText(r.getString(R.string.new_pictures_text))
.setContentIntent(pi)
.setAutoCancel(true)
.build();
NotificationManager notificationManager = 
(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
notificationManager.notify(0,notification); // 第一个整数参数是一个消息ID，整个应用中国值应该是唯一的。如果使用同一个ID发送两条消息，则第二条消息会替换掉第一条消息（进度条及其他动态视觉效果的实现方式）
}
else{
// 得到一个旧的查询结果
}

prefs.edit().putString(FlickrFetchr.PREF_LAST_RESULT_ID,resultId).commit();
}

// 实现延迟运行服务的方法
public static void setServiceAlarm(Context context,boolean isOn){
Intent i = new Intent(context,PollService.class);
PendingIntent pi = PendingIntent.getService(context,0,i,0); // 如果使用同一个intent请求PendingIntent两次，得到的PendingIntent仍会是同一个，可以借此测试一个PendingIntent是否已存在，或撤销已发出的PendingIntent

AlarmManager alarmManager = 
(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
if(isOn){
alarmManager.setRepeating(  // 设置定时器
AlarmManager.RTC, // 硬件闹钟，不唤醒设备休眠，即当设备休眠时不发射闹钟
System.currentTimeMillis(),
POLL_INTERVAL,
pi
);
}else{ // 取消定时器
alarmManager.cancel(pi);
pi.cancel();
}
}

// 如果使用同一个intent请求PendingIntent两次，得到的PendingIntent仍会是同一个
public static boolean isServiceAlarmOn(Context context){
Intent i = new Intent(context,PollService.class);
// 一个PendingIntent只能登记一个定时器
PendingIntent pi = PendingIntent.getService(
context,
0,
i,
PendingIntent.FLAG_NO_CREATE)
);
return pi!=null;
}
}
```

在AndroidManifest.xml中声明Service：
	<manifest
<application ... 
<activity ... 
</activity
<service android:name=”.PollService” />

根据服务的启动状态更新选项菜单的状态：
在3.0以前的版本上，除了菜单的首次创建外，每次菜单需要配置都会调用onPrepareOptionMenu()方法，因此可以用来更新选项菜单的内容。在3.0以后的版本中，操作栏无法自动更新自己，需要通过调用Activity.invalidateOptionMenu()方法来回调onPrepareOptionMenu()方法，并刷新菜单项。
```java
public class PhotoGalleryFragment extends Fragment{
...
@Override
public void onPrepareOptionMenu(Menu menu){
super.onPrepareOptionsMenu(menu);
MenuItem toggleItem = menu.findItem(R.id.menu_item_toggle_polling);
if(PollService.isSeviceAlarmOn(getActivity()){
toggleItem.setTitle(R.string.stop_polling);
}
else{
toggleItem.setTitle(R.string.start_polling);
}
}

@Override
@TargetApi(11)
public boolean onOptionsItemSelected(MenuItem item){
switch(item.getItemId()){
...
case R.id.menu_item_toggle_polling:
// 切换服务启动状态
boolean shouldStartAlarm = !PollService.isServiceAlarmOn(getActivity());
PollService.setServiceAlarm(getActivity(),shouldStartAlarm);

// 刷新菜单
if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB)
getActivity().invalidateOptionsMenu(); // 回调onPrepareOptionMenu()方法
return true;
default:
return super.onOptionItemSelected(item);
}
}
}
```