---
layout: post
title:  "面试题整理：PHP"
date: 2017-04-05 00:00:01
categories: 面试题
tags: PHP
excerpt: ""
---

# __autoload和spl_autoload_register()函数直接有什么区别和联系？
```php
void __autoload(string $class)
```
可以通过定义这个函数来启用类的自动加载，参数为待加载的类名。

例如：
./myClass.php
```php
<?php
class myClass {
  public function __construct() {
    echo "myClass init'ed successfuly!!!";
  }
}
?>
```

./index.php
```php
<?php
function __autoload($classname) {
    $filename = "./". $classname .".php";			# 拼凑查找类文件的逻辑
    include_once($filename);
}

$obj = new myClass();							# 直接使用类名，会触发对__autoload函数的调用
?>
```

```php
bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )
```
将函数注册到SPL __autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。
如果在程序中已经实现了__autoload()函数，它必须显式注册到__autoload()队列中。因为 spl_autoload_register()函数会将Zend Engine中的__autoload()函数取代为spl_autoload()或spl_autoload_call()。

spl_autoload_register 可以很好地处理需要`多个加载器`的情况，这种情况下spl_autoload_register会`按顺序依次调用`之前注册过的加载器。作为对比， __autoload 因为是一个函数，所以只能被定义一次。

例如：
```php
function loadprint( $class ) {
 	$file = $class . '.class.php';  
 	if (is_file($file)) {  
  		require_once($file);  
 	} 
} 

spl_autoload_register( 'loadprint' ); 

$obj = new PRINTIT();
$obj->doPrint();
```
将__autoload换成loadprint函数。但是loadprint不会像__autoload自动触发，这时spl_autoload_register()就起作用了，它告诉PHP碰到没有定义的类就执行loadprint()。 

例：spl_autoload_register() 调用静态方法 
```php
class test {
 	public static function loadprint( $class ) {
  		$file = $class . '.class.php';  
  		if (is_file($file)) {  
   			require_once($file);  
  		} 
 	}
} 

spl_autoload_register(array('test','loadprint'));
// 另一种写法：spl_autoload_register("test::loadprint"); 

$obj = new PRINTIT();
$obj->doPrint();
```

# CGI、FastCGI的理解和区别

CGI：CGI叫“公共网关接口”(Common Gateway Interface), CGI描述了客户端和服务器程序之间传输数据的一种标准,就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。总之，`CGI是一种标准，一种协议`。

CGI程序：CGI程序确保CGI协议的顺利执行，并且返回结果，用来沟通程序(如PHP, Python, Java)和Web服务器(Apache2, Nginx), 充当桥梁的作用。即CGI程序是介于Web服务器与Web程序之间的，用来保证CGI协议的程序。如php-fpm。

web server（比如说nginx）只是内容的分发者。比如，如果客户端(比如浏览器)请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，那它就要找到相应的CGI程序来处理了，根据配置，找到了php-cgi这个程序（也就是PHP解析器）,那么他会把这个请求交个php-cgi（PHP解析器）。`nginx会启动CGI程序,然后会根据CGI协议，把需要的数据传给全部丢给php-cgi`，比如请求的url，查询字符串，POST数据，HTTP header等等。php-cgi(PHP解析器)会解析php.ini文件，初始化执行环境，然后找到index.php，编译，执行,把执行结果返回给客户端。
CGI执行过程的特点是：每次请求过来，再启动CGI程序，去处理请求。所以就会造成，如果50个请求过来，就得启动50个CGI程序的进程来处理，处理完之后，就销毁相应的线程。
但是启动一个进程，肯定是需要时间的，这样大量的启动、销毁，造成了大量的浪费。

FastCGI会启动FastCGI进程管理器（简称`master`），解析配置文件，初始化执行环境，master再启动多个CGI程序(简称`worker`)在那里等候。master的职责是：请求过来，把请求传递给到空闲的worker,然后立即可以接受下一个请求，再传递。worker的职责是：每个worker都一直在等候，接到从master传递过来的请求之后，立即执行并返回，但是执行完毕后，不销毁，而且继续等待下个请求。当然，master还时时刻刻监控着worker的情况，如果worker不够了，master会启动多几个，如果空闲的太多了，停掉一些。这样一种方法，`比起老的CGI执行，省去了大量的启动、销毁线程的时间和节约了大量的资源`。

修改php.ini后，FastCgi可以平滑的重启,执行php-fpm reload。php-cgi进程是没办法平滑重启的，需要restart。

CGI 的工作方式，从 Web 服务器的角度看，是在特定的位置（位置指url，比如：http://www.example.com/wiki.cgi）定义了可以运行的CGI 程序（比如一个脚本，但也可能不是脚本，比如用C实现CGI）。当收到一个匹配URL的请求，相应的程序就会被调用（如果是脚本，则应该调用脚本解释器进行解释），并将客户端发送的数据作为输入。程序的输出会由 Web 服务器收集，并加上合适的档头，再发送回客户端。
一般每次的 CGI 请求都需要新生成一个程序的副本来运行，这样大的工作量会很快将服务器压垮，因此一些更有效的技术可以让脚本解释器直接作为模块集成在 Web 服务器（例如：Apache，mod_php）中，这样就能避免重复载入和初始化解释器。不过这只是就那些需要解释器的高级语言（即解释语言）而言的，使用诸如C一类的编译语言则可以避免这种额外负荷。由于 C 及其他编译语言的程序与解释语言程序相比，前者的运行速度更快、对操作系统的负荷更小，使用编译语言程序是可能达到更高执行效率的，然而因为开发效率等原因，在目前解释性语言还是最合适的。
与为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。这些进程由FastCGI服务器管理，而不是web服务器。 当进来一个请求时，web服务器把环境变量和这个页面请求通过一个socket比如FastCGI进程与web服务器(都位于本地）或者一个TCP connection（FastCGI进程在远端的server farm）传递给FastCGI进程。Apache通过mod_fcgid以及较早的第三方mod_fastcgi模块来实现。 

# Cookies与Session

Cookie与Session都属于会话跟踪技术。理论上，一个用户的所有请求操作都应该属于同一个会话。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭（HTTP基于TCP），再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。
在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。目前Cookie已经成为标准，所有的主流浏览器都支持Cookie（需要浏览器的支持：保存、更新、发送、删除。不同的浏览器保存Cookie的方式不同）。
查看网站Cookie的简单方式：直接在浏览器地址栏中输入`javascript:alert(document.cookie)`
Session的使用比Cookie方便，但是过多的Session存储在服务器内存中，会对服务器造成压力。

Cookie具有`不可跨域名性`（这里指全域名，而不是仅仅指根域名）。同一个一级域名下的两个二级域名如www.demo.com和images.demo.com也不能交互使用Cookie，因为二者的域名并不严格相同。如果想所有demo.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数为“`.demo.com`”（以.开头），这样所有以“demo.com”结尾的域名都可以访问该Cookie。
Cookie中使用Unicode字符时需要对Unicode字符进行编码（`Cookie中保存中文只能编码`，推荐使用UTF-8，因为`JavaScript不支持GBK编码`）。
由于浏览器每次请求服务器都会携带Cookie，因此Cookie内容不宜过多，否则影响速度。Cookie的内容应该少而精。

maxAge为负数的Cookie，为`临时性Cookie`，不会被持久化，不会被写到Cookie文件中。Cookie信息保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。Cookie默认的maxAge值为-1。
要想修改Cookie只能使用一个同名的Cookie来覆盖原来的Cookie，达到修改的目的。删除时只需要把maxAge修改为0即可（Cookie并不提供直接的修改、删除操作）。修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。
从客户端读取Cookie时，包括maxAge在内的其他属性都是不可读的，也不会被提交。浏览器提交Cookie时只会提交name与value属性。maxAge属性只被浏览器用来判断Cookie是否过期。
Cookie的`Expires`属性标识了Cookie的有效时间，当Cookie的有效时间过了之后，这些数据就被自动删除了。默认情况下coolie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户退出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。`expires属性现在已经被max-age属性所取代`，max-age用秒来设置cookie的生存期。
`path属性`决定允许访问Cookie的路径。页面只能获取它属于的Path的Cookie。例如/session/test/a.jsp不能获取到路径为/session/abc/的Cookie。

如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的`secure属性`为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。
W3C标准的浏览器会阻止JavaScript读写任何不属于自己网站的Cookie。

Session在用户第一次访问服务器的时候`自动创建`。Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。
虽然Session保存在服务器，对客户端是透明的，`它的正常运行仍然需要客户端浏览器的支持`（如果使用Cookie来发送SessionID的话）。这是因为Session需要使用Cookie作为识别标志。如果浏览器不支持Cookie，则需要依赖URL重写。
`URL地址重写`是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。

# foreach循环中使用引用有什么潜在问题？

```php
$array = [1, 2, 3]; 
echo implode(',', $array), "<br/>"; 	// 1,2,3

foreach ($array as &$value) {}    
echo implode(',', $array), "<br/>"; 	// 1,2,3	

foreach ($array as $value) {}     	 
echo implode(',', $array), "<br/>";		// 1,2,2
```

第一个循环过后，$value是数组中最后一个元素的引用。
第二个循环开始：
第1步：复制$arr[0]到$value（注意此时$value是$arr[2]的引用），这时数组变成[1,2,1]
第2步：复制$arr[1]到$value，这时数组变成[1,2,2]
第3步：复制$arr[2]到$value，这时数组变成[1,2,2]
综上，最终结果就是1,2,2
避免这种错误最好的办法就是在循环后立即用unset函数销毁变量：
```php
$arr = array(1, 2, 3, 4); 
foreach ($arr as &$value) { 
    $value = $value * 2; 
} 
unset($value);
```

# mysqli的Prepared语句有什么好处？

mysqli支持prepared语句，好处有2：
1）对于在执行大量具有不同数据的相同查询时，可以提高执行速度；
2）可以免受SQL注入攻击；
通常的数据库插入操作如下：

```php
$query = “insert into books values(‘”.$isbn.”’,’”.$author.”’,’”.$title.”’,’”.$price.”’)”;
$result = $db->query($query);
if($result){
echo $db->affected_rows;
...
```
Prepared语句的基本思想是向MySql发送一个需要执行的查询模板，然后再单独发送数据。因此可以向相同的Prepared语句发送大量相同的数据，对于批处理的插入操作来说是非常有用的。
```php
$query = “insert into books values(?,?,?,?)”;
$stmt = $db->prepare($query);
$stmt->bind_param(“sssd”,$isbn,$author,$title,$price); //sssd为格式化字符串
$stmt->execute();
echo $smtt->affected_rows;
$stmt->close();
```
对于查询操作，也可以绑定查询结果至变量：
$stmt->bind_result($isbn,$author,$title,$price);

# PHP中有哪几种表达字符串的方式？区别是什么？

一个字符串可以用4种方式表达： 
1）单引号  
2）双引号  
3）heredoc 语法结构  
4）nowdoc 语法结构（自 PHP 5.3.0 起） 
不像双引号和heredoc语法结构，在单引号字符串中的变量和特殊字符的转义序列将不会被替换。
要注意的是heredoc结束标识符这行除了可能有一个分号（;）外，绝对不能包含其它字符。这意味着标识符不能缩进，分号的前后也不能有任何空白或制表符。
就象 heredoc 结构类似于双引号字符串，nowdoc 结构是类似于单引号字符串的。nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作。
字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1。

# PHP中的闭包无须像js一样通过self=this的形式来扩展作用域

```php
class Demo{
  private $list = [1,2,3,4,5,6,7,8,9,10];
  public $delList = [];
  
  public function test(){
    $arr = array_filter($this->list,function($n){
      if($n % 2 == 0){
        return true;
      }
      else{
        $this->delList[] = $n;
        return false;
      }
    });
    
    return $arr;
  }
}

$demo = new Demo();
$arr = $demo->test();
var_dump($arr);   // 1 3 5 7 9
var_dump($demo->delList); // 2 4 6 8 10
```

# PHP中那些函数是同步阻塞的

同步阻塞函数

mysql、mysqli、pdo以及其他DB操作函数
sleep、usleep
curl
stream、socket扩展的函数
swoole_client同步模式
memcache、redis扩展函数
file_get_contents/fread等文件读取函数
swoole_server->taskwait
swoole_server->sendwait
swoole_server的PHP代码中有上述函数，Server就是同步服务器
代码中没有上述函数就是异步服务器
异步非阻塞函数

swoole_client异步模式
mysql-async库
redis-async库
swoole_timer_tick/swoole_timer_after
swoole_event系列函数
swoole_table/swoole_atomic/swoole_buffer
swoole_server->task/finish函数

# PHP对象注入漏洞的原因是什么？

PHP支持`对象的序列化和反序列化`操作（serialize、unserialize）。
如：

```php
class User{

  public $age = 0;
  public $name = '';

  public function PrintData(){
    echo 'User ' . $this->name . ' is ' . $this->age . ' years old. <br />';
  }
}

$usr = unserialize('O:4:"User":2:{s:3:"age";i:20;s:4:"name";s:4:"John";}');
$usr->PrintData();
```

输出：
User John is 20 years old. 

`当一个对象进行序列化和反序列化操作时也会自动调用其他相应的魔幻方法`：
当对象进行序列化操作时魔幻方法“__sleep”会被自动调用。（必须返回一个包含序列化的类变量名的数组）
当对象进行反序列化操作时魔幻方法“__wakeup”会被自动调用。
反序列化操作自动调用__wakeup和__destruct，攻击者可以操作类变量来攻击web应用，比如：
$usr = unserialize('O:7:"LogFile":1:{s:8:"filename";s:9:".htaccess";}');
$usr->PrintData();
从而`意外地执行了`LogFile的__construct和__destruct。
在处理由用户提供数据的地方不要使用“unserialize”，可以使用“json_decode”。

# PHP支持哪些数据类型？

PHP共支持`8种原始数据类型`，其中包括：
4种标量类型：boolean、integer、float（double）、string
2种复合类型：array、object
2种特殊类型：resource、NULL
`double 和 float 是相同的`，由于一些历史的原因，这两个名称同时存在。
变量的类型通常不是由程序员设定的，确切地说，是由PHP根据该变量使用的上下文在运行时决定的。 

# PHP的变量作用域规则是什么样的？

6项基本的作用域规则：
1）`超级全局变量`（内置）可以在脚本的任何地方使用和可见。
2）`常量`一旦被声明，将全局可见，即可以在函数内外使用。
3）在一个`脚本中声明的全局变量`在整个脚本中是可见的。
4）函数内部使用的变量声明为全局变量时，其名称要与全局变量一致。
5）在函数内部创建的`静态变量`，在函数外部不可见，但是可以在函数的多次执行中保持值。
6）在函数内部创建的非静态变量，当函数终止时就不存在了。

# PHP的启动与终止

无论是web模式还是cli模式运行，PHP的工作原理都是一样的， 都是作为一种SAPI在运行（Server Application Programming Interface： the API used by PHP to interface with Web Servers）。`SAPI就是PHP和外部环境的代理器`。它把外部环境抽象后, 为内部的PHP提供一套固定的，统一的接口，使得PHP自身实现能够不受错综复杂的外部环境影响，保持一定的独立性。

PHP程序的启动可以看作有两个概念上的启动，终止也有两个概念上的终止。 以Apache举例，其中一个是`PHP作为Apache的一个模块的启动与终止`， 这次启动php会初始化一些必要数据，比如与宿主Apache有关的，并且这些数据是常驻内存的！ 终止与之相对。 还有一个概念上的启动就是当Apache分配一个页面请求过来的时候，PHP会有一次启动与终止，这也是我们最常讨论的一种。

在PHP随着Apache的启动而常驻在内存里时， 会把自己所有已加载扩展的`MINIT方法`(全称Module Initialization，是由每个模块自己定义的函数)都执行一遍。 在这个时间里，扩展可以定义一些自己的常量、类、资源等所有会被用户端的PHP脚本用到的东西。 

当一个页面请求到来时候，PHP会迅速的开辟一个新的环境，并重新扫描自己的各个扩展， 遍历执行它们各自的`RINIT方法`(俗称Request Initialization)， 这时候一个扩展可能会初始化在本次请求中会使用到的变量等， 还会初始化稍后用户端（即PHP脚本）中的变量之类的。

当请求完成（或者别die等终结），PHP便会启动回收程序，执行所有已加载扩展的`RSHUTDOWN`（Request Shutdown）方法， 这时候扩展可以抓紧利用内核中的变量表之类的做一些事情， 因为一旦PHP把所有扩展的RSHUTDOWN方法执行完， 便会释放掉这次请求使用过的所有东西， 包括变量表的所有变量、所有在这次请求中申请的内存等等。

当Apache通知PHP自己要Stop的时候，PHP便进入`MSHUTDOWN`（Module Shutdown）阶段。一旦PHP把扩展的MSHUTDOWN执行完，便会进入自毁程序，所以这里一定要把自己擅自申请的内存给释放掉。

一个最简单的例子：

walu.c 
```c
 int time_of_minit;  // 每次请求都不变
 PHP_MINIT_FUNCTION(walu)
 {
     time_of_minit=time(NULL);
     return SUCCESS;
 }

 int time_of_rinit;  // 每次请求都改变
 PHP_RINIT_FUNCTION(walu)
 {
     time_of_rinit=time(NULL);
     return SUCCESS;
 }

 // 每次页面请求都会往time_rshutdown.txt中写入数据
 PHP_RSHUTDOWN_FUNCTION(walu)
 {
     FILE *fp=fopen("/cnan/www/erzha/time_rshutdown.txt","a+");
     fprintf(fp,"%d\n",time(NULL));
     fclose(fp);
     return SUCCESS;
 }

 // 只有在apache结束后time_mshutdown.txt才写入有数据
 PHP_MSHUTDOWN_FUNCTION(walu)
 {
     FILE *fp=fopen("/cnan/www/erzha/time_mshutdown.txt","a+");
     fprintf(fp,"%d\n",time(NULL));
     return SUCCESS;
 }

 PHP_FUNCTION(walu_test)
 {
     php_printf("%d&lt;br /&gt;",time_of_minit);
     php_printf("%d&lt;br /&gt;",time_of_rinit);
     return;
 }
```

# PHP的生命周期

两种init和两种shutdown各会执行多少次、各自的执行频率有多少取决于PHP是用什么sapi与宿主通信的。最常见的四种sapi通信方式如下：

 1.直接以CLI/CGI模式调用

 PHP的生命周期完全在一个单独的请求中完成，两种init和两种shutdown仍然都会被执行。

 以`$php -f test.php`为例，执行过程如下：

 （1）调用每个扩展的MINIT；

 （2）请求test.php文件；

 （3）调用每个扩展的RINIT；

 （4）执行test.php；

 （5）调用每个扩展的RSHUTDOWN；

 （6）执行清理操作；

 （7）调用每个扩展的MSHUTDOWN；

 （8）终止php；

 2.多进程模块

 如编译成Apache2的Pre-fork MPM，当Apache启动的时候，会立即把自己fork出好几个子进程，每一个进程都有自己独立的内存空间，在每个进程里的PHP的工作方式如下：

 （1）调用每个扩展的MINIT；

 （2）循环：a.调用每个扩展的RINIT; b.执行脚本；c.调用每个扩展的RSHUTDOWN；

 （3）调用每个扩展的MSHUTDOWN；

 3.多线程模

 如IIS的isapi和Apache MPM worker，只有一个服务器进程在运行着，但会同时运行很多线程，这样可以减少一些资源开销， 像Module init和Module shutdown就只需要运行一次就行了，一些全局变量也只需要初始化一次， 因为线程独具的特质，使得各个请求之间方便的共享一些数据成为可能。

 4.Embedded(嵌入式，在自己的C程序中调用Zend Engine)

 Embed SAPI是一种比较特殊但不常用的sapi，允许在C/C++语言中调用PHP/ZE提供的函数。 这种sapi和上面的三种一样，按Module Init、Request Init、Rshutdown、mshutdown的流程执行着。

# PHP配置中的open_basedir配置项的作用是什么？

open_basedir是PHP配置中为了`防御跨目录进行文件（目录）读写`的配置，所有PHP中有关文件读、写的函数都会经过open_basedir的检查。实际上是一些目录的集合，在定义了open_basedir以后，`php可以读写的文件、目录都将被限制在这些目录中`。在linux下，不同的目录由“:”分割，如“/var/www/:/tmp/”。
注意用open_basedir指定的限制实际上是前缀,而不是目录名。

Apache+PHP配置方法有三种：
方法一：在php.ini里配置
open_basedir = .:/tmp/
方法二：在Apache配置的VirtualHost里设置(httpd-vhosts.conf)
php_admin_value open_basedir .:/tmp/
方法三：在Apache配置的Direcotry里设置
php_admin_value open_basedir .:/tmp/
关于三个配置方法的解释：
a、方法二的优先级高于方法一，也就是说方法二会覆盖方法一；方法三的优先级高于方法二，也就是说方法三会覆盖方法二；
b、配置目录里加了“/tmp/”是因为php默认的临时文件（如上传的文件、session等）会放在该目录，所以一般需要添加该目录，否则部分功能将无法使用；
c、配置目录里加了“.”是指运行php文件的当前目录，这样做可以避免每个站点一个一个设置；
d、如果站点还使用了站点目录外的文件，需要单独在对应VirtualHost设置该目录；

# SplQueue实现队列

异步并发的服务器里经常使用队列实现生产者消费者模型，解决并发排队问题。PHP的SPL标准库中提供了SplQueue扩展内置的队列数据结构。另外PHP的数组也提供了array_pop和array_shift可以使用数组模拟队列数据结构。
虽然使用Array可以实现队列，但实际上性能会非常差。在一个大并发的服务器程序上，建议使用SplQueue作为队列数据结构。

100万条数据随机入队、出队，使用SplQueue仅用2312.345ms即可完成，而使用Array模拟的队列的程序根本无法完成测试，CPU一直持续在100%，降低到1万条后，也需要260ms才能完成测试。

SplQueue
```php
$splq = new SplQueue;
for($i = 0; $i < 1000000; $i++){
  $data = "hello $i\n";
  $splq->push($data);

  if ($i % 100 == 99 and count($splq) > 100){
    $popN = rand(10, 99);
    for ($j = 0; $j < $popN; $j++){
      $splq->shift();
    }
  }
}

$popN = count($splq);
for ($j = 0; $j < $popN; $j++){
  $splq->pop();
}
```

Array队列
```php
$arrq = array();
for($i = 0; $i <1000000; $i++){
  $data = "hello $i\n";
  $arrq[] = $data;
  if ($i % 100 == 99 and count($arrq) > 100){
    $popN = rand(10, 99);
    for ($j = 0; $j < $popN; $j++){
      array_shift($arrq);
    }
  }
}
$popN = count($arrq);
for ($j = 0; $j < $popN; $j++){
  array_shift($arrq);
}
```

# swoole如何处理高并发

Reactor模型：IO多路复用异步非阻塞程序使用经典的Reactor模型，它本身不处理任何数据收发，只是可以监视一个socket(也可以是管道、eventfd、信号)句柄的事件变化比如：

1.Add:添加一个Socket到Reactor；

2.Set:修改Socket对应的事件，如可读可写；

3.Del：从Reactor中移除；

4.Callback：事件发生后，回调的函数；

Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。



swoole采用`多线程Reactor+多进程Worker`：

1.Master进程启动一个Main Reactor线程和多个普通Reactor线程；

2.请求到达 Main Reactor；

3.Main Reactor根据Reactor的情况，将请求注册给对应的Reactor(每个Reactor都有epoll。用来监听客户端的变化)

4.客户端有变化时，交给worker来处理；

5.worker处理完毕，通过进程间通信(比如管道、共享内存、消息队列)发给对应的reactor。

6.reactor将响应结果发给相应的连接。

7.请求处理完成；

因为reactor基于epoll，所以每个reactor可以处理无数个连接请求。 如此，swoole就轻松的处理了高并发。



swoole的worker进程有2种类型：
**一种是 普通的worker进程，一种是 task worker进程。**worker进程是用来处理普通的耗时不是太长的请求；task worker进程用来处理耗时较长的请求，比如数据库的I/O操作。以异步Mysql举例：

1.耗时较长的Mysql查询进入worker；
2.worker通过管道将这个请求交给task worker来处理；
3.worker再去处理其他请求；
4.task worker处理完毕后，处理结果通过管道返回给worker；
5.worker 将结果返回给reactor；
6.reactor将结果返回给请求方；

如此，通过worker、task worker结合的方式，我们就实现了异步I/O。

# Swoole工作原理与优势

swoole的出现使phper可以从web开发跳出，进入了更大的服务器网络编程领域。

swoole运行有个前提条件：必需在cli模式下执行。

cli下执行一个php文件时的关键步骤：

1.调用每个扩展的MINIT；

2.调用每个扩展的RINIT；

3.执行test.php；

4.调用每个扩展的RSHUTDOWN；

5.调用每个扩展的MSHUTDOWN；

fpm每个请求都是在执行2~4步。opcode cache是把第3步的词法分析、语法分析、生成opcode代码这几个操作给缓存起来了，从而达到加速的作用。

Swoole在第3步接管了php，进入swoole的生命周期，以多进程模式为例：

（1）.onStart

在回调此函数之前Swoole Server已进行了如下操作

- 创建了manager进程
- 创建了worker子进程
- 监听所有TCP/UDP端口
- 监听了定时器

`此函数是在主进程回调的`，和worker进程的onWorkStart是并行的没有先后之分，在此回调里强烈要求只做log记录，设置进程名操作，不做业务逻辑,否则业务逻辑代码的错误导致master进程crash,让整个swoole server不对对外提供服务了。

（2）.onWorkStart

每个worker或task进程在启动之后，会回调此函数，由于此回调类似于fpm里的MINIT，所以可以在这里做一个全局的资源加载，框架初始化之类的操作，这样可以对每个请求做全局共享，而达到提升性能的目的。

（3）.onReceive

每个请求（也称数据到达），会回调此函数，然后进行业务逻辑处理，输出结果

（4）.onWorkerStop

worker退出时，会回调此函数。

（5）.onShutDown

swoole服务停止回调此函数,然后继续fpm的第4、5步，进而退出php生命周期。



Apache处理一个请求是**同步阻塞**的模式：每到达一个请求，Apache都会去fork一个子进程去处理这个请求，直到这个请求处理完毕。

epoll代理的原理是这样的：当连接有I/O流事件产生的时候，epoll就会去告诉进程哪个连接有I/O流事件产生，然后进程就去处理这个进程。

有了epoll，理论上1个进程就可以无限数量的连接，而且无需轮询，真正解决了c10k的问题。Nginx是基于epoll的，异步非阻塞的服务器程序。自然，Nginx能够轻松处理百万级的并发连接，也就无可厚非了。

# 为什么PHP不做编译优化？

C程序通常一次编译，多次运行或长时间运行，因此在编译上多耗些时间、多做些优化被认为是值得的。而解释型语言往往作为胶水语言，也就是`完成一项用后即弃的特定任务`。在PHP内核开发邮件列表里，一个月经贴是为什么PHP不做编译优化。官方的答复是，PHP程序运行时间往往很短暂，比如10ms；如果花100ms做编译优化，把运行时间压缩到1ms，总的时间消耗是101ms，反而更慢了（不考虑中间代码缓存）。

# 为什么在被包含文件中仍然要使用PHP起始标志？

当一个文件被包含时，语法解析器`在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复`。由于此原因，目标文件中需要作为PHP代码执行的任何代码都必须被包括在有效的PHP起始和结束标记之中。

# 为什么要关闭register_globals配置？

register_globals是php.ini里的一个配置，这个配置影响到php如何接收传递过来的参数。
register_globals的意思就是注册为全局变量，所以当On的时候，`传递过来的值会被直接的注册为（与控件的name属性同名的）全局变量直接使用`，而Off的时候，我们需要到特定的数组里去得到它。

# 什么是协程？

协程，又称微线程，纤程。英文名Coroutine。
子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。
所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而`协程的调用和子程序不同`。
协程看上去也是子程序，但执行过程中，`在子程序内部可中断`，然后转而执行别的子程序（是`中断后执行，而不是函数调用其他的子程序`），在适当的时候再返回来接着执行。
协程的特点在于是一个线程执行（所以不是多线程）。优势就是极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，`没有线程切换的开销`，和多线程比，线程数量越多，协程的性能优势就越明显。另一个优势就是`不需要多线程的锁机制`，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

缺点：
无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决

# 什么样的变量会被认为是NULL？如何判断？

特殊的NULL值表示一个变量没有值。`NULL类型唯一可能的值就是NULL`（不区分大小写）。在下列情况下一个变量被认为是 NULL： 
1）被赋值为 NULL。 
2）尚未被赋值。 
3）被unset()。 
判断是否为NULL：`is_null()`
递减NULL值也没有效果，但是递增NULL的结果是 1。

# 使用Swoole执行php与普通方式的不同之处

使用swoole拓展的PHP脚本与传统的PHP脚步不同，前者是需要预先在服务端执行的，而后者是每次访问时才会执行。

比如你的程序中定义了一个类A，那么在每次有用户访问时，类A都需要提前编译到内存中，1万次访问就要编译1万次。而用swoole拓展则只需要在服务端编译一次，无论多少次访问都不需要再次编译了，只要swoole的进程存在，类A就会一直存在于内存中。

因此，使用swoole来编写常规项目时，需要将自己置身于第三方上帝的角色，而非访问者的角色来编写并阅读自己的代码。
比如：PHP入门时就必须要掌握的session，对于运用了swoole扩展的PHP程序而言，完全可以用一个变量来替换。
再比如：平时写PHP代码，完全不必担心内存使用，全局变量/函数/对象等，可以随便使用，因为PHP脚本执行结束后，内存自然会自行释放掉。但用swoole扩展的PHP程序，则必然要手动注销全局的变量/函数/对象等

php在fork子进程的时候，父进程的资源连接会被子进程获得，父进程本身会断掉。要解决这个问题只能在fork之后重新建连接。

`一定不可以多进程或多线程共同一个mysql或redis连接，否则消息会串`。每个进程或线程创建一个mysql的连接。连接断掉也就是mysql gone away之后进行重连。子进程退出后php引擎回清理回收所有的内存，关闭所有的连接。然后由于子进程和父进程共享内存，所以父进程里建立的连接等等也会被顺带关闭掉。

fpm本身是leader follower同步阻塞模型，同一时间只能处理一个请求，支持不了异步。

# 使用swoole时出现mysql-server-gone-away的原因

使用swoole时出现mysql-server-gone-away的原因
`mysql本身是一个多线程的程序`，每个连接过来，会开一个线程去处理相关的query, mysql会定期回收长时间没有任何query的连接(时间周期受wait_timeout配置影响)，所以在swoole中，由于是一个长驻内存的服务，我们建立了一个mysql的连接，不主动关闭 或者是用pconnect的方式，那么这个mysql连接会一直保存着，然后长时间没有和数据库有交互，就主动被mysql server关闭了，之后继续用这个连接，就报mysql server gone away了。

解决方法：
1.修改mysql的`wait_timeout`值为一个非常大的值，此方法不太可取，可能会产生大量的sleep连接，导致mysql连接上限了， 建议不使用。

2.每次query之前主动进行连接检测
//如果是用mysqli，可用内置的mysqli_ping
```php
if (!$mysqli->ping()) {  
	mysqli->connect(); //重连
}
```

//如果是pdo，可以检测mysql server的服务器信息来判断
```php
 try {
	$pdo->getAttribute(\PDO::ATTR_SERVER_INFO);
} catch (\Exception $e) {
	if ($e->getCode() == 'HY000') {
		$pdo = new PDO(xxx);  //重连
	} else {
		throw $e;
	}
}
```
这个方案有个缺点：额外多一次请求，所以改进方法: 用一个全局变量存放最后一次query的时间，下一次query的时候先和现在时间对比一下，超过waite_timeout再重连. 或者也可以用swoole_tick定时检测。

3.被动检测，每次query用try catch包起来，如有mysql gone away异常，则重新连接，再执行一次当前sql.
```php
try {
	query($sql);
} catch (\Exception $e) {
	if ($e->getCode() == 'HY000') {
		reconnect(); //重连
		query($sql)
	} else {
		throw $e;
	}
}
```

4.用`短连接`，务必每次操作完之后，手动close

# 哪些变量不能使用可变变量行为？

在 PHP 的函数和类的方法中，`超全局变量不能用作可变变量`。`$this变量也是一个特殊变量，不能被动态引用`。 

# 在PHP中基于yield实现简单的协程通信（`双向`异步信息传递）

包含yield关键字的函数比较特殊，返回值是一个`Generator对象`，此时函数内语句尚未真正执行。Generator对象是Iterator接口实例，可以通过rewind()、current()、next()、valid()系列接口进行操纵。`Generator可以视为一种“可中断”的函数，而yield构成了一系列的“中断点”`。Generator类似于车间生产的流水线，每次需要用产品的时候才从那里取一个，然后这个流水线就停在那里等待下一次取操作。

```php
<?php

function gen() {
	for($i=1;$i<=100;$i++) {
		$cmd = (yield $i);  // `yield既是语句，又是表达式`，既具备类似return语句的功能，同时也有类似表达式的返回值（通过send得到的值）
		if($cmd=='stop') {
			return;
		}
	}s
}

$gen = gen();
$i=0;
foreach($gen as $item) {
	echo $item."\n";
	if($i>=10) {
		$gen->send('stop');
	}
	$i++;
}
```

# 在PHP中，如何控制数组json_encode后为json对象或者json数组？

```php
$foo = array(
  "item1" => (object)[],
  "item2" => []
);

echo json_encode($foo);
```
输出：
```php
{"item1":{},"item2":[]}
```

# 在方法中使用的$this一定指向该方法所从属的对象吗？

$this是一个到主叫对象的引用（通常是该方法所从属的对象，但`如果是从第二个对象静态调用时也可能是另一个对象`）。

```php
class A{
  function foo(){
    if (isset($this)) {
      echo '$this is defined (';
      echo get_class($this);
      echo ")\n";
    } else {
      echo "\$this is not defined.\n";
    }
  }
}

class B{
  function bar(){
    // Note: the next line will issue a warning if E_STRICT is enabled.
    A::foo();
  }
}

$b = new B();
$b->bar();
```

输出：$this is defined (B)

# 在脚本文件中使用return，有哪些不同的场景和行为？

在脚本文件中使用return语言结构：
  如果在全局范围中调用，则当前脚本文件中止运行。
  如果当前脚本文件是被 include 的或者 require 的，则控制交回调用文件。
此外，如果当前脚本是被 include 的，则 return 的值会被当作 include 调用的返回值。

如果在主脚本文件中调用 return，则脚本中止运行。

如果当前脚本文件是在 php.ini 中的配置选项 auto_prepend_file 或者 auto_append_file 所指定的，则此脚本文件中止运行。 
注意既然 return 是语言结构而不是函数，因此其参数没有必要用括号将其括起来。通常都不用括号，实际上也应该不用，这样可以降低 PHP 的负担。 如果没有提供参数，则一定不能用括号，此时返回 NULL。如果调用 return 时加上了括号却又没有参数会导致解析错误。

# 如何不使用include实现将一个PHP文件“包含”到一个变量中？

用输出控制函数结合 include 来捕获其输出
例：使用`输出缓冲`来将 PHP 文件包含入一个字符串

```php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
  if (is_file($filename)) {
    ob_start();
    include $filename;
    $contents = ob_get_contents();
    ob_end_clean();
    return $contents;
  }
  return false;
}
```

# 如何使用OpCache提高PHP应用的性能？

sudo vim /etc/php.ini
加入：
; 开关打开
opcache.enable=1

; 可用内存, 酌情而定, 单位 megabytes
opcache.memory_consumption=256

; 最大缓存的文件数目, 命中率不到 100% 的话, 可以试着提高这个值
opcache.max_accelerated_files=5000

; Opcache 会在一定时间内去检查文件的修改时间, 这里设置检查的时间周期, 默认为 2, 单位为秒
opcache.revalidate_freq=240

; interned string 的内存大小, 也可调
opcache.interned_strings_buffer=8   

; 是否快速关闭, 打开后在PHP Request Shutdown的时候回收内存的速度会提高
opcache.fast_shutdown=1

; 不保存文件/函数的注释
opcache.save_comments=0

检查：
php -v
    PHP 5.5.3-1ubuntu2.2 (cli) (built: Feb 28 2014 20:06:05) 
    Copyright (c) 1997-2013 The PHP Group
    Zend Engine v2.5.0, Copyright (c) 1998-2013 Zend Technologies
        `with Zend OPcache v7.0.3-dev`, Copyright (c) 1999-2013, by Zend Technologies

需要提醒的是，在生产环境中使用上述配置之前，必须经过严格测试。 因为`上述配置存在一个已知问题，它会引发一些框架和应用的异常， 尤其是在存在文档使用了备注注解的时候`。

重启服务：
sudo /etc/init.d/php-fpm restart
sudo /etc/init.d/nginx restart

如果在更新代码之后，发现没有执行的还是旧代码，可使用函数 opcache_reset() 来清除缓存。

# 如何收集PHP的错误日志？

php在没有连接到数据库或者其他情况下会有提示错误，一般错误信息中会包含php脚本当前的路径信息或者查询的SQL语句等信息，这类信息提供给黑客后，是不安全的，所以服务器建议禁止错误提示。
`display_errors = Off`
在关闭display_errors后为了能够把错误信息记录下来，便于查找服务器运行的原因,同时也要设置错误日志存放的目录，建议跟webserver的日志放在一起。
打开php.ini，安全加固配置方式如下，打开错误日志记录并设置错误日志存放路径：
log_errors = On
error_log = /usr/local/apache2/logs/php_error.log # 该文件必须允许webserver的用户和组具有写的权限

# 如何禁止在PHP中使用危险函数？

Web木马程序通常利用php的特殊函数执行系统命令，查询任意目录文件，增加修改删除文件等。
比如：
<?php eval($_POST[cmd]);?> 
（其实就是使用了一些危险函数使得应用存在漏洞，最好的防范方式就是不允许使用这些函数）
打开php.ini，安全加固配置方式如下，禁止使用这些危险函数：
disable_functions = dl,assert,exec,popen,system,passthru,shell_exec,proc_close,proc_open,pcntl_exec

# 常量和变量有哪些不同？作用域是什么样的？

和super globals一样，`常量的范围是全局的`。不用管作用区域就可以在脚本的任何地方访问常量。

常量只能包含标量数据（boolean、integer、float和string）。可以定义resource常量，但应尽量避免，因为会造成不可预料的结果。

常量和变量有如下不同： 
	1）常量前面没有美元符号（$）；  
	2）常量只能用 `define()` 函数定义，而不能通过赋值语句；  
	3）常量可以不用理会变量的作用域而在任何地方定义和访问；  
	4）常量一旦定义就不能被重新定义或者取消定义；  
	5）常量的值只能是标量。

如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 "CONSTANT"）。
define("CONSTANT", "Hello world.");
echo CONSTANT; // outputs "Hello world."
echo Constant; // 输出 "Constant" 并发出一个提示级别错误信息
如果只想检查是否定义了某常量，用 `defined()` 函数。 

使用关键字 const 定义常量
// 以下代码在 PHP 5.3.0 后可以正常工作
const CONSTANT = 'Hello World';
echo CONSTANT;
和使用define()来定义常量相反的是，`使用const关键字定义常量必须处于最顶端的作用区域`，因为用此方法是在编译时定义的。这就意味着不能在类定义内、函数内、循环内以及if语句之内用const来定义常量。

# 打开allow_url_fopen、allow_url_include配置会有什么问题？有什么替代方案？

允许访问URL远程资源（就是允许fopen这样的函数打开url）使得PHP应用程序的漏洞变得更加容易被利用，php脚本若存在远程文件包含漏洞可以让攻击者直接获取网站权限及上传web木马，一般会在php配置文件中关闭该功能，若需要访问远程服务器建议采用其他方式如libcurl库。
allow_url_fopen = Off
allow_url_include = Off
比如有这样的代码：

```php
 	if (isset($HTTP_GET_VARS)) {
		reset($HTTP_GET_VARS);
		while ( list($var, $val) = each($HTTP_GET_VARS) ) {
			$$var=$val;
		}
	}
```
（一些较偶然的场景会导致将以http://开头的get参数所表示的远程文件直接包含进来，然后执行）

# 有哪些通过PHP在Web服务器上执行命令的方式？

有4种主要的在Web服务器上执行命令的方法：
1）`exec()`函数
没有直接的输出，将返回命令执行结果的最后一行
2）`passthru()`函数
直接将输出显示到浏览器，如果输出是二进制，比如图片，这将是非常有用的。
3）`system()`函数
将命令的输出回显到浏览器，它将每一行的输出向后对齐。
4）反引号
``
更复杂的需求可以使用popen()、proc_open()、proc_close()，这些函数可以启动外部进程，并且在这些进程之间传递数据。

如果要把用户提交的数据包含在命令中，考虑到安全性问题，可以使用`escapeshellcmd`来阻止用户在系统上执行恶意的命令：
system(escapeshellcmd($command));

# 有哪些魔术常量？其行为是什么样的？它们真的是常量吗？

__LINE__ 文件中的当前行号  
__FILE__ 文件的完整路径和文件名
__DIR__ 文件所在的目录 
__FUNCTION__ 函数名称（PHP 4.3.0 新加）
__CLASS__ 类的名称（PHP 4.3.0 新加）  
__TRAIT__ Trait 的名字（PHP 5.4.0 新加）  
__METHOD__ 类的方法名（PHP 5.0.0 新加）
__NAMESPACE__ 当前命名空间的名称（区分大小写）

# 用于属性重载的魔术方法有哪些？

在给不可访问属性赋值时，`__set()` 会被调用。 
读取不可访问属性的值时，`__get()` 会被调用。 
当对不可访问属性调用 isset() 或 empty() 时，`__isset()` 会被调用。 
当对不可访问属性调用 unset() 时，`__unset()` 会被调用。 
属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。

# 用于方法重载的魔术方法有哪些？

在对象中调用一个不可访问方法时，`__call()` 会被调用。 
用静态方式中调用一个不可访问方法时，`__callStatic()` 会被调用。
自动加载不可用于 PHP 的 CLI 交互模式。

# 能否在声明静态变量时使用表达式进行赋值？

静态变量的声明是在编译时解析的，因此`在声明静态变量时不能用表达式进行赋值`：

```php
function foo(){
  static $int = 0;       	// correct
  static $int = 1+2;    	// wrong  (as it is an expression)
  static $int = sqrt(121);  	// wrong  (as it is an expression too)

  $int++;
  echo $int;
}
```

# 能否将非对象类型转换为对象？如果可以，转换得到的对象有哪些属性？

如果将一个对象转换成对象，它将不会有任何变化。
`如果其它任何类型的值被转换成对象，将会创建一个内置类stdClass的实例`。
如果该值为 NULL，则新的实例为空。
数组转换成对象将使键名成为属性名并具有相对应的值。
对于任何其它的值，名为`scalar`的成员变量将包含该值。 
$obj = (object) 'ciao';
echo $obj->scalar;  // outputs 'ciao'

# 被包含文件的搜索顺序是什么样的？

1）先按参数给出的路径寻找
2）如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找
3）如果在include_path下没找到该文件则include最后才在调用脚本文件所在的目录和当前工作目录下寻找
4）如果最后仍未找到文件则include 结构会发出一条警告；这一点和 require 不同，后者会发出一个致命错误。 
5）如果定义了路径——不管是绝对路径还是当前目录的相对路径，include_path 都会被完全忽略。
6）当一个文件被包含时，其中所包含的代码继承了include所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域。 
7）如果 include 出现于调用文件中的一个函数里，则被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样。所以它将遵循该函数的变量范围。此规则的一个例外是魔术常量，它们是在发生包含之前就已被解析器处理的。

