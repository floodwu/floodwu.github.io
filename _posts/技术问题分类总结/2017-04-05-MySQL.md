---
layout: post
title:  "MySQL"
date: 2017-04-05 00:00:04
categories: 技术问题分类总结
tags: MySQL
excerpt: ""
---

* content
{:toc}

## Prepared语句的好处
* 对于在执行大量具有不同数据的相同查询时，可以提高执行速度（MySQL省去了部分语句解析工作）；
* 可以避免SQL注入攻击；
Prepared语句的基本思想是向MySQL发送一个需要执行的查询模板，然后再单独发送数据。因此可以向相同的Prepared语句发送大量相同的数据，对于批处理的插入操作来说是非常有用的。


## mysql server gone away
MySQL本身是一个多线程的程序，每个连接过来，会开一个线程去处理相关的query，MySQL会定期回收长时间没有任何query的连接（时间周期受wait_timeout配置影响），由于Swoole是一个长驻内存的服务，建立了一个MySQL的连接，不主动关闭或者是用pconnect（持久连接）的方式，那么这个MySQL连接会一直保存着，然后长时间没有和数据库有交互，就主动被mysql server关闭了，之后继续用这个连接，就报mysql server gone away了。

**解决方法**
* 修改MySQL的wait_timeout值为一个非常大的值，此方法不太可取，可能会产生大量的sleep连接，导致MySQL连接上限了， 建议不使用；
* 每次query之前主动进行连接检测；
如果是用mysqli，可用内置的mysqli_ping
```php
<?php
if (!$mysqli->ping()) {  
  mysqli->connect(); //重连
}
```

如果是pdo，可以检测mysql server的服务器信息来判断
```php
<?php
try {
  $pdo->getAttribute(\PDO::ATTR_SERVER_INFO);
}catch (\Exception $e) {
  if ($e->getCode() == 'HY000') {
    $pdo = new PDO(xxx);  //重连
  } else {
    throw $e;
  }
}
```
这个方案有个**缺点：额外多一次请求**，所以改进方法: 用一个全局变量存放最后一次query的时间，下一次query的时候先和现在时间对比一下，超过waite_timeout再重连，或者也可以用swoole_tick定时检测。

* 被动检测，每次query用try catch包起来，如有mysql gone away异常，则重新连接，再执行一次当前sql.

```php
<?php
try {
  query($sql);
} catch (\Exception $e) {
  if ($e->getCode() == 'HY000') {
    reconnect(); // 重连
    query($sql)
  } else {
    throw $e;
  }
}
```

* 用`短连接`，务必每次操作完之后，手动close；


## MySQL语句的执行顺序
MySQL的语句执行一共分为11步，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。
* FORM：对FROM的左边的表和右边的表计算笛卡尔积，产生虚表VT1；
* ON：对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中；
* JOIN：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止；
* WHERE：对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中；
* GROUP BY：根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5；
* CUBE|ROLLUP：对表VT5进行cube或者rollup操作，产生表VT6；
* HAVING：对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中；
* SELECT：执行select操作，选择指定的列，插入到虚拟表VT8中；
* DISTINCT：对VT8中的记录进行去重。产生虚拟表VT9；
* ORDER BY：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10；
* LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回；

## SQL_CALC_FOUND_ROWS
在很多分页的程序中都这样写:
```
SELECT COUNT(*) from 'table' WHERE ......;      # 查出符合条件的记录总数
SELECT * FROM 'table' WHERE ...... LIMIT M,N;   # 查询当页要显示的数据
```
这样的语句可以改成:
```
SELECT SQL_CALC_FOUND_ROWS * FROM 'table' WHERE ......  LIMIT M, N;
SELECT FOUND_ROWS();
```
这样只要执行一次较耗时的复杂查询可以同时得到与不带LIMIT同样的记录条数：第二个SELECT返回一个数字，指示了在没有LIMIT子句的情况下，第一个SELECT返回了多少行。


## 两大类触发器
* DML触发器
是基于表而创建的，可以在一张表创建多个DML触发器。其特点是定义在表或者视图上、自动触发、不能被直接调用。用户可以针对INSERT、UPDATE、DELETE语句分别设置触发器，也可以针对一张表上的特定操作设置。触发器可以容纳非常复杂的SQL语句，但不管操作多么复杂，也只能作为一个独立的单元被执行、看作一个事务。如果在执行触发器的过程中发生了错误，则整个事务都会回滚。

* DDL触发器
是一种特殊的触发器，它在响应数据定义语言(DDL)语句时触发。可以用于在数据库中执行管理任务，例如审核以及规范数据库操作。


## 主键与唯一索引的区别
* UNIQUE KEY可空，PRIMARY KEY 不可空不可重复；
* UNIQUE KEY可以在一个表里的一个或多个字段定义（多个UNIQUE KEY可以同时存在），在一个表中只能有一个PRIMARY KEY；
* PRIMARY KEY一般在逻辑设计中**用作记录标识**，这也是设置PRIMARY KEY的本来用意，而UNIQUE KEY只是为了保证域/域组的唯一性。


## InnoDB行级锁
如果是InnoDB引擎，就可以在事务里使用行锁，比如：
```
SELECT xx FROM xx [FORCE INDEX(PRIMARY)] WHERE xx FOR UPDATE 
```
被加锁的行，其他事务也能读取但如果想写的话就必须等待锁的释放（乐观锁）。
<u>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，只有查询能够使用索引时才可以使用行级锁</u>。不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。


## 数据库连接池理解
由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，再加上网络延迟，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略。
连接池仅在超大型应用中才有价值。普通的应用采用MySQL长连接方案，每个php-fpm创建一个MySQL连接，每台机器开启100个php-fpm进程。如果有10台机器，每台机器并发的请求为100。实际上只需要创建1000个MySQL连接就能满足需求，数据库的压力并不大。即使有100台机器，硬件配置好的存储服务器依然可以承受。
达到数百或者数千台应用服务器时，MySQL服务器就需要维持十万级的连接。这时数据库的压力就会非常大了。连接池技术就可以派上用场了，可以大大降低数据库连接数。
基于swoole的AsyncTask模块实现的连接池是完美方案，编程简单，没有数据同步和锁的问题。甚至可以多个服务共享连接池。缺点是灵活性不如多线程连接池，无法动态增减连接，且有一次进程间通信的开销。
node.js/ngx_lua等在多进程的模式下，无法开发出真正的连接池，除非也像swoole_task这样来实现。


## 外联接
LEFT OUTER JOIN或LEFT JOIN \ RIGHT OUTER JOIN或RIGHT JOIN \ FULL OUTER JOIN或FULL JOIN。
左外联接的结果集中除了包括满足条件的行外，还包括**左表所有的行**，左表中没有满足条件的以空值的形式出现。


## 为SELECT语句添加一个自动增加的列
```sql
set @N = 0;
SELECT @N := @N +1 AS number, name, surname FROM gbtags_users;
```

## 分析MySQL语句执行时间和消耗资源
```
SET profiling=1;               # 启动profiles，默认是没开启的
SELECT * FROM customers;       # 执行要分析的SQL语句

SHOW profiles;                 # 查看SQL语句具体执行步骤及耗时
SHOW profile cpu,block io FOR QUERY 41;   # 查看ID为41的查询在各个环节的耗时和资源消耗
```


## 使用EXPLAIN分析MySQL语句的执行情况
```
mysql> explain select * from t_online_group_records where UNIX_TIMESTAMP(gre_updatetime) > 123456789;
+----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table                  | type | possible_keys | key  | key_len | ref  | rows | Extra      |
+----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | t_online_group_records | ALL  | NULL          | NULL | NULL    | NULL |   47 | Using where |
+----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.00 sec)
```
重点关注type，rows和Extra。

**type**
操作的类型，可以用来**判断有无使用到索引**。结果值从好到坏：
```
... > RANGE(使用到索引) > INDEX > ALL(全表扫描)
```
**一般查询应达到range级别**，具体可能值如下：
* SYSTEM ：CONST的特例，当表上只有一条记录时
* CONST ：WHERE条件筛选后表上至多有一条记录匹配时，比如`WHERE ID = 2`
* EQ_REF ：参与连接运算的表是内表（两表连接时作为循环中的内循环遍历的对象，这样的表称为内表）。基于索引（连接字段上存在唯一索引或者主键索引，且操作符必须是“=”谓词，索引值不能为NULL）做扫描，使得**对外表的一条元组，内表只有唯一一条元组与之对应**。
* REF ：可以用于单表扫描或者连接。参与连接运算的表，是内表。
  基于索引（连接字段上的索引是非唯一索引，操作符必须是“=”谓词，连接字段值不可为NULL）做扫描，使得对外表的一条元组，内表可有若干条元组与之对应。
* REF_OR_NULL ：类似REF，只是搜索条件包括：连接字段的值可以为NULL的情况，比如 where col = 2 or col is null
* RANGE ：**范围扫描**，基于索引做范围扫描，为诸如BETWEEN、IN、>=、LIKE类操作提供支持
* INDEX_SCAN ：索引做扫描，是基于索引在索引的叶子节点上找满足条件的数据（不需要访问数据文件）
* ALL ：`全表扫描`或者范围扫描：不使用索引，顺序扫描，直接读取表上的数据（访问数据文件）
* UNIQUE_SUBQUERY ：在子查询中，基于唯一索引进行扫描，类似于EQ_REF
* INDEX_SUBQUERY ：在子查询中，基于除唯一索引之外的索引进行扫描
* INDEX_MERGE ：多重范围扫描。两表连接的每个表的连接字段上均有索引存在且索引有序，结果合并在一起。适用于作集合的并、交操作。
* FT ：FULL TEXT，`全文检索`

**rows**
SQL执行检查的记录数

**Extra**
SQL执行的附加信息，如**Using index表示查询只用到索引列**，不需要去读表等。


## CASE…WHEN…THEN
使用CASE来重新定义数值类型：
```
SELECT id,title,(CASE date WHEN '0000-00-00' THEN '' ELSE date END) AS date
FROM your_table
  
SELECT id,title,
(CASE status WHEN 0 THEN 'open' WHEN 1 THEN 'close' ELSE 'standby' END) AS status
FROM your_table
```


## 关系型数据库三个范式
* 第一范式：是对属性的原子性约束，要求属性具有原子性，不可再分解； 
* 第二范式：是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 
* 第三范式：是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余（没有冗余的数据库未必是最好的数据库）。 


## 导出备份数据之后发送的写操作
先使用mysqlbinlog导出这部分写操作SQL（基于时间点或位置）：
```
# 导出2014-09-21 09:59:59之后的binlog
mysqlbinlog --database="test" --start-date="2014-09-21 09:59:59" /var/lib/mysql/mybinlog.000001 > binlog.data.sql

# 导出起始id为123456之后的binlog：
mysqlbinlog --database="test" --start-position="123456" /var/lib/mysql/mybinlog.000001 > binlog.data.sql
```

**导入备份数据**
```
mysql -uroot -p test < mytable.20140921.bak.sql
```

**导入binlog**
```
mysql -uroot -p test < binlog.data.sql
```

## ON DUPLICATE KEY UPDATE
```
# VALUES用来取插入的值，存在主键冲突时就更新，没有删除操作
INSERT INTO ... ON DUPLICATE KEY UPDATE col=VALUES(col)   
```
例：更新统计表
```
select * from player_count where player_id = 1;               # 查询统计表中是否有记录
insert into player_count(player_id,count) value(1,1);         # 没有记录就执行insert 操作
update player_count set count = count+1 where player_id = 1;  # 有记录就执行update操作
```
用ON DUPLICATE KEY UPDATE的做法如下：
```
insert into player_count(player_id,count) value(1,1) on duplicate key update count=count+1;
```

## 慢查询日志格式
```
User@Host: edu_online[edu_online] @  [10.139.10.167]
Query_time: 1.958000  Lock_time: 0.000021 Rows_sent: 254786  Rows_examined: 254786
SET timestamp=1410883292;
select * from t_online_group_records;
```
日志显示该查询用了1.958秒，返回254786行记录，一共遍历了254786行记录。及具体的时间戳和SQL语句。
可以使用mysqldumpslow进行慢查询日志分析。


## 常见MySQL性能优化技巧
* 优化MySQL查询语句，使其使用查询缓存
对于相同的查询MySQL引擎会使用缓存，但是如果在SQL语句中使用函数，如NOW()、RAND()、 CURDATE()等等，则拼凑出的查询不会被认为是相同的查询。
```php
// 查询缓存不开启
$r = mysql_query("SELECT username FROM user WHERE signup_date >= CURDATE()");

// 开启查询缓存
$today = date("Y-m-d");
$r = mysql_query("SELECT username FROM user WHERE signup_date >= $today");
```

* 当只要一行数据时使用LIMIT 1
这样MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。

* 为搜索字段建索引
索引并不一定就是给主键或是唯一的字段。如果在表中有某个字段总要会经常用来做搜索，那么就为其建立索引。

* **在JOIN表的时候使用相同类型的列，并将其索引**
对于那些STRING类型，还需要有相同的字符集才行（两个表的字符集有可能不一样）

* 千万不要ORDER BY RAND()
You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY 
would evaluate the column multiple times. 
当记录数据过多时，会非常慢。

* 避免SELECT *

* 使用ENUM而不是VARCHAR
ENUM实际保存的是TINYINT，但其外表上显示为字符串。如果有一个字段的取值是有限而且固定的，那么，应该使用ENUM而不是VARCHAR。

* **尽可能的使用NOT NULL**
“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”
NULL值需要额外的存储空间，而且在比较时也需要额外的逻辑。

* 把IP地址存成UNSIGNED INT，而不是VARCHAR(15)

* **固定长度的表会更快**
如果表中的所有字段都是固定长度的，整个表会被认为是`static`或`fixed-length`。

* 垂直分割
垂直分割是一种把数据库中的大表按列变成几张小表的方法，这样可以降低表的规模、方便使用缓存。
需要注意的是，这些被分出去的字段所形成的表，不应该会被经常性地去JOIN，否则性能会比不分割时还要差很多。

* 拆分大的DELETE或INSERT语句
因为这两个操作是会锁表的。如果有一个大的处理，一定把其拆分，使用LIMIT条件是一个好的方法。下面是一个示例：
```php
while (1) {
  // 每次只做1000条
  mysql_query("DELETE FROM logs WHERE log_date <= '2009-11-01' LIMIT 1000");
  if (mysql_affected_rows() == 0) {
    // 没得可删了，退出！
    break;
  }

  // 每次都要休息一会儿
  usleep(50000);
}
```

* 越小的列会越快
如使用TINYINT而不是INT，使用DATE而不是DATETIME。

* 选择一个正确的存储引擎
MyISAM对于SELECT COUNT(*)这类的计算非常快，但是不支持行锁（写操作会锁表），也不支持事务。
InnoDB的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比MyISAM还慢。

* 持久链接
持久链接的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。自从Apache开始重用它的子进程后下一次的HTTP请求会重用Apache的子进程，并重用相同的MySQL链接。

* 尽量早做过滤，使JOIN或者UNION等后续操作的数据量尽量小。

* 把能在逻辑层算的提到逻辑层来处理，如一些数据排序、时间函数计算等。


## 覆盖索引
对于
```
SELECT a FROM … WHERE b = …
```
这种查询，通常的做法是在b字段上建立索引，执行查询时系统会查询b索引进行定位，然后再利用此定位去表里查询需要的数据a。即该过程存在两次查询，一次是查询索引，一次是查询表。
使用Covering Index可以只查询一次索引就完成。建立一个组合索引`b,a`，当查询时，通过组合索引的b部分去定位，至于需要的数据a，立刻就可以在索引里得到，从而**省略了表查询的过程**。
如果使用Covering Index，要**注意SELECT的方式，只SELECT必要的字段**，而不能SELECT *，因为不太可能把所有的字段一起做索引。

可以使用EXPLAIN命令来确认是否使用了组合索引：**如果在Extra里出现`Using Index`，就说明使用的是Covering Index**。

**实例1：**
```
SELECT COUNT(*) FROM articles WHERE category_id = …
```
当在category_id建立索引后，这个查询使用的就是Covering Index（即，只查索引，而没有查表）。

**实例2：**
比如说在文章系统里分页显示的时候，一般的查询是这样的：
```
SELECT id, title, content FROM article ORDER BY created DESC LIMIT 10000, 10;
```
通常这样的查询会把索引建在created字段（其中id是主键），不过当LIMIT偏移很大时，查询效率仍然很低，改变一下查询：
```
SELECT id, title, content FROM article
INNER JOIN (
  SELECT id FROM article ORDER BY created DESC LIMIT 10000, 10
) AS page USING(id)
```
此时，建立复合索引`created, id`就可以在子查询里利用上Covering Index，快速定位id。

## B树
B树是对二叉查找树的改进。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。
**特点如下：**
* 一个节点可以容纳多个值
* 除非数据已经填满，否则不会增加新的层。也就是说，**B树追求"层"越少越好**。
* 子节点中的值，与父节点中的值，有严格的大小对应关系。一般来说，如果父节点有a个值，那么就有a+1个子节点。
这种数据结构，非常有利于减少读取硬盘的次数。**假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层**。假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。
数据库以B树格式储存，只解决了按照"主键"查找数据的问题。如果想查找其他字段，就需要建立索引（index）。所谓索引，就是以某个字段为关键字的B树文件（这里仅指基于B树的索引）。

## GROUP BY注意点
* 在SELECT指定的字段要么就要包含在GROUP BY语句的后面，作为分组的依据；要么就要被包含在聚合函数中；
* HAVING子句的作用是筛选满足条件的组，即在分组之后过滤数据；

## innodb_buffer_pool_size
innodb_buffer_pool_size这个参数主要作用是设置缓存innodb表的索引、数据、插入数据时的缓冲的缓存区大小。
默认值：128M，操作系统内存的70%-80%最佳。
此外，这个参数是非动态的，要修改这个值，**需要重启mysqld服务**。

如果因为内存不够，MySQL无法启动，就会在错误日志中出现如下报错：
```
InnoDB: mmap(137363456 bytes) failed; errno 12
```

## LIMIT
返回不多于5行（小于等于）
```
SELECT prod_name FROM products LIMIT 5;
```

返回从第6行开始的5行（行号从0开始）
```
SELECT prod_name FROM products LIMIT 5,5;
```

返回从第6行开始的5行（LIMIT的一种替代语法）
```
SELECT prod_name FROM products LIMIT 5 OFFSET 5;
```

## MyISAM和InnoDB的比较
* MySQL默认采用的是MyISAM。
* MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。
* InnoDB支持数据行级锁，MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。
* InnoDB支持外键，MyISAM不支持外键。
* InnoDB的主键范围更大，最大是MyISAM的2倍。
* InnoDB不支持全文索引，而MyISAM支持。全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实作用不大，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。
* MyISAM支持GIS数据，InnoDB不支持。即MyISAM支持以下空间数据对象：Point、Line、Polygon、Surface等。
* 没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(*)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(*)时一般要伴随where，且where中要包含**主键以外的**索引列（因为InnoDB中PRIMARY KEY是和raw data存放在一起的，而其他index则是单独存放，然后有个指针指向PRIMARY KEY。所以只是count(*)的话使用其他index扫描更快，而PRIMARY KEY则主要在扫描索引同时要返回raw data时的作用较大）。

## MySQL一行记录最多能有多少个VARCHAR(255)类型的列？
MySQL表中一行的长度不能超过65535字节，VARCHAR(N)使用额外的1到2字节来存储值的长度，如果N<=255，则使用一个字节，否则使用两个字节；如果表格的编码为UTF8（一个字符占3个字节），那么VARCHAR(255)占用的字节数为255 * 3 + 2 = 767，这样，一行就最多只能有65535 / 765 = 85个VARCHAR(255)类型的列。


## MySQL事务隔离级别（ISOLATION LEVEL）
* READ UNCOMMITTED
最低的隔离级别，可读取其他事务未提交的数据（事务可以看到其他事务尚未提交的修改），可能造成脏读。

* READ COMMITTED
只能读取已提交的数据，但是不可重复读（避免脏读）

* REPEATABLE READ
可重复读。
用户A查询完之后，用户B将无法更新用户A所查询到的数据集中的任何数据（但是可以更新、插入和删除用户A查询到的数据集之外的数据），直到用户A事务结束才可以进行更新，这样就有效的**防止用户在同一个事务中读取到不一致的数据**。

* SERIALIZABLE
事务串行化，必须等待当前事务执行完，其他事务才可以执行写操作，有多个事务同时设置SERIALIZABLE时会产生死锁：
```
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```
这是四个隔离级别中限制最大的级别。因为并发级别较低，所以应只在必要时才使用该选项。

**使用事务时设置隔离级别**
```
START TRANSACTION
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
COMMIT
ROLLBACK
```

## MySQL分区表理解
分区是一种粗粒度，简易的索引策略，适用于大数据的过滤场景。对于大数据（如10TB）而言，索引起到的作用相对小，因为索引的空间与维护成本很高，另外如果不是索引覆盖查询，将导致回表，造成大量磁盘IO。
分区表分为RANGE、LIST、HASH、KEY四种类型，并且分区表的索引是可以局部针对分区表建立的。
用RANGE创建分区表：
```
CREATE TABLE sales (
  id INT AUTO_INCREMENT,
  amount DOUBLE NOT NULL,
  order_day DATETIME NOT NULL,
  PRIMARY KEY(id, order_day)
) ENGINE=Innodb PARTITION BY RANGE(YEAR(order_day)) (
  PARTITION p_2010 VALUES LESS THAN (2010),
  PARTITION p_2011 VALUES LESS THAN (2011),
  PARTITION p_2012 VALUES LESS THAN (2012),
  PARTITION p_catchall VALUES LESS THAN MAXVALUE);
```
如果这么做，则order_day必须包含在主键中，且会产生一个问题：当年份超过阈值，到了2013，2014时需要手动创建这些分区，更好的方法是使用HASH：
```
CREATE TABLE sales ( 
  id INT PRIMARY KEY AUTO_INCREMENT,
  amount DOUBLE NOT NULL,
  order_day DATETIME NOT NULL
) ENGINE=Innodb PARTITION BY HASH(id DIV 1000000);
```
这种分区表示每100W条数据建立一个分区，且没有阈值范围的影响。

如果想为一个表创建分区，这个表最多只能有一个唯一索引（主键也是唯一索引）。如果没有唯一索引，可指定任何一列为分区列；否则就只能指定唯一索引中的任何一列为分区列。查询时需用到分区的列，不然会遍历所有的分区，比不分区的查询效率还低，MySQL支持子分区。
在表建立后也可以新增、删除、合并分区。


## MySQL主从同步工作模式理解
**复制机制（Replication）**
master通过复制机制，将master的写操作通过`binlog`传到slave生成中继日志(`relaylog`)，slave再将中继日志redo，使得主库和从库的数据保持同步。

**slave主动拉取模式下复制相关的3个MySQL线程**：
* slave上的I/O线程：向master请求数据；
* master上的Binlog Dump线程：读取binlog事件并把数据发送给slave的I/O线程；
* slave上的SQL线程：读取中继日志并执行，更新数据库；

**相关监控命令**
```
show processlist      # 查看MySQL进程信息，包括3个同步线程的当前状态
show master status    # 查看master配置及当前复制信息
show slave status     # 查看slave配置及当前复制信息
```

## MySQL异步
MySQL异步是指将MySQL连接事件驱动化，这样就变成了非阻塞IO。数据库操作并不会阻塞进程，在MySQL-Server返回结果时再执行对应的逻辑。

**注意点**：
* 异步MySQL并没有节省SQL执行的时间
* 一个MySQL连接同时只能执行1个SQL，如果异步MySQL存在并发那么必须创建多个MySQL连接
* 异步回调程序中，异步MySQL并没有提升性能。**异步最大的好处是可以高并发**，如果并发1万个请求，那么就需要建立1万个MySQL连接，这会给MySQL-Server带来巨大的压力。

虽然应用层代码使用异步回调避免了自身的阻塞，实际上真正的瓶颈是数据库服务器。异步MySQL还带来了额外的编程复杂度，所以除非是特殊场景的需求，否则不建议使用异步MySQL。如果程序中坚持要使用异步，那么必须是异步MySQL+连接池的形式。超过规定的MySQL最大连接后，应当对SQL请求进行排队，而不是创建新连接，避免大量并发请求导致MySQL服务器崩溃。


## MySQL索引类型
* 普通索引：最基本的索引，没有任何限制，MyISAM中默认的BTREE类型的索引，也是大多数情况下用到的索引。
```
// 直接创建索引
CREATE INDEX index_name ON table(column(length))

// 修改表结构的方式添加索引
ALTER TABLE table_name ADD INDEX index_name ON (column(length))

// 创建表的时候同时创建索引
CREATE TABLE `table` (
  `id` int(11) NOT NULL AUTO_INCREMENT ,
  `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
  `time` int(10) NULL DEFAULT NULL ,
  PRIMARY KEY (`id`),
  INDEX index_name (title(length))
)

// 删除索引
DROP INDEX index_name ON table
```

* 唯一索引
索引列的值必须唯一，但**允许有空值**（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。

```
// 创建唯一索引
CREATE UNIQUE INDEX indexName ON table(column(length))

// 修改表结构
ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))

// 创建表的时候直接指定
CREATE TABLE `table` (
  `id` int(11) NOT NULL AUTO_INCREMENT ,
  `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
  `time` int(10) NULL DEFAULT NULL ,
  PRIMARY KEY (`id`),
  UNIQUE indexName (title(length))
);
```

* 全文索引
**仅可用于MyISAM表**。可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE或CREATE INDEX被添加。对于较大的数据集，将资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。 

```
// 创建表的适合添加全文索引
CREATE TABLE `table` (
  `id` int(11) NOT NULL AUTO_INCREMENT ,
  `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
  `time` int(10) NULL DEFAULT NULL ,
  PRIMARY KEY (`id`),
  FULLTEXT (content)
);

// 修改表结构添加全文索引
ALTER TABLE article ADD FULLTEXT index_content(content)

// 直接创建索引
CREATE FULLTEXT INDEX index_content ON article(content)
```

* 单列索引、多列索引
多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。

* 组合索引
```
ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10));
```
建立这样的组合索引，**相当于分别建立了下面两组组合索引**：

```
title,time
title
```
没有time这样的组合索引，因为MySQL组合索引执行**最左前缀匹配**，简单的理解就是只从最左面的开始组合。如：

```
SELECT * FROM article WHREE title='测试' AND time=1234567890;   # 使用title,time索引
SELECT * FROM article WHREE utitle='测试';                      # 使用title索引
SELECT * FROM article WHREE time=1234567890;                   # 未使用索引    
```

**MySQL只对以下操作符才使用索引：**
```
<、<=、=、>、>=、between、in、以及某些时候的like(不以通配符%或_开头的情形)。
```
**理论上每张表里面最多可创建16个索引**。 


## MySQL自增主键出现不连续情况的原因
**造成自增主键不连续的原因**
* INSERT语句不管是否成功，都会增加AUTO_INCREMENT值。
* 进行了DELETE相关操作。
* ROLLBACK相关。

**修复自增主键，使其连续**
```
INSERT INTO th_page2(site,url,title,title_index,content,tag,created_at,updated_at,deleted_at)
SELECT site,url,title,title_index,content,tag,created_at,updated_at,deleted_at FROM th_page ORDER BY tag;

DROP TABLE th_page;

ALTER TABLE th_page2 RENAME th_page;
```

## ON与WHERE比较
执行连接操作时，可先用ON先进行过滤，减少连接操作的中间结果，然后用WHERE对连接产生的结果再一次过滤。但是，如果是左/右连接，在ON条件里对主表的过滤是无效的，仍然会用到主表的所有记录，连接产生的记录如果不满足主表的过滤条件那么从表部分的数据会置为NULL。
