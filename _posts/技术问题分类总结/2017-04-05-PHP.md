---
layout: post
title:  "PHP"
date: 2017-04-05 00:00:01
categories: 技术问题分类总结
tags: PHP
excerpt: ""
---

* content
{:toc}

## foreach循环中使用引用存在的问题
**问题**
求以下代码的打印值：
```php
<?php
$array = [1, 2, 3]; 
foreach ($array as &$value) {}   
foreach ($array as $value) {}        
var_dump($array);
```

**分析**
```php
<?php
$array = [1, 2, 3]; 

foreach ($array as &$value) {
  // do nothing
}   

var_dump($array);  // 1 2 3
var_dump($value);  // 3 $value在这里仍然有作用域

// unset($value);  // fix

foreach ($array as $value) {
  // do nothing
}        
var_dump($array);  // 1 2 2
```
**总结**
* PHP foreach循环中定义的“临时变量”的作用域会延伸到循环体之外；
* 引用自己并没有维护一个值，而是指向引用的变量，对引用的修改等于对被引用对象的修改；




## __autoload()和spl_autoload_register()的主要区别

**函数原型**
```php
<?php
void __autoload(string $class)

bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )
```

**区别**
* spl_autoload_register()函数会将Zend Engine中的__autoload()函数取代为spl_autoload()或spl_autoload_call()。
* spl_autoload_register()<u>可以很好地处理需要多个加载器的情况</u>，这种情况下spl_autoload_register会<u>按顺序依次调用之前注册过的加载器</u>。作为对比，__autoload 因为是一个函数，所以只能被定义一次。


**举例**
```php
<?php
spl_autoload_register(function ($class) {
  include 'classes/' . $class . '.class.php';
});
```

## 使用spl_autoload_register()调用静态方法
```php
<?php
class Loader {
  public static function loadPrinter( $class ) {
    $file = $class . '.class.php';  
    if (is_file($file)) {  
      require_once($file);  
    } 
  }
} 

spl_autoload_register(['Loader','loadPrinter']);
// 另一种写法：spl_autoload_register("Loader::loadPrinter"); 

$obj = new Printer();  // 假设存在Printer.class.php这个文件
$obj->doPrint();
```

## 4种字符串表示方法
* 单引号（不会转义）
* 双引号（会转义）
* heredoc语法结构（类似双引号）
* nowdoc语法结构（类似单引号）
字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1。


## PHP中的闭包无须像js（非ES6）一样通过self=this的形式来扩展作用域
```php
<?php
class Demo{
  private $list = [1,2,3,4,5,6,7,8,9,10];
  public $delList = [];
  
  public function test(){
    $arr = array_filter($this->list,function($n){
      if($n % 2 == 0){
        return true;
      }
      else{
        $this->delList[] = $n;  // 此$this指向Demo的对象，而非闭包函数
        return false;
      }
    });
    
    return $arr;
  }
}

$demo = new Demo();
$arr = $demo->test();
var_dump($arr);   // 1 3 5 7 9
var_dump($demo->delList); // 2 4 6 8 10
```

## 在PHP中使用异步非阻塞函数
* swoole_client异步模式
* mysql-async库
* redis-async库
* swoole_timer_tick/swoole_timer_after
* swoole_event系列函数
* swoole_table/swoole_atomic/swoole_buffer
* swoole_server->task/finish函数


## PHP对象注入漏洞
PHP支持对象的序列化和反序列化操作（serialize、unserialize）。
如：
```php
<?php
class User{
  public $age = 0;
  public $name = '';
  public function PrintData(){
    echo 'User ' . $this->name . ' is ' . $this->age . ' years old. <br />';
  }
}

$usr = unserialize('O:4:"User":2:{s:3:"age";i:20;s:4:"name";s:4:"John";}');
$usr->PrintData();
```

输出：
```
User John is 20 years old. 
```
当一个对象进行序列化和反序列化操作时也会自动调用其他相应的魔术方法：
* 当对象进行序列化操作时魔术方法__sleep()会被自动调用（必须返回一个包含序列化的类变量名的数组）。
* 当对象进行反序列化操作时魔术方法__wakeup()会被自动调用。

攻击者可以操作类变量来攻击web应用，比如：
```php
<?php
$usr = unserialize('O:7:"LogFile":1:{s:8:"filename";s:9:".htaccess";}');
$usr->PrintData();
```
从而意外地执行了LogFile的__construct()和_destruct()。
在处理由用户提供数据的地方不要使用unserialize()，可以使用json_decode(...)。

**总结**
实际就是PHP的反序列化机制会自动执行一些魔方方法，从而引起一些意外情况。

## PHP数据类型
PHP共支持8种原始数据类型，其中包括：
* 4种标量类型：boolean、integer、float（double）、string
* 2种复合类型：array、object
* 2种特殊类型：resource、NULL
double和float是相同的，由于一些历史的原因，这两个名称同时存在。
变量的类型通常不是由程序员设定的，确切地说，是由PHP根据该变量使用的上下文在运行时决定的。

## PHP变量作用域
**6项基本的作用域规则**：
* 超级全局变量（内置）可以在脚本的任何地方使用和可见。
* 常量一旦被声明，将全局可见，即可以在函数内外使用。
* 在一个脚本中声明的全局变量在整个脚本中是可见的。
* 函数内部使用的变量声明为全局变量时，其名称要与全局变量一致。
* 在函数内部创建的静态变量，在函数外部不可见，但是可以在函数的多次执行中保持值。
* 在函数内部创建的非静态变量，当函数终止时就不存在了。


## SAPI
无论是Web模式还是Cli模式运行，PHP的工作原理都是一样的， 都是作为一种SAPI在运行（Server Application Programming Interface：the API used by PHP to interface with Web Servers）。SAPI就是PHP和外部环境的代理器。它把外部环境抽象后, 为内部的PHP提供一套固定的，统一的接口，使得PHP自身实现能够不受错综复杂的外部环境影响，保持一定的独立性。


## PHP扩展的基本执行方式
* MINIT
在PHP随着Apache的启动而常驻在内存里时， 会把自己所有已加载扩展的MINIT方法(全称Module Initialization，是由每个模块自己定义的函数)都执行一遍。 在这个时间里，扩展可以定义一些自己的常量、类、资源等所有会被用户端的PHP脚本用到的东西。 

RINIT
当一个页面请求到来时候，PHP会迅速的开辟一个新的环境，并重新扫描自己的各个扩展， 遍历执行它们各自的RINIT方法(俗称Request Initialization)， 这时候一个扩展可能会初始化在本次请求中会使用到的变量等， 还会初始化稍后用户端（即PHP脚本）中的变量之类的。

RSHUTDOWN
当请求完成（或者别die等终结），PHP便会启动回收程序，执行所有已加载扩展的RSHUTDOWN（Request Shutdown）方法， 这时候扩展可以抓紧利用内核中的变量表之类的做一些事情， 因为一旦PHP把所有扩展的RSHUTDOWN方法执行完， 便会释放掉这次请求使用过的所有东西， 包括变量表的所有变量、所有在这次请求中申请的内存等等。

MSHUTDOWN
当Apache通知PHP自己要Stop的时候，PHP便进入MSHUTDOWN（Module Shutdown）阶段。一旦PHP把扩展的MSHUTDOWN执行完，便会进入自毁程序，所以这里一定要把自己擅自申请的内存给释放掉。

**一个最简单的例子**
walu.c 
```c
int time_of_minit;  // 每次请求都不变
PHP_MINIT_FUNCTION(walu)
{
  time_of_minit=time(NULL);
  return SUCCESS;
}

int time_of_rinit;  // 每次请求都改变
PHP_RINIT_FUNCTION(walu)
{
  time_of_rinit=time(NULL);
  return SUCCESS;
}

// 每次页面请求都会往time_rshutdown.txt中写入数据
PHP_RSHUTDOWN_FUNCTION(walu)
{
  FILE *fp=fopen("/cnan/www/erzha/time_rshutdown.txt","a+");
  fprintf(fp,"%d\n",time(NULL));
  fclose(fp);
  return SUCCESS;
}

// 只有在apache结束后time_mshutdown.txt才写入有数据
PHP_MSHUTDOWN_FUNCTION(walu)
{
  FILE *fp=fopen("/cnan/www/erzha/time_mshutdown.txt","a+");
  fprintf(fp,"%d\n",time(NULL));
  return SUCCESS;
}

PHP_FUNCTION(walu_test)
{
  php_printf("%d&lt;br /&gt;",time_of_minit);
  php_printf("%d&lt;br /&gt;",time_of_rinit);
  return;
}
```

## PHP的生命周期
PHP扩展程序的两种init（MINIT、RINIT）和两种shutdown（RSHUTDOWN、MSHUTDOWN）各会执行多少次、各自的执行频率有多少取决于PHP是用什么SAPI与宿主通信的。最常见的四种SAPI通信方式如下：
**1.直接以CLI/CGI模式调用**
 PHP的生命周期完全在一个单独的请求中完成，两种init和两种shutdown仍然都会被执行。
 以`php -f test.php`为例，执行过程如下：
* （1）调用每个扩展的MINIT；
* （2）请求test.php文件；
* （3）调用每个扩展的RINIT；
* （4）执行test.php；
* （5）调用每个扩展的RSHUTDOWN；
* （6）执行清理操作；
* （7）调用每个扩展的MSHUTDOWN；
* （8）终止php；
fpm的每个请求都是在执行RINIT到RSHUTDOWN的步骤。
opcode cache是把第（4）步的词法分析、语法分析、生成opcode代码这几个操作给缓存起来了，从而达到加速的作用。
swoole在第（4）步接管了PHP，进入swoole的生命周期。

**2.多进程模块**
如编译成Apache2的Pre-fork MPM，当Apache启动的时候，会立即把自己fork出好几个子进程，每一个进程都有自己独立的内存空间，在每个进程里的PHP的工作方式如下：
* （1）调用每个扩展的MINIT；
* （2）循环：{ a.调用每个扩展的RINIT;  b.执行脚本； c.调用每个扩展的RSHUTDOWN；}
* （3）调用每个扩展的MSHUTDOWN；

**3.多线程模块**
如IIS的isapi和Apache MPM worker，**只有一个服务器进程在运行着，但会同时运行很多线程**，这样可以减少一些资源开销，像Module init和Module shutdown就只需要运行一次就行了，一些全局变量也只需要初始化一次， 因为线程独具的特质，使得各个请求之间方便的共享一些数据成为可能。

**4.Embedded(嵌入式，在自己的C程序中调用Zend Engine)**
Embed SAPI是一种比较特殊但不常用的SAPI，允许在C/C++语言中调用PHP/ZE提供的函数。 这种SAPI和上面的三种一样，按Module Init、Request Init、Rshutdown、mshutdown的流程执行着。

## open_basedir配置项的作用
open_basedir是PHP配置中为了防御跨目录进行文件（目录）读写的配置，所有PHP中有关文件读、写的函数都会经过open_basedir的检查。实际上是一些目录的集合，在定义了open_basedir以后，PHP可以读写的文件、目录都将被限制在这些目录中。在Linux下，不同的目录由`:`分割，如`/var/www/:/tmp/`。
注意用open_basedir指定的限制实际上是前缀，而不是目录名。

Apache运行PHP有三种配置open_basedir的方法：
* （1）在php.ini里配置
```
open_basedir = .:/tmp/
```

* （2）在Apache配置的VirtualHost里设置(httpd-vhosts.conf)
```
php_admin_value open_basedir .:/tmp/
```

* （3）在Apache配置的Direcotry里设置
```
php_admin_value open_basedir .:/tmp/
```

**关于三个配置方法的解释**
* 优先级：方法（3）>方法（2）>方法（1）;
* 配置目录里加了`/tmp/`是因为PHP默认的临时文件（如上传的文件、session等）会放在该目录，所以一般需要添加该目录，否则部分功能将无法使用；
* 配置目录里加了`.`是指运行PHP文件的当前目录，这样做可以避免每个站点一个一个设置；
* 如果站点还使用了站点目录外的文件，需要单独在对应VirtualHost设置该目录；


## 使用PHP数组模拟队列操作的性能问题
PHP的数组提供了array_pop和array_shift可以使用数组模拟队列数据结构。虽然使用Array可以实现队列，但实际上性能会非常差。在一个大并发的服务器程序上，建议使用SplQueue作为队列数据结构。
一项实测结果：100万条数据随机入队、出队，使用SplQueue仅用2312.345ms即可完成，而使用Array模拟的队列的程序根本无法完成测试，CPU一直持续在100%，降低到1万条后，也需要260ms才能完成测试。
详略。

## PHP不必做编译优化
C等需要编译执行的程序通常一次编译，会多次运行或长时间运行，因此在编译上多耗些时间、多做些优化被认为是值得的。而解释型语言往往作为胶水语言，也就是完成一项用后即弃的特定任务。官方的答复是，PHP程序运行时间往往很短暂，比如10ms；如果花100ms做编译优化，把运行时间压缩到1ms，总的时间消耗是101ms，反而更慢了（不考虑中间代码缓存）。

## 在被包含文件中仍然要使用`<?php`起始标志
当一个文件被包含时，语法解析器在目标文件的开头脱离PHP模式并进入HTML模式，到文件结尾处恢复。由于此原因，目标文件中需要作为PHP代码执行的任何代码都必须被包括在有效的PHP起始和结束标记之中。

## 应该关闭register_globals配置
这个配置影响到PHP如何接收传递过来的参数。register_globals的意思就是注册为全局变量，所以当On的时候，传递过来的值会被直接的注册为（与HTML控件的name属性同名的）全局变量直接使用，而Off的时候，需要到特定的全局变量数组里去得到它。

## PHP中NULL值的判断
NULL类型唯一可能的值就是NULL（不区分大小写）。在下列情况下一个变量被认为是NULL：
* 被赋值为NULL
* 尚未被赋值
* 被unset() 
递减NULL值也没有效果，但是递增NULL的结果是1。
```php
<?php
$a = null;
$b = null;

$a--;
$b++;

var_dump($a);  // null
var_dump($b);  // 1
```

## 不能使用可变变量的变量
超全局变量不能用作可变变量。$this变量也是一个特殊变量，不能被动态引用。


## 使用yield实现双向异步信息传递
包含yield关键字的函数比较特殊，返回值是一个Generator对象，此时函数内语句尚未真正执行。Generator对象是Iterator接口实例，可以通过rewind()、current()、next()、valid()系列接口进行操纵。Generator可以视为一种“可中断”的函数，而yield构成了一系列的“中断点”。
```php
<?php
function gen() {
  for($i=1;$i<=100;$i++) {
    // yield既是语句，又是表达式，既具备类似return语句的功能，同时也有类似表达式的返回值（通过send得到的值）
    $cmd = (yield $i);  
    if($cmd=='stop') {
      return;
    }
  }
}

$gen = gen();
$i=0;
foreach($gen as $item) {
  echo $item."\n";
  if($i>=10) {
    $gen->send('stop');  // 向Generator发送值
  }
  $i++;
}
```

## 控制数组json_encode后为json对象或者json数组
```php
<?php
$foo = [
  "item1" => (Object)[],  // 关键点：将Array转换成Object类型
  "item2" => []
];

echo json_encode($foo);
```
输出：
```php
{"item1":{},"item2":[]}
```

## return的使用场景和行为
* 如果在全局范围中调用，则当前脚本文件中止运行；
* 如果当前脚本文件是被include的或者require的，则控制交回调用文件；且如果当前脚本是被include的，则return的值会被当作include调用的返回值。
* 如果当前脚本文件是在php.ini中的配置选项auto_prepend_file或者auto_append_file所指定的，则此脚本文件中止运行；
return是语言结构而不是函数，因此其参数没有必要用括号将其括起来。通常都不用括号，实际上也应该不用，这样可以降低PHP的负担。 如果没有提供参数，则一定不能用括号，此时返回NULL。如果调用return时加上了括号却又没有参数会导致解析错误。


## cgi.fix_pathinfo配置项的作用
如果Web Server为Nginx，则须在PHP的配置文件php.ini中配置cgi.fix_pathinfo = 0，防止<u>Nginx文件解析漏洞</u>。
在cgi.fix_pathinfo = 1的情况下，假设有如下的URL：http://xxx.net/foo.jpg，当访问http://xxx.net/foo.jpg/a.php时，foo.jpg将会被执行，如果foo.jpg是一个普通文件，那么foo.jpg的内容会被直接显示出来，但是如果把一段php代码保存为foo.jpg，那么问题就来了，这段代码就会被直接执行。

## 启用并配置OpCache
**php.ini**
```ini
; 开关打开
opcache.enable=1

; 可用内存, 酌情而定, 单位megabytes(M)
opcache.memory_consumption=256

...
```

**检查**
```
php -v

PHP 5.5.3-1ubuntu2.2 (cli) (built: Feb 28 2014 20:06:05) 
Copyright (c) 1997-2013 The PHP Group
Zend Engine v2.5.0, Copyright (c) 1998-2013 Zend Technologies
with Zend OPcache v7.0.3-dev, Copyright (c) 1999-2013, by Zend Technologies
```
注意其中多出了：
```
with Zend OPcache v7.0.3-dev
```
需要提醒的是，在生产环境中使用上述配置之前，必须经过严格测试。 因为上述配置存在一个已知问题，它会引发一些框架和应用的异常， 尤其是在存在文档使用了备注注解的时候。
如果在更新代码之后，发现没有执行的还是旧代码，可使用函数opcache_reset()来清除缓存。


## 收集PHP错误日志
```
display_errors = Off
log_errors = On

# 该文件必须允许Web Server的用户和组具有写的权限
error_log = /usr/local/apache2/logs/php_error.log 
```

## 禁止在PHP中使用危险函数
```ini
disable_functions = dl,assert,exec,popen,system,passthru,shell_exec,proc_close,proc_open,pcntl_exec
```


## 使用define和const定义常量的区别
* 用define定义的常量可以不用理会变量的作用域而在任何地方定义和访问；
* 使用const关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内、循环内以及if语句之内用const来定义常量；

## allow_url_fopen和allow_url_include配置
允许访问URL远程资源（即允许fopen这样的函数打开url）使得PHP应用程序的漏洞变得更加容易被利用，php脚本若存在远程文件包含漏洞会使得攻击者直接获取网站权限及上传web木马。一般会在php配置文件中关闭该功能，若需要访问远程服务器建议采用其他方式如libcurl库。
```ini
allow_url_fopen = Off
allow_url_include = Off
```
比如有这样的代码：
```php
<?php
if(isset($HTTP_GET_VARS)){
  reset($HTTP_GET_VARS);
  while ( list($var, $val) = each($HTTP_GET_VARS) ) {
    $$var=$val;
  }
}
```
一些较偶然的场景会导致将以http://开头的get参数所表示的远程文件直接包含进来，然后执行。


## 魔术常量
* __LINE__ 文件中的当前行号
* __FILE__ 文件的完整路径和文件名
* __DIR__ 文件所在的目录 
* __FUNCTION__ 函数名称（PHP 4.3.0 新加）
* __CLASS__ 类的名称（PHP 4.3.0 新加）  
* __TRAIT__ Trait 的名字（PHP 5.4.0 新加）  
* __METHOD__ 类的方法名（PHP 5.0.0 新加）
* __NAMESPACE__ 当前命名空间的名称（区分大小写）


## 用于属性重载的魔术方法
* 在给不可访问属性赋值时，__set()会被调用。 
* 读取不可访问属性的值时，__get()会被调用。 
* 当对不可访问属性调用isset()或empty()时，__isset()会被调用。 
* 当对不可访问属性调用 unset() 时，__unset()会被调用。 
* 属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。


## 用于方法重载的魔术方法
* 在对象中调用一个不可访问方法时，__call()会被调用。 
* 用静态方式中调用一个不可访问方法时，__callStatic()会被调用。


## 在声明静态变量时不能使用表达式进行赋值
静态变量的声明是在编译时解析的，因此在声明静态变量时不能用表达式进行赋值。
```php
<?php
function foo(){
  static $int = 0;       	// ok
  static $int = 1+2;    	// error  (as it is an expression)
  static $int = sqrt(121);  // error  (as it is an expression too)

  $int++;
  echo $int;
}
```

## 将非对象类型转换为对象
* 如果将一个对象转换成对象，它将不会有任何变化；
* 如果其它任何类型的值被转换成对象，将会创建一个内置类stdClass的实例；
* 如果该值为NULL，则新的实例为空；
* 数组转换成对象将使键名成为属性名并具有相对应的值；
* 对于任何其它的值，名为scalar的成员变量将包含该值； 
```php
<?php
$a = (Object)'abc';
echo $a->scalar;  // abc
echo gettype($a); // object
```

## 被包含文件的搜索顺序
* 先按参数给出的路径寻找；
* 如果没有给出目录（只有文件名）时则按照include_path指定的目录寻找；
* 如果在include_path下没找到该文件则include最后才在调用脚本文件所在的目录和当前工作目录下寻找；
* 如果最后仍未找到文件则include结构会发出一条警告；这一点和require不同，后者会发出一个致命错误；
* 如果定义了路径，不管是绝对路径还是当前目录的相对路径，include_path都会被完全忽略；


## 包含文件的作用域关系
* 当一个文件被包含时，其中所包含的代码继承了include所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域；
* 如果include出现于调用文件中的一个函数里，则被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样。所以它将遵循该函数的变量范围。此规则的一个例外是魔术常量，它们是在发生包含之前就已被解析器处理的；
