---
layout: post
title:  "问题总结：PHP"
date: 2017-04-05 00:00:05
categories: 问题总结
tags: PHP
excerpt: ""
---

* content
{:toc}

# foreach循环中使用引用有什么潜在问题？

```php
<?php
$array = [1, 2, 3]; 
echo implode(',', $array), "<br/>";   // 1,2,3

foreach ($array as &$value) {}    
echo implode(',', $array), "<br/>";   // 1,2,3  

foreach ($array as $value) {}        
echo implode(',', $array), "<br/>";   // 1,2,2
```

**第一个循环过后，$value是数组中最后一个元素的引用。**
第二个循环开始：

* 第1步：复制$arr[0]到$value（注意此时$value是$arr[2]的引用），这时数组变成[1,2,1]
* 第2步：复制$arr[1]到$value，这时数组变成[1,2,2]
* 第3步：复制$arr[2]到$value，这时数组变成[1,2,2]

综上，最终结果就是1,2,2
避免这种错误最好的办法就是**在循环后立即用unset函数销毁变量**：

```php
<?php
$arr = array(1, 2, 3, 4); 
foreach ($arr as &$value) { 
  $value = $value * 2; 
} 
unset($value);
```

# __autoload和spl_autoload_register()的主要区别？
函数原型：
```php
<?php
void __autoload(string $class)

bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )
```

区别：

* spl_autoload_register()函数会将Zend Engine中的__autoload()函数取代为spl_autoload()或spl_autoload_call()。__
* __spl_autoload_register 可以很好地处理需要`多个加载器`的情况，这种情况下spl_autoload_register会`按顺序依次调用`之前注册过的加载器**。作为对比， __autoload 因为是一个函数，所以只能被定义一次。 



# 使用spl_autoload_register()调用静态方法 

```php
<?php
class test {
  public static function loadprint( $class ) {
    $file = $class . '.class.php';  
    if (is_file($file)) {  
      require_once($file);  
    } 
  }
} 

spl_autoload_register(['test','loadprint']);
// 另一种写法：spl_autoload_register("test::loadprint"); 

$obj = new PRINTIT();
$obj->doPrint();
```

# CGI、FastCGI的理解和区别

## CGI

CGI即**公共网关接口**(Common Gateway Interface)，描述了客户端和服务器程序之间传输数据的一种协议，就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。总之，**CGI是一种标准，一种协议**。

## CGI程序

CGI程序确保CGI协议的顺利执行，并且返回结果，用来**沟通程序（如PHP、Python、 Java）和Web服务器（Apache2、Nginx）**，充当桥梁的作用。即CGI程序是介于Web服务器与Web程序之间的，用来保证CGI协议的程序。如php-fpm。

Web Server（比如说nginx）只是内容的分发者。比如，如果客户端请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，那它就要找到相应的CGI程序来处理了，根据配置，找到了php-cgi这个程序（也就是PHP解析器），那么他会把这个请求交个php-cgi（安装PHP时会附带安装的一个程序）。nginx会启动CGI程序，然后会根据CGI协议，把需要的数据传给全部丢给php-cgi，比如请求的url，查询字符串，POST数据，HTTP header等等。php-cgi会解析php.ini文件，初始化执行环境，然后找到index.php，编译，执行。程序的输出会由Web服务器收集，并加上合适的HTTP头，再发送回客户端。

**CGI执行的特点**：每次请求过来，再启动CGI程序，去处理请求。所以就会造成，如果n个请求过来，就得启动n个CGI程序的进程来处理，处理完之后，就销毁相应的线程。但是启动一个进程，肯定是需要时间的，这样大量的启动、销毁，造成了大量的浪费。

一些更有效的技术可以让脚本解释器直接作为模块集成在 Web 服务器（例如：Apache，mod_php）中，这样就能避免重复载入和初始化解释器。不过这只是就那些需要解释器的高级语言（即解释型语言）而言的，使用诸如C一类的编译语言则可以避免这种额外负荷。

## FastCGI

与为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。FastCGI会启动FastCGI进程管理器（简称`master`），解析配置文件，初始化执行环境，master再启动多个CGI程序（简称`worker`）在那里等候。

当进来一个请求时，web服务器把环境变量和这个页面请求通过一个socket比如FastCGI进程与web服务器(都位于本地）或者一个TCP connection（FastCGI进程在远端的server farm）传递给FastCGI进程。Apache通过mod_fcgid以及较早的第三方mod_fastcgi模块来实现。 

**master的执行特点**：请求过来，把请求传递给到空闲的worker，然后立即可以接受下一个请求，再传递。

**worker的职责**：每个worker都一直在等候，接到从master传递过来的请求之后，立即执行并返回，但是**执行完毕后，不销毁，而且继续等待下个请求**。当然，master还时时刻刻监控着worker的情况，如果worker不够了，master会启动多几个，如果空闲的太多了，停掉一些。这样一种方法，**比起CGI执行，省去了大量的启动、销毁线程的时间和节约了大量的资源**。

修改php.ini后，FastCGI可以平滑的重启（执行`php-fpm reload`）。php-cgi进程是没办法平滑重启的，需要restart。

# Cookie与Session

Cookie与Session都属于**会话跟踪技术**。理论上，一个用户的所有请求操作都应该属于同一个会话。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭（指非长连接情况下），再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。目前Cookie已经成为标准，所有的主流浏览器都支持Cookie（需要浏览器的支持：保存、更新、发送、删除。不同的浏览器保存Cookie的方式不同）。

**查看网站Cookie的简单方式**

直接在浏览器地址栏中输入

```
javascript:alert(document.cookie)
```

## Cookie

**修改Cookie**

**要想修改Cookie只能使用一个同名的Cookie来覆盖原来的Cookie**。**删除时只需要把maxAge修改为0即可**（Cookie并不提供直接的修改、删除操作）。修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。
从客户端读取Cookie时，包括maxAge在内的其他属性都是不可读的，也不会被提交。**浏览器提交Cookie时只会提交name与value属性**。maxAge属性只被浏览器用来判断Cookie是否过期。

**Expires**

Cookie的Expires属性标识了Cookie的有效时间，当Cookie的有效时间过了之后，这些数据就被自动删除了。默认情况下Cookie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户退出浏览器后这些值也会丢失，如果想让Cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。

**max-age**

expires属性现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。

**path**

`path属性`决定允许访问Cookie的路径。页面只能获取它属于的Path的Cookie。例如/session/test/a.php不能获取到路径为/session/abc/的Cookie。

**secure**

如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的`secure属性`为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。
W3C标准的浏览器会阻止JavaScript读写任何不属于自己网站的Cookie。

**临时性Cookie**

`maxAge`为负数的Cookie，为**临时性Cookie，不会被持久化，不会被写到Cookie文件中**。Cookie信息**保存在浏览器内存中**，因此关闭浏览器该Cookie就消失了。Cookie默认的maxAge值为-1。

## Session

Session在用户第一次访问服务器的时候`自动创建`。Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是**Session的超时时间**。如果超过了超时时间没访问过服务器，Session就自动失效了。
虽然Session保存在服务器，对客户端是透明的，**它的正常运行仍然需要客户端浏览器的支持**（如果使用Cookie来发送SessionID的话）。这是因为Session需要使用Cookie作为识别标志。**如果浏览器不支持Cookie，则需要依赖URL重写。**
URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。

## Cookie与Session的比较

* Session的使用比Cookie方便，但是过多的Session存储在服务器内存中，会对服务器造成压力。
* Cookie具有`不可跨域名性`（这里指全域名，而不是仅仅指根域名。同一个一级域名下的两个二级域名如www.demo.com和images.demo.com也不能交互使用Cookie，因为二者的域名并不严格相同。如果想所有demo.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数为`.demo.com`（以.开头），这样所有以`demo.com`结尾的域名都可以访问该Cookie。


* Cookie中使用Unicode字符时需要对Unicode字符进行编码（**Cookie中保存中文只能编码**，推荐使用UTF-8，因为JavaScript不支持GBK编码）。


* Cookie的内容应该少而精（由于浏览器每次请求服务器都会携带Cookie，因此Cookie内容不宜过多，否则影响速度）。


# cgi.fix_pathinfo配置项的作用是什么？

如果WebServer为Nginx，则须在PHP的配置文件php.ini中配置cgi.fix_pathinfo = 0，防止nginx文件解析漏洞。

在cgi.fix_pathinfo = 1的情况下，假设有如下的 URL：http://xxx.net/foo.jpg，当访问 http://xxx.net/foo.jpg/a.php 时，foo.jpg 将会被执行，如果 foo.jpg 是一个普通文件，那么 foo.jpg 的内容会被直接显示出来，但是如果把一段php代码保存为foo.jpg，那么问题就来了，这段代码就会被直接执行。



# mysqli的Prepared语句有什么好处？

mysqli支持prepared语句，好处有2：

* 对于在执行大量具有不同数据的相同查询时，可以提高执行速度（MySQL省去了部分解析工作）；
* 可以**避免SQL注入攻击**；

通常的数据库插入操作如下：

```php
<?php
$query = "insert into books values('".$isbn."','".$author."','".$title."','".$price."')";
$result = $db->query($query);
if($result){
echo $db->affected_rows;
...
```
Prepared语句的基本思想是**向MySQL发送一个需要执行的查询模板，然后再单独发送数据**。因此可以向相同的Prepared语句发送大量相同的数据，对于批处理的插入操作来说是非常有用的。
```php
<?php
$query = “insert into books values(?,?,?,?)”;
$stmt = $db->prepare($query);
$stmt->bind_param("sssd",$isbn,$author,$title,$price); 
$stmt->execute();
echo $smtt->affected_rows;
$stmt->close();
```
对于查询操作，也可以绑定查询结果至变量：
```php
<?php
$stmt->bind_result($isbn,$author,$title,$price);
```

# PHP中有哪几种表达字符串的方式？区别是什么？

一个字符串可以用4种方式表达（*茴香豆的四种写法*）：

* 单引号
* 双引号
* heredoc语法结构
* nowdoc语法结构（自 PHP 5.3.0 起） 

不像双引号和heredoc语法结构，**在单引号字符串中的变量和特殊字符的转义序列将不会被替换**。
要注意的是heredoc结束标识符这行除了可能有一个分号（;）外，绝对不能包含其它字符。这意味着标识符不能缩进，分号的前后也不能有任何空白或制表符。
就像heredoc结构类似于双引号字符串，**nowdoc结构是类似于单引号字符串的**（不进行解析操作、转义）。
字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1。

# PHP中的闭包无须像js（非ES6）一样通过self=this的形式来扩展作用域

```php
<?php
class Demo{
  private $list = [1,2,3,4,5,6,7,8,9,10];
  public $delList = [];
  
  public function test(){
    $arr = array_filter($this->list,function($n){
      if($n % 2 == 0){
        return true;
      }
      else{
        $this->delList[] = $n;  // 此$this指向Demo的对象，而非闭包函数
        return false;
      }
    });
    
    return $arr;
  }
}

$demo = new Demo();
$arr = $demo->test();
var_dump($arr);   // 1 3 5 7 9
var_dump($demo->delList); // 2 4 6 8 10
```

# PHP中那些函数是同步阻塞的？

## 同步阻塞函数

* mysql、mysqli、pdo以及其他DB操作函数

* sleep、usleep

* curl

* stream、socket扩展的函数

* swoole_client同步模式

* memcache、redis扩展函数

* file_get_contents/fread等文件读取函数

* swoole_server->taskwait

* swoole_server->sendwait

swoole_server的PHP代码中有上述函数，Server就是`同步服务器`。代码中没有上述函数就是`异步服务器`。

## 异步非阻塞函数

* swoole_client异步模式
* mysql-async库
* redis-async库
* swoole_timer_tick/swoole_timer_after
* swoole_event系列函数
* swoole_table/swoole_atomic/swoole_buffer
* swoole_server->task/finish函数

# PHP对象注入漏洞的原因是什么？

## 序列化与反序列化

PHP支持**对象的序列化和反序列化**操作（serialize、unserialize）。
如：

```php
<?php
class User{

  public $age = 0;
  public $name = '';

  public function PrintData(){
    echo 'User ' . $this->name . ' is ' . $this->age . ' years old. <br />';
  }
}

$usr = unserialize('O:4:"User":2:{s:3:"age";i:20;s:4:"name";s:4:"John";}');
$usr->PrintData();
```

输出：
```
User John is 20 years old. 
```
**当一个对象进行序列化和反序列化操作时也会自动调用其他相应的魔术方法**：

* 当对象进行序列化操作时魔术方法`__sleep()`会被自动调用（必须返回一个包含序列化的类变量名的数组）。
* 当对象进行反序列化操作时魔术方法`__wakeup()`会被自动调用。

## 反序列化存在的安全问题

攻击者可以**操作类变量**来攻击web应用，比如：

```php
<?php
$usr = unserialize('O:7:"LogFile":1:{s:8:"filename";s:9:".htaccess";}');
$usr->PrintData();
```
从而**意外地执行了LogFile的`__construct()`和`_destruct()`**。
在处理由用户提供数据的地方不要使用`unserialize()`，可以使用`json_decode(...)`。

# PHP支持哪些数据类型？

PHP共支持**8种原始数据类型**，其中包括：

* 4种标量类型：`boolean`、`integer`、`float（double）`、`string`
* 2种复合类型：`array`、`object`
* 2种特殊类型：`resource`、`NULL`

**double和float是相同的**，由于一些历史的原因，这两个名称同时存在。
变量的类型通常不是由程序员设定的，确切地说，是**由PHP根据该变量使用的上下文在运行时决定的**。 

# PHP的变量作用域规则是什么样的？

**6项基本的作用域规则**：

* `超级全局变量`（内置）可以在脚本的任何地方使用和可见。
* **`常量`一旦被声明，将全局可见**，即可以在函数内外使用。
* 在一个`脚本中声明的全局变量`在整个脚本中是可见的。
* 函数内部使用的变量声明为全局变量时，其名称要与全局变量一致。
* 在函数内部创建的`静态变量`，在函数外部不可见，但是可以在函数的多次执行中保持值。
* 在函数内部创建的非静态变量，当函数终止时就不存在了。

# SAPI

无论是Web模式还是Cli模式运行，PHP的工作原理都是一样的， 都是**作为一种SAPI在运行**（Server Application Programming Interface： *the API used by PHP to interface with Web Servers*）。**SAPI就是PHP和外部环境的代理器**。它把外部环境抽象后, **为内部的PHP提供一套固定的，统一的接口，使得PHP自身实现能够不受错综复杂的外部环境影响**，保持一定的独立性。

# PHP扩展程序的基本执行方式

**MINIT**

**在PHP随着Apache的启动而常驻在内存里时**， 会把自己所有已加载扩展的`MINIT方法`(全称Module Initialization，是由每个模块自己定义的函数)都执行一遍。 在这个时间里，扩展可以定义一些自己的常量、类、资源等所有会被用户端的PHP脚本用到的东西。 

**RINIT**

**当一个页面请求到来时候**，PHP会迅速的开辟一个新的环境，并重新扫描自己的各个扩展， 遍历执行它们各自的`RINIT方法`(俗称Request Initialization)， 这时候一个扩展可能会初始化在本次请求中会使用到的变量等， 还会初始化稍后用户端（即PHP脚本）中的变量之类的。

**RSHUTDOWN**

**当请求完成**（或者别die等终结），PHP便会启动回收程序，执行所有已加载扩展的`RSHUTDOWN`（Request Shutdown）方法， 这时候扩展可以抓紧利用内核中的变量表之类的做一些事情， 因为一旦PHP把所有扩展的RSHUTDOWN方法执行完， 便会释放掉这次请求使用过的所有东西， 包括变量表的所有变量、所有在这次请求中申请的内存等等。

**MSHUTDOWN**

**当Apache通知PHP自己要Stop的时候**，PHP便进入`MSHUTDOWN`（Module Shutdown）阶段。一旦PHP把扩展的MSHUTDOWN执行完，便会进入自毁程序，所以这里一定要把自己擅自申请的内存给释放掉。

**一个最简单的例子**

walu.c 
```c
int time_of_minit;  // 每次请求都不变
PHP_MINIT_FUNCTION(walu)
{
  time_of_minit=time(NULL);
  return SUCCESS;
}

int time_of_rinit;  // 每次请求都改变
PHP_RINIT_FUNCTION(walu)
{
  time_of_rinit=time(NULL);
  return SUCCESS;
}

// 每次页面请求都会往time_rshutdown.txt中写入数据
PHP_RSHUTDOWN_FUNCTION(walu)
{
  FILE *fp=fopen("/cnan/www/erzha/time_rshutdown.txt","a+");
  fprintf(fp,"%d\n",time(NULL));
  fclose(fp);
  return SUCCESS;
}

// 只有在apache结束后time_mshutdown.txt才写入有数据
PHP_MSHUTDOWN_FUNCTION(walu)
{
  FILE *fp=fopen("/cnan/www/erzha/time_mshutdown.txt","a+");
  fprintf(fp,"%d\n",time(NULL));
  return SUCCESS;
}

PHP_FUNCTION(walu_test)
{
  php_printf("%d&lt;br /&gt;",time_of_minit);
  php_printf("%d&lt;br /&gt;",time_of_rinit);
  return;
}
```

# PHP的生命周期

PHP扩展程序的两种init（MINIT、RINIT）和两种shutdown（RSHUTDOWN、MSHUTDOWN）各会执行多少次、各自的执行频率有多少**取决于PHP是用什么SAPI与宿主通信的**。最常见的四种SAPI通信方式如下：

## 1.直接以CLI/CGI模式调用

 PHP的生命周期完全在一个单独的请求中完成，两种init和两种shutdown仍然都会被执行。

 以`php -f test.php`为例，执行过程如下：

* （1）调用每个扩展的MINIT；

* （2）请求test.php文件；

* （3）调用每个扩展的RINIT；

* （4）执行test.php；

* （5）调用每个扩展的RSHUTDOWN；

* （6）执行清理操作；

* （7）调用每个扩展的MSHUTDOWN；

* （8）终止php；

 ## 2.多进程模块

如编译成Apache2的Pre-fork MPM，当Apache启动的时候，会立即把自己fork出好几个子进程，每一个进程都有自己独立的内存空间，在每个进程里的PHP的工作方式如下：

* （1）调用每个扩展的MINIT；
* （2）**循环**：{ a.调用每个扩展的RINIT;  b.执行脚本； c.调用每个扩展的RSHUTDOWN；}
* （3）调用每个扩展的MSHUTDOWN；

 ## 3.多线程模块

如IIS的isapi和Apache MPM worker，**只有一个服务器进程在运行着，但会同时运行很多线程**，这样可以减少一些资源开销，像Module init和Module shutdown就只需要运行一次就行了，一些全局变量也只需要初始化一次， 因为线程独具的特质，使得各个请求之间方便的共享一些数据成为可能。

## 4.Embedded(嵌入式，在自己的C程序中调用Zend Engine)

Embed SAPI是一种比较特殊但不常用的SAPI，允许在C/C++语言中调用PHP/ZE提供的函数。 这种SAPI和上面的三种一样，按Module Init、Request Init、Rshutdown、mshutdown的流程执行着。

# PHP配置中的open_basedir配置项的作用是什么？

open_basedir是PHP配置中为了**防御跨目录进行文件（目录）读写**的配置，所有PHP中有关文件读、写的函数都会经过open_basedir的检查。实际上是一些目录的集合，在定义了open_basedir以后，**PHP可以读写的文件、目录都将被限制在这些目录中**。在Linux下，不同的目录由`:`分割，如`/var/www/:/tmp/`。
注意用open_basedir指定的限制实际上是前缀，而不是目录名。

**Apache运行PHP有三种配置open_basedir的方法**

* （1）在php.ini里配置

`open_basedir = .:/tmp/`

* （2）在Apache配置的VirtualHost里设置(httpd-vhosts.conf)

`php_admin_value open_basedir .:/tmp/`

* （3）在Apache配置的Direcotry里设置

`php_admin_value open_basedir .:/tmp/`

**关于三个配置方法的解释**
（1）方法（2）的优先级高于方法（1），也就是说方法（2）会覆盖方法（1）；方法（3）的优先级高于方法（2），也就是说方法（3）会覆盖方法（2）；
（2）配置目录里加了`/tmp/`是因为PHP默认的临时文件（如上传的文件、session等）会放在该目录，所以一般需要添加该目录，否则部分功能将无法使用；
（3）配置目录里加了`.`是指运行PHP文件的当前目录，这样做可以避免每个站点一个一个设置；
（4）如果站点还使用了站点目录外的文件，需要单独在对应VirtualHost设置该目录；

# 使用数组、SplQueue实现队列的性能比较

PHP的SPL标准库中提供了内置的队列数据结构SplQueue。另外PHP的数组也提供了array_pop和array_shift可以使用数组模拟队列数据结构。
**虽然使用Array可以实现队列，但实际上性能会非常差**。在一个大并发的服务器程序上，建议使用SplQueue作为队列数据结构。
100万条数据随机入队、出队，使用SplQueue仅用2312.345ms即可完成，而使用Array模拟的队列的程序根本无法完成测试，CPU一直持续在100%，降低到1万条后，也需要260ms才能完成测试。

SplQueue
```php
<?php
$splq = new SplQueue;
for($i = 0; $i < 1000000; $i++){
  $data = "hello $i\n";
  $splq->push($data);

  if ($i % 100 == 99 and count($splq) > 100){
    $popN = rand(10, 99);
    for ($j = 0; $j < $popN; $j++){
      $splq->shift();
    }
  }
}

$popN = count($splq);
for ($j = 0; $j < $popN; $j++){
  $splq->pop();
}
```

Array队列
```php
<?php
$arrq = array();
for($i = 0; $i <1000000; $i++){
  $data = "hello $i\n";
  $arrq[] = $data;
  if ($i % 100 == 99 and count($arrq) > 100){
    $popN = rand(10, 99);
    for ($j = 0; $j < $popN; $j++){
      array_shift($arrq);
    }
  }
}
$popN = count($arrq);
for ($j = 0; $j < $popN; $j++){
  array_shift($arrq);
}
```

# Swoole的基本IO模型

## Swoole采用**多线程Reactor+多进程Worker**

* （1）Master进程启动一个Main Reactor线程和多个普通Reactor线程；

* （2）请求到达Main Reactor；

* （3）Main Reactor根据Reactor的情况，将请求注册给对应的Reactor(每个Reactor都有epoll，用来监听客户端的变化)

* （4）客户端有变化时，交给worker来处理；

* （5）worker处理完毕，通过进程间通信(比如管道、共享内存、消息队列)发给对应的reactor。

* （6）reactor将响应结果发给相应的连接。

* （7）请求处理完成；

因为reactor基于epoll，所以每个reactor可以处理无数个连接请求。如此，swoole就轻松的处理了高并发。



## **Swoole的worker进程有2种类型**

**一种是普通的worker进程，一种是task worker进程。**worker进程是用来处理普通的耗时不是太长的请求；task worker进程用来处理耗时较长的请求，比如数据库的I/O操作。以异步MySQL举例：

* （1）耗时较长的MySQL查询进入worker；
* （2）worker通过管道将这个请求交给task worker来处理；
* （3）worker再去处理其他请求；
* （4）task worker处理完毕后，处理结果通过管道返回给worker；
* （5）worker将结果返回给reactor；
* （6）reactor将结果返回给请求方；

如此，通过worker、task worker结合的方式，就实现了异步I/O。

# Swoole的生命周期

## Cli模式下PHP的基本工作方式

Swoole运行有个前提条件：**必需在Cli模式下执行**。

Cli下执行一个php文件时的关键步骤：

* （1）调用每个扩展的MINIT；

* （2）调用每个扩展的RINIT；

* （3）执行test.php；

* （4）调用每个扩展的RSHUTDOWN；

* （5）调用每个扩展的MSHUTDOWN；

**FPM每个请求都是在执行（2）~（4）步**。

**opcode cache是把第（3）步的词法分析、语法分析、生成opcode代码这几个操作给缓存起来了，从而达到加速的作用**。

## Swoole的生命周期

**Swoole在第（3）步接管了PHP**，进入swoole的生命周期，以多进程模式为例：

### （1）onStart()

在回调此函数之前Swoole Server已进行了如下操作：

- 创建了manager进程
- 创建了worker子进程
- 监听所有TCP/UDP端口
- 监听了定时器

**此函数是在主进程回调的**，和worker进程的onWorkStart是并行的没有先后之分，在此回调里强烈要求只做log记录，设置进程名操作，不做业务逻辑，否则业务逻辑代码的错误导致master进程crash，让整个swoole server不对对外提供服务了。

### （2）onWorkStart()

**每个worker或task进程在启动之后，会回调此函数**，由于此回调类似于fpm里的MINIT，所以可以在这里做一个全局的资源加载，框架初始化之类的操作，这样可以对每个请求做全局共享，而达到提升性能的目的。

### （3）onReceive()

**每个请求到达**（也称数据到达），会回调此函数，然后进行业务逻辑处理，输出结果

### （4）onWorkerStop()

**worker退出时**，会回调此函数。

### （5）onShutDown()

**Swoole服务停止**回调此函数，然后继续PHP的Cli工作步骤，进而退出PHP生命周期。



# 为什么PHP不做编译优化？

C程序通常一次编译，多次运行或长时间运行，因此在编译上多耗些时间、多做些优化被认为是值得的。而解释型语言往往作为胶水语言，也就是**完成一项用后即弃的特定任务**。官方的答复是，PHP程序运行时间往往很短暂，比如10ms；如果花100ms做编译优化，把运行时间压缩到1ms，总的时间消耗是101ms，反而更慢了（不考虑中间代码缓存）。



# 为什么在被包含文件中仍然要使用PHP起始标志？

当一个文件被包含时，**语法解析器在目标文件的开头脱离PHP模式并进入HTML模式，到文件结尾处恢复**。由于此原因，目标文件中需要作为PHP代码执行的任何代码都必须被包括在有效的PHP起始和结束标记之中。



# 为什么要关闭register_globals配置？

`register_globals`是php.ini里的一个配置，这个配置影响到PHP如何接收传递过来的参数。
register_globals的意思就是注册为全局变量，所以**当On的时候，传递过来的值会被直接的注册为（与HTML控件的name属性同名的）全局变量直接使用**，而Off的时候，需要到特定的全局变量数组里去得到它。




# 什么样的变量会被认为是NULL？如何判断？

特殊的NULL值表示一个变量没有值。**NULL类型唯一可能的值就是NULL**（不区分大小写）。在下列情况下一个变量被认为是 NULL： 

* 被赋值为 NULL
* 尚未被赋值
* 被unset() 

判断是否为NULL：`is_null()`
**递减NULL值也没有效果，但是递增NULL的结果是 1**。



# 使用Swoole时出现mysql server gone away的原因

**MySQL本身是一个多线程的程序**，每个连接过来，会开一个线程去处理相关的query，MySQL会定期回收长时间没有任何query的连接（时间周期受wait_timeout配置影响），由于**Swoole是一个长驻内存的服务**，建立了一个MySQL的连接，不主动关闭或者是用pconnect（持久连接）的方式，那么这个MySQL连接会一直保存着，然后长时间没有和数据库有交互，就主动被mysql server关闭了，之后继续用这个连接，就报mysql server gone away了。

## 解决方法

* 修改MySQL的`wait_timeout`值为一个非常大的值，此方法不太可取，可能会产生大量的sleep连接，导致MySQL连接上限了， 建议不使用。
* 每次query之前主动进行连接检测

如果是用mysqli，可用内置的mysqli_ping

```php
<?php
if (!$mysqli->ping()) {  
  mysqli->connect(); //重连
}
```

如果是pdo，可以检测mysql server的服务器信息来判断
```php
<?php
try {
  $pdo->getAttribute(\PDO::ATTR_SERVER_INFO);
}catch (\Exception $e) {
	if ($e->getCode() == 'HY000') {
		$pdo = new PDO(xxx);  //重连
	} else {
		throw $e;
	}
}
```
这个方案有个**缺点：额外多一次请求**，所以改进方法: 用一个全局变量存放最后一次query的时间，下一次query的时候先和现在时间对比一下，超过waite_timeout再重连，或者也可以用swoole_tick定时检测。

* 被动检测，每次query用try catch包起来，如有mysql gone away异常，则重新连接，再执行一次当前sql.

```php
<?php
try {
  query($sql);
} catch (\Exception $e) {
  if ($e->getCode() == 'HY000') {
    reconnect(); // 重连
    query($sql)
  } else {
    throw $e;
  }
}
```

* 用`短连接`，务必每次操作完之后，手动close；

# 哪些变量不能使用可变变量行为？

超全局变量不能用作可变变量。$this变量也是一个特殊变量，不能被动态引用。 



# 在PHP中基于yield实现简单的协程通信（双向异步信息传递）

包含yield关键字的函数比较特殊，返回值是一个`Generator对象`，**此时函数内语句尚未真正执行**。Generator对象是Iterator接口实例，可以通过rewind()、current()、next()、valid()系列接口进行操纵。Generator可以视为一种**“可中断”的函数**，而yield构成了一系列的“中断点”。

```php
<?php
function gen() {
  for($i=1;$i<=100;$i++) {
    // yield既是语句，又是表达式，既具备类似return语句的功能，同时也有类似表达式的返回值（通过send得到的值）
    $cmd = (yield $i);  
    if($cmd=='stop') {
      return;
    }
  }
}

$gen = gen();
$i=0;
foreach($gen as $item) {
  echo $item."\n";
  if($i>=10) {
    $gen->send('stop');  // 向Generator发送值
  }
  $i++;
}
```



# 如何控制数组json_encode后为json对象或者json数组？

```php
<?php
$foo = array(
  "item1" => (Object)[],  // 关键点：将Array转换成Object类型
  "item2" => []
);

echo json_encode($foo);
```
输出：
```php
{"item1":{},"item2":[]}
```



# 在方法中使用的$this一定指向该方法所从属的对象吗？

`$this`是一个到主叫对象的引用，通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象。

```php
<?php
class A{
  function foo(){
    echo get_class($this);
  }
}

class B{
  function bar(){
    // Note: the next line will issue a warning if E_STRICT is enabled.
    A::foo();
  }
}

$b = new B();
$b->bar();
```

输出：
```
B
```

# 在脚本文件中使用return，有哪些不同的场景和行为？

在脚本文件中使用return语言结构：

* 如果在全局范围中调用，则当前脚本文件中止运行；
* 如果当前脚本文件是被include的或者require的，则控制交回调用文件；且如果当前脚本是被include的，则return的值会被当作include调用的返回值。
* 如果当前脚本文件是在php.ini中的配置选项auto_prepend_file或者auto_append_file所指定的，则此脚本文件中止运行；

注意既然**return是语言结构而不是函数**，因此其参数没有必要用括号将其括起来。通常都不用括号，实际上也应该不用，这样可以降低 PHP 的负担。 如果没有提供参数，则一定不能用括号，此时返回 NULL。如果调用 return 时加上了括号却又没有参数会导致解析错误。



# 如何使用OpCache提高PHP应用的性能？

php.ini中加入：
```ini
; 开关打开
opcache.enable=1

; 可用内存, 酌情而定, 单位megabytes(M)
opcache.memory_consumption=256

; 最大缓存的文件数目, 命中率不到100%的话,可以试着提高这个值
opcache.max_accelerated_files=5000

; Opcache会在一定时间内去检查文件的修改时间, 这里设置检查的时间周期, 默认为2,单位为秒
opcache.revalidate_freq=240

; interned string的内存大小,也可调
opcache.interned_strings_buffer=8   

; 是否快速关闭, 打开后在PHP Request Shutdown的时候回收内存的速度会提高
opcache.fast_shutdown=1

; 不保存文件/函数的注释
opcache.save_comments=0
```

检查：
php -v
```
PHP 5.5.3-1ubuntu2.2 (cli) (built: Feb 28 2014 20:06:05) 
Copyright (c) 1997-2013 The PHP Group
Zend Engine v2.5.0, Copyright (c) 1998-2013 Zend Technologies
with Zend OPcache v7.0.3-dev, Copyright (c) 1999-2013, by Zend Technologies
```
注意其中多出了
```
with Zend OPcache v7.0.3-dev
```

需要提醒的是，**在生产环境中使用上述配置之前，必须经过严格测试**。 因为上述配置存在一个已知问题，它会引发一些框架和应用的异常， 尤其是在存在文档使用了备注注解的时候。

如果在更新代码之后，发现没有执行的还是旧代码，可使用函数opcache_reset()来清除缓存。

# 如何收集PHP的错误日志？

php在没有连接到数据库或者其他情况下会有提示错误，一般错误信息中会包含php脚本当前的路径信息或者查询的SQL语句等信息，这类信息暴露后，是不安全的，所以服务器建议禁止错误提示：
```
display_errors = Off
```
在关闭display_errors后为了能够把错误信息记录下来，便于查找服务器运行的原因,同时也要设置错误日志存放的目录，建议跟webserver的日志放在一起。
打开php.ini，安全加固配置方式如下，打开错误日志记录并设置错误日志存放路径：
```
log_errors = On

# 该文件必须允许webserver的用户和组具有写的权限
error_log = /usr/local/apache2/logs/php_error.log 
```

# 如何禁止在PHP中使用危险函数？
Web木马程序通常利用PHP的特殊函数执行系统命令，查询任意目录文件，修改文件等。
比如：
```php
<?php 
eval($_POST[cmd]);
?> 
```
其实就是使用了一些危险函数使得应用存在漏洞，最好的防范方式就是不允许使用这些函数。
打开php.ini，安全加固配置方式如下，禁止使用这些危险函数：
```ini
disable_functions = dl,assert,exec,popen,system,passthru,shell_exec,proc_close,proc_open,pcntl_exec
```



# 常量和变量有哪些不同？作用域是什么样的？

常量只能包含标量数据（boolean、integer、float和string）。可以定义resource常量，但应尽量避免，因为会造成不可预料的结果。

**常量和变量有如下不同**：
* 常量前面没有美元符号（$）；  
* 常量只能用 `define()函数`或`const关键字`定义；
* 用define定义的常量可以不用理会变量的作用域而在任何地方定义和访问；
* 常量一旦定义就不能被重新定义或者取消定义；
* 常量的值只能是标量；

如果使用了一个未定义的常量，PHP假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 "CONSTANT"）。**常量名区分大小写**。
```php
define("CONSTANT", "Hello world.");
echo CONSTANT; // Hello world.
echo Constant; // Use of undefined constant Constant - assumed 'Constant' in
```
如果只想检查是否定义了某常量，用 `defined()` 函数。 

**使用关键字const定义常量**：
```php
// 以下代码在 PHP 5.3.0 后可以正常工作
const CONSTANT = 'Hello World';
echo CONSTANT;
```
和使用define()来定义常量相反的是，**使用const关键字定义常量必须处于最顶端的作用区域**，**因为用此方法是在编译时定义的**。这就意味着**不能在函数内、循环内以及if语句之内用const来定义常量**:
```php
<?php

function fun(){
  const TEST = 1;
}
```

输出：

```
PHP Parse error:  syntax error, unexpected 'const' (T_CONST) in /usercode/file.php on line 4
```



# 打开allow_url_fopen、allow_url_include配置会有什么问题？

允许访问URL远程资源（就是允许fopen这样的函数打开url）使得PHP应用程序的漏洞变得更加容易被利用，php脚本若存在远程文件包含漏洞会使得攻击者直接获取网站权限及上传web木马。一般会在php配置文件中关闭该功能，若需要访问远程服务器建议采用其他方式如libcurl库。
```ini
allow_url_fopen = Off
allow_url_include = Off
```
比如有这样的代码：
```php
<?php
if(isset($HTTP_GET_VARS)){
  reset($HTTP_GET_VARS);
  while ( list($var, $val) = each($HTTP_GET_VARS) ) {
    $$var=$val;
  }
}
```
一些较偶然的场景会导致将**以http://开头的get参数所表示的远程文件**直接包含进来，然后执行。



# 有哪些通过PHP在Web服务器上执行命令的方式？

有4种主要的在Web服务器上执行命令的方法：
* `exec()`函数：没有直接的输出，将返回命令执行结果的最后一行
* `passthru()`函数：直接将输出显示到浏览器，如果输出是二进制，比如图片，这将是非常有用的
* `system()`函数：将命令的输出回显到浏览器，它将每一行的输出向后对齐
* 反引号``

更复杂的需求可以使用popen()、proc_open()、proc_close()，这些函数可以启动外部进程，并且在这些进程之间传递数据。

如果要把用户提交的数据包含在命令中，考虑到安全性问题，可以使用`escapeshellcmd`来阻止用户在系统上执行恶意的命令：
```php
system(escapeshellcmd($command));
```


# 有哪些魔术常量？
* `__LINE__` 文件中的当前行号
* `__FILE__` 文件的完整路径和文件名
* `__DIR__` 文件所在的目录 
* `__FUNCTION__` 函数名称（PHP 4.3.0 新加）
* `__CLASS__` 类的名称（PHP 4.3.0 新加）  
* `__TRAIT__`Trait 的名字（PHP 5.4.0 新加）  
* `__METHOD__` 类的方法名（PHP 5.0.0 新加）
* `__NAMESPACE__` 当前命名空间的名称（区分大小写）



# 用于属性重载的魔术方法有哪些？

在给不可访问属性赋值时，`__set()` 会被调用。 
读取不可访问属性的值时，`__get()` 会被调用。 
当对不可访问属性调用 isset() 或 empty() 时，`__isset()` 会被调用。 
当对不可访问属性调用 unset() 时，`__unset()` 会被调用。 
属性重载只能在对象中进行。**在静态方法中，这些魔术方法将不会被调用**。



# 用于方法重载的魔术方法有哪些？

在对象中调用一个不可访问方法时，`__call()` 会被调用。 
用静态方式中调用一个不可访问方法时，`__callStatic()` 会被调用。



# 为什么在声明静态变量时不能使用表达式进行赋值？

**静态变量的声明是在编译时解析的**，因此在声明静态变量时不能用表达式进行赋值：

```php
<?php
function foo(){
  static $int = 0;       	// ok
  static $int = 1+2;    	// error  (as it is an expression)
  static $int = sqrt(121);  // error  (as it is an expression too)

  $int++;
  echo $int;
}
```



# 能否将非对象类型转换为对象？如果可以，转换得到的对象有哪些属性？

* 如果将一个对象转换成对象，它将不会有任何变化。
* 如果其它任何类型的值被转换成对象，将会创建一个内置类`stdClass`的实例。
* 如果该值为NULL，则新的实例为空。
* 数组转换成对象将使键名成为属性名并具有相对应的值。
* 对于任何其它的值，名为`scalar`的成员变量将包含该值。 
```php
$a = (Object)'abc';
echo $a->scalar;  // abc
echo gettype($a); // object
```



# 被包含文件的搜索顺序是什么样的？

* （1）先按参数给出的路径寻找；
* （2）如果没有给出目录（只有文件名）时则按照`include_path`指定的目录寻找；
* （3）如果在include_path下没找到该文件则include最后才在**调用脚本文件所在的目录和当前工作目录下寻找**；
* （4）如果最后仍未找到文件则include结构会发出一条警告；这一点和require不同，后者会发出一个致命错误；
* （5）如果定义了路径，**不管是绝对路径还是当前目录的相对路径**，include_path都会被完全忽略；




# 包含文件的作用域关系

* （1）当一个文件被包含时，**其中所包含的代码继承了include所在行的变量范围**。从该处开始，**调用文件在该行处可用的任何变量在被调用的文件中也都可用**。不过**所有在包含文件中定义的函数和类都具有全局作用域**；

* （2）如果include出现于调用文件中的一个函数里，则**被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样**。所以它将遵循该函数的变量范围。此规则的一个例外是魔术常量，它们是在发生包含之前就已被解析器处理的；


