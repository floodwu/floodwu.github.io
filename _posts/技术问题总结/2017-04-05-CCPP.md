---
layout: post
title:  "问题总结：C&C++"
date: 2017-04-05 00:00:05
categories: 技术问题总结
tags: C++ C
excerpt: "这里所有的C、C++相关的面试题，全部来自于当初毕业时参加百度、微软、腾讯等公司的校园招聘的真实经历的总结。"
---

* content
{:toc}




# new、delete与malloc、free之间的联系和区别

## malloc/free和new/delete的联系
1. 存储方式相同。malloc和new动态申请的内存**都位于堆中**。申请的内存**都不能自动被操作系统收回**，都需要配套的free和delete来释放。
2. 除了带有构造函数和析构函数的类等数据类型以外，**对于一般数据类型，如int、char等等，两组动态申请的方式可以通用**，作用效果一样，只是形式不一样。
3. 内存泄漏对于malloc或者new都是可以检查出来的，区别在于new可以指明是哪个文件的哪一行，而malloc没有这些信息。
4. 两组都需要配对使用，malloc配free，new配delete。在C++中，两组之间不能混着用（虽说有时能编译过，但容易存在较大的隐患）。

## malloc/free和new/delete的区别
1. malloc返回void类型指针，free的形参为void指针，new和delete直接带具体类型的指针。
2. malloc和free属于C语言中的**函数**，需要库的支持，而new/delete是C++中的**运算符**，况且可以重载，所以**new/delete的执行效率高些**。
3. 在C++中，**new是类型安全的**，而malloc不是。例如：

```c
// 编译时指出错误
int* p = new char[10];  

//对数组需要加中括号“[]”
delete [] p;  

// 编译时无法指出错误
int* p = malloc(sizeof(char)*10); 

//只需要所释放内存的头指针（free释放malloc分配的数组）。在malloc和free的面前没有对象没有数组，只有“内存块”。一次malloc分配的东西，一次free一定能回收。至于内存块的大小内存管理会进行记录，这应该是库函数的事。free的真正弊端在于它不会调用析构函数。
free (p);  
```
4. 使用new动态申请类对象的内存空间时，类对象的构建要调用构造函数，相当于对内存空间进行了初始化。而**malloc动态申请的类对象的内存空间时，不会初始化**，也就是说申请的内存空间无法使用，因为类的初始化是由构造函数完成的。
5. 不能用malloc和free来完成类对象的动态创建和删除。

## calloc、realloc：

```c
void *calloc(int n,int size);
```
函数返回值为void型指针。如果执行成功，函数从堆上获得size * n的字节空间，并返回该空间的首地址。如果执行失败，函数返回NULL。**该函数与malloc函数的一个显著不同时是，calloc函数得到的内存空间是经过初始化的，其内容全为0**。calloc函数适合为数组申请空间，可以将size设置为数组元素的空间长度，将n设置为数组的容量。

realloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能，其函数声明如下：
```c
void * realloc(void * p,int n);
```
其中，指针p必须为指向堆内存空间的指针，即由malloc函数、calloc函数或realloc函数分配空间的指针。realloc函数将指针p指向的内存块的大小改变为n字节。如果n小于或等于p之前指向的空间大小，那么。保持原有状态不变。如果n大于原来p之前指向的空间大小，那么，系统将重新为p从堆上分配一块大小为n的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p之前指向的空间被释放。**relloc函数分配的空间也是未初始化的**。

注意：使用malloc函数，calloc函数和realloc函数分配的内存空间都要**使用free函数或指针参数为NULL的realloc函数来释放**。



# 为什么不建议让异常离开析构函数？

程序抛出异常时候，会导致栈展开，局部对象依次析构。**如果析构过程中再次抛出异常，程序将会立即中止**。



# 使用define定义一年有多少毫秒

```
#define MS_OF_YEAR (365*24*60*60*1000)UL
```
（对于整数溢出的考虑）



# 使用define定义max函数

```c++
#define MAX(a,b)  (a)>(b)?(a): (b)
```
（对于define中()使用的把握）
例：
```
#define TEST1 a+b
#define TEST2 (a+b)
void main(void)
{
    int a, b, c, d;
    c = TEST1;       //相当于 c = a+b;
    d = TEST2;       //相当于 d = (a+b);
}
```
这样写是防止忽略运算符优先级而导致的错误。



# 关键字volatile的意义及使用场景

意思是volatile告诉编译器**不要持有变量的临时拷贝**;
场景可抽象为两个线程，线程1和线程2通过某种方式共享一个变量，线程1根据变量状态进行某种操作，但线程2有可能改变变量的值，由于线程1中对变量的值一直保存到寄存器中，就不会发现变量的改变，此时线程1会做出错误的行为，当然，这个问题也可以由锁进行同步，但会有较大的时间消耗，volatile可以较好的解决此问题。



# 写一个病毒

```c++
while(1){
  int *p = new int[ 10000000 ]；
}
```



# 如何避免同一头文件的多次include

`#ifndef … `或者 `#pragma once`
`#pragma once`是编译器相关的，就是说即使这个编译系统上有效，但在其他编译系统也不一定可以，不过现在基本上已经是每个编译器都有这个杂注了。
`#ifndef，#define，#endif`是C/C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式。



# 字节对齐理解

在结构中，编译器为结构的每个成员按其**自然边界**（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。
**为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的对齐**。比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除。
对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而**非标准数据类型按下面的原则对齐**：

* 数组：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。 
* 联合：按其包含的长度最大的数据类型对齐。 
* 结构体：结构体中每个数据类型都要对齐。

  比如有如下一个结构体：
```c
struct stu{
  char sex;
  int length;
  char name[10];
};
struct stu my_stu;
```
由于**在x86下，GCC默认按4字节对齐**，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们sizeof(my_stu)会得到长度为20，而不是15。
 ![image](/images/tech/img_4.png)

**需要字节对齐的根本原因在于CPU访问数据的效率问题**。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。



# 对一个包含虚函数成员的对象bzero()会有什么问题？

**对包含虚函数成员的对象bzero会破坏该对象的虚函数表（VTABLE）**，调用该虚函数时将core。
原型：
```c
extern void bzero（void *s, int n）;
```
用法：
```c
#include <string.h>
```
功能：置字节字符串s的前n个字节为零且包括`\0`。 

说明：bzero无返回值，并且使用strings.h头文件，strings.h曾经是posix标准的一部分，但是在POSIX.1-2001标准里面，这些函数被标记为了遗留函数而不推荐使用。在POSIX.1-2008标准里已经没有这些函数了。推荐使用memset替代bzero。



# 常量存储器与栈空间

在函数体内声明
```
[1] char *str="abc";
[2] char str[]={'a','b','c'};
```
有什么区别？

* \[1\]\[2\] 中str变量都分配在栈上
* [1] 中str指向常量存储区的字符串”abc”，其中字符串末尾会补0
* [2] 中str数组的内容存储于栈空间，数组大小为3，字符串不会补0



# 异或操作总结
```
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
1 ^ 1 = 0
0 ^ a = a
```
代码验证：
```
int a = 123, b = 456;
a ^ b = 435;
a ^ b ^ a = 456 (b)
a ^ b ^ b = 123 (a)
```
应用：不用临时变量交换两值：
```
a = a ^ b
b = b ^ a 
a = a ^ b
```



# `int *p[5]`和`int (*p)[5]`的区别
前者定义了指针的数组，后者定义了指向数组的指针



# 用C++实现一个不能被继承的类

**将构造函数和析构函数声明为私有函数，该函数就不可被继承**。同时为了该类可以被实例化，在类中定义一个静态函数，返回初始化的一个类对象。



# 结构体大小如何判断？

## 偏移量

偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。
由于存储变量时地址对齐的要求，编译器在编译程序时会**遵循两条原则**：

* 1.结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）
* 2.结构体大小必须是所有成员大小的整数倍。

此外：**结构体变量的首地址能够被其最宽基本类型成员的大小所整除**；
因此**不同的定义顺序会影响到结构体的大小**：

```c
struct s{
  char c;
  int i;
  char cc;
};  // 大小为12

struct s{
  char c;
  char cc;
  int i;
}; // 大小为8
```
当结构体中的成员又是另外一种结构体类型时，只需要把其展开，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。

## 基本数据类型所占字节数

```
类型                  字节
char                  	1
short int             	2
int                   	2(16bit)/4(32bit)/4(64bit)
long                  	4(16bit)/4(32bit)/8(64bit)
指针变量              	 4
float                 	4
double                	8
long long             	8
long double           	10
```
各种数据类型所占字节长度，主要是int型,long型和指针数据类型的差异。
* int型数据，如果是16bit平台,则是2个字节，如果是32bit的，则占4个字节,64bit仍然是4字节。
* long型数据，如果是16bit平台,则是4个字节，如果是32bit的，则占4个字节,64bit仍然是8字节。
* 指针型数据，比较特殊，大多是4个字节，只有在16bit平台，并且指针式段内寻址时才是2个字节。

另外注意：sizeof(表达式)这样的使用，sizeof是给出其操作数所需要占用的内存大小，在编译时就可以确定。因此不需要去计算表达式的值；
因此有：
```c
int i = 3;
cout << sizeof(i++) << endl;
cout << i << endl;
```
输出4,3。i++根本没有执行。
![image](/images/tech/img_3.png)

# 虚函数和纯虚函数的区别

定义一个函数为虚函数，不代表函数为不被实现的函数，定义它为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为纯虚函数，才代表函数没有被实现，定义他是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 
**虚函数有实现，纯虚函数没有方法的实现**。包含纯虚函数的类将成为抽象类，不可实例化对象。纯虚函数必循在其子类中进行重写，不然其子类也成为抽象类。不能实例化对象。



# 虚基类成员的可见性

假定通过多个派生路径继承名为X的成员，有下面三种可能性：

* 如果在每个路径中 X 表示同一虚基类成员，则没有二义性，因为共享该成员的单个实例。
* 如果在某个路径中 X 是虚基类的成员，而在另一路径中 X 是后代派生类的成员，也没有二义性——特定派生类实例的优先级高于共享虚基类实例。
* 如果沿每个继承路径 X 表示后代派生类的不同成员，则该成员的直接访问是二义性的。

像非虚多重继承层次一样，这种二义性最好用在派生类中提供覆盖实例的类来解决。
**特殊的初始化语义**：通常，每个类只初始化自己的直接基类。如果使用常规规则，就可能会多次初始化虚基类。类将沿着包含该虚基类的每个继承路径初始化。为了解决这个重复初始化问题，从具有虚基类的类继承的类对初始化进行特殊处理。在虚派生中，由最低层派生类的构造函数初始化虚基类。虽然由最低层派生类初始化虚基类，但是任何直接或间接继承虚基类的类一般也必须为该基类提供自己的初始化式。只要可以创建虚基类派生类类型的独立对象，该类就必须初始化自己的虚基类，这些初始化式只有创建中间类型的对象时使用。




# 试图用宏开始或结束一段注释是不行的

```c
#define  BSC   //       
#define  BMC  /*    
#define  EMC  */
```
* （1）BSC my single-linecomment
* （2）BMC my multi-linecomment  EMC
  （1）和（2）都错误，因为**注释先于预处理指令被处理**，当这两行被展开成`//…`或`/*…*/`时,注释已处理完毕此时再出现`//…`或`/*…*/`自然错误.



# C++中模板的编译过程

* 第一遍扫描到模板定义时将token流存入语法树中，不做其它操作
* 第二遍当模板被实例化时用模板实参代入进行运算，将所有的模板参数换为实参进行语法和语义分析

特别需要注意的是**类模板的成员函数只有在调用的时候才会被实例化**。



# C++中虚函数的实现机制？

表面现象：虚函数是在类中被声明为virtual的成员函数，**当编译器看到通过指针或引用调用此类函数时，对其执行晚绑定**，即通过指针（或引用）指向的类的类型信息来决定该函数是哪个类的。

实现机制：**编译器对每个包含虚函数的类创建一个表（称为VTABLE）**。在VTABLE中，编译器放置特定类的虚函数地址。在每个带有虚函数的类中，编译器置一指针，称为vpointer（缩写为VPTR），指向这个对象的VTABLE。通过基类指针做虚函数调用时（也就是做多态调用时），编译器静态地插入取得这个VPTR，并在VTABLE表中查找函数地址的代码，这样就能调用正确的函数使晚捆绑发生。



# C++局部变量，全局变量，静态变量的作用域，生命期？

C++变量根据定义位置的不同，具有不同的作用域，作用域可分为6种：全局作用域，局部作用域，语句作用域，类作用域，命名作用域和文件作用域。

## 从作用域看

* 全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。
* 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在，他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
* 局部变量：也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。
* 静态全局变量：也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他**作用于定义它的文件里，不能作用到其他文件里**，即被static关键字修饰过的变量具有**文件作用域**。这样即使两个不同的源文件都定义了相同的静态全局变量，他们也是不同的变量。

## 从分配内存空间看

全局变量、静态局部变量、静态全局变量都在**静态存储区**分配空间，而局部变量在**栈**分配空间。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上没有什么不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

* 静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与堆栈变量和堆变量的区别
* 变量用static告知编译器，自己仅仅在变量的作用域范围内可见。这一点是他与全局变量的区别。

从以上分析可以看出，**把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围，因此static这个说明符在不同的地方起的作用是不同的**。

**TIPS**
* 若全局变量仅在单个文件中访问，则可以讲这个变量修改为静态全局变量。
* 若全局变量仅在单个函数中使用，则可以将这个变量修改为该函数的静态局部变量。
* 全局变量、静态局部变量、静态全局变量都存放在静态数据存储区。
* 函数中必须要使用static变量的情况：当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。



# char的整型运算
```c
char a = '5';
char b = '6';
cout << a+b << endl;  // 输出107
a = a - '0';
cout << a << endl;  // 输出 ♣
```

**附：ASCII码**
```
0:48、A:65、a:97
'A' == 'a'-32
```



# define中为何经常会使用 do{...}while(0);来包装多条语句代码

`do{...}while(0)`的目的是为了在for循环和if语句时，避免出现下面的情况：

```c++
#define xxx  i++; i--;
for (I = 0 ; I < 10; I ++) xxx;
```
展开后变为
```c++
for ( I = 0 ; I < 10; I ++ ) I ++; I --;
```
(对define中do{}while(0)的理解)



# define的一些注意点

* `#define SQR(x) printf("Thesquareof x is%d.\n",((x)*(x)))`;

如果这样使用宏：
```
SQR(8);
```
则输出为：
```
The squareof x is 64.
```
注意，**引号中的字符x被当作普通文本来处理，而不被当作一个可以被替换的语言符号**。假如确实希望在字符串中包含宏参数，那就可以使用`#`，它可以把语言符号转化为字符串。上面的例子改一改：
```
#define  SQR(x)   printf("The  squareof   "#x"   is%d.\n",((x)*(x)));
```
再使用：
```
SQR(8);
```
则输出的是：  
```
The  squareof   8   is  64.
```

* 求两个数的平方
```
#define SQR(x)  x * x
```
假设x的值是个表达式`10+1，SQR(x)`被替换后变成`10+1*10+1`这并不是想要得到的。括起来就好了：
```
#define SQR(x) （（x）*（x））
```
求两个数的和：
```
#define SUM (x)（x）+（x）
```
而代码又写成这样：
```
SUM (x)* SUM (x)
```
替换后变成：
```
（5*3）+（5*3）*（5*3）+（5*3）
```
所以又错了！所以最外层的括号最好也别省了。
要搞定宏定义表达式其实很简单，别吝啬括号就行了。
注意这一点：**宏函数被调用时是以实参代换形参。而不是值传送**。

* 和#运算符一样，**##运算符可以用于宏函数的替换部分**。这个运算符把两个语言符号组合成单个语言符号。看例子： 
```
#define  XNAME(n)  x##n
```
如果这样使用宏：`XNAME(8)`
则会被展开成这样：`x8` 
`##`就是个粘合剂，将前后两部分粘合起来。

# static、const、volatile、typeof关键字的用途描述

* static：静态函数、静态变量、静态类成员
* const：const变量，const指针、const函数
* volatile：多线程共享变量
* typeof：获取类型值

# std::vector实现原理及特定场景下的改进
* 说一下std::vector的实现原理，主要讲一下和内存管理相关的内容
* 常驻内存程序，一个std::vector的生命周期和程序生命周期相同，且会频繁的调用std::vector的push_back()和clear()方法，调用clear()方法时，vector.size()小于1万的概率为0.95,vector.size()可能出现的最大值为100万。如果程序中有多个这样的std::vector实例，程序长期运行后，会导致内存持续增长，一定时间后，可能将内存耗尽。请问，如何用较小的代价修改vector的设计，来避免内存持续增长问题。
  答：
* 内存不够用时，双倍扩容。clear()时，不释放内存，以减少内存分配次数。
* 修改clear()方法，当vector.size() 大于1万时，释放内存。

# STL中的stable_sort()的时间复杂度是多少
`stable_sort()`使用的算法类似于自适应算法，当空间足够的时，时间复杂度是`O(nlogn)`；当空间比较紧张时，时间复杂度是`O(nlogn*logn)`。
