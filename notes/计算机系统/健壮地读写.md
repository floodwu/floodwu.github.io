# 健壮地读写

——《深入理解计算机系统》

RIO包（Robust I/O）会自动处理不足值的情况，实现方便、健壮和高效的I/O。

```c
// 无缓冲的输入函数
ssize_t rio_readn( int fd, void *usrbuf, size_t n ){
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while( nleft > 0 ){
        if( (nread = read(fd,bufp,nleft)) < 0 ){
        	if(errno == EINTR){  // 被信号打断（Interrupted）
        		nread = 0; // 再次调用read()
        	}
        	else{
        		return -1;
        	}
        }
        else if(nread == 0){ // EOF（已无可读数据，比如n大于文件的实际长度）
        	break;
        }
        nleft -= nread;
        bufp += nread;
    }
    return ( n - nleft );  // return >= 0
}

// 无缓冲输出函数
ssize_t rio_writen( int fd, void *usrbuf, size_t n ){
	size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while( nleft > 0 ){
    	if( (nwritten = write(fd,bufp,nleft)) <= 0 ){
    		if(errno == EINTR){  // 被信号打断（Interrupted）
        		nwritten = 0; // 再次调用write()
        	}
        	else{
        		return -1;
        	}
    	}
    	nleft -= nwritten;
        bufp += nwritten;
    }
    return n;
}

// 缓冲区格式
\#define RIO_BUFSIZE 8192
typedef struct {
	int rio_fd;        // 缓冲区描述符
	int rio_cnt;       // 缓冲区中未被读取字节数
	char *rio_bufptr;  // 下一个未读取字节的起始位置 
	char rio_buf[RIO_BUFSIZE];   // 缓冲区
} rio_t;

// 初始化缓冲区的函数（将一个已打开的文件描述符与一个缓冲区联系起来）
void rio_readinitb(rio_t *rp, int fd){
	rp->rio_fd = fd;
	rp->rio_cnt = 0;
	rp->rio_bufptr = rp->rio_buf;
}

// 带缓冲区的read函数
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n){
	int cnt;
	while( rp->rio_cnt <= 0 ){ // 当缓冲区为空时，则填充缓冲区
		rp->rio_cnt = read( rp->rio_fd, rp->rio_buf, sizeof(rp->rio_buf));
		if(rp->rio_cnt < 0){
			if(errno != EINTR){
				return -1;
			}
		}
		else if(rp->rio_cnt == 0){
			return 0;
		}
		else{
			rp->rio_bufptr = rp->rio_buf;
		}
	}

	cnt = n;
	if( rp->rio_cnt < n ){
		cnt = rp->rio_cnt;
	}
	memcpy(usrbuf,rp->rio_bufptr,cnt);
	rp->rio_bufptr += cnt;
	rp->rio_cnt -= cnt;
	return cnt;
}
```
一个文本行就是一个由\n结尾的ASCII码字符序列。假设要编写一个计算文本文件中文本行数的函数，如果使用read一次一个字节地从文件传送到用户存储器，通过检查每个字节来查找换行符，这种方式的缺点是效率太低，因为每读取文件中一个字节都要陷入内核。
```c
// 带缓冲区的输入函数（读文本行）
// 最多读maxlen-1个字节，余下的一个字节留给结尾的空字符
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen){
	int n,rc;
	char c,*bufp = usrbuf;

	for( n = 1; n < maxlen; n++){
		if((rc = rio_read(rp, &c, 1)) == 1){
			*bufp++ = c;
			if(c == '\n'){
				break;
			}
		}else if( rc == 0 ){
			if( n == 1 ){
				return 0;  // EOF no data
			}
			else{
				break;  // EOF some data was read
			}
		}
		else{
			return -1;  // Error
		}
	}
	*bufp = 0;
	return n;
}

// 带缓冲区的输入函数（读字节）
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n){
	size_t nleft = n;
	ssize_t nread;
	char *bufp = usrbuf;

	while( nleft > 0 ){
		if( (nread = rio_read(rp,bufp,nleft)) < 0 ){
			if( errno == EINTR){
				nread = 0;
			}
			else{
				return -1;
			}
		}
		else if(nread == 0){
			break;
		}
		nleft -= nread;
		bufp += nread;
	}
	return ( n-nleft );
}
```