# 工作队列的实现

工作队列可以把工作推后，交由一个内核线程去执行，因此可以运行在进程上下文中，允许重新调度甚至睡眠。因此，当需要用一个可以重新调度的实体来执行下半部处理的时候，比如需要获得大量内存、需要获取信号量、以及需要执行阻塞式的IO操作时，就应该选择工作队列。`它是唯一能够在进程上下文中运行的下半部实现机制，也只有它才可以睡眠`。

工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其他部分排到队列里的任务，它创建的这些内核线程称为工作者线程。驱动程序可以使用工作队列来创建一个专门的工作者线程来处理需要推后的工作。工作队列子系统提供了一个缺省的工作者线程events/n（n为CPU编号），以处理被推后的工作。除非一个驱动程序必须建立一个属于它自己的内核线程，否则最好使用缺省线程。

工作者线程用workqueue_struct表示，该结构内部维护了一个cpu_workqueue_struct的数组，数组的每一项对应系统中一个处理器。所有的工作者线程都是用普通的内核线程实现的，它们都要执行worker_thread()函数，在它初始化完成以后，这个函数执行一个死循环并开始休眠，当有操作被插入到队列里的时候，线程就被唤醒，并执行这些操作。工作用work_struct表示，每个处理器上的每种类型的队列（cpu_workqueue_struct的数组）都有一个该结构的链表，当一个工作者线程被唤醒时，它会执行它链表上的所有工作，执行完毕后就移除该工作，当链表上不再有对象时，它就会继续休眠。