# 自旋锁

Linux内核中最常见的锁是自旋锁，`自旋锁最多只能被一个可执行线程持有`，如果一个执行线程试图获得一个已经被持有的自旋锁，那么改线程就会一直进行`忙循环-旋转-等待锁重新可用`。如果锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。

自旋锁的初衷在于在短期内进行轻量级加锁。因为一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋（特别浪费处理器时间），所以`自旋锁不应该被长时间持有`。还可以采取另外的方式来处理对锁的争用，比如让请求线程睡眠，直到锁重新可用时再唤醒它，这样处理器就不必循环等待，可以去执行其他代码，但这也会带来额外的开销（两次上下文切换）。

自旋锁的实现与体系结构密切相关，代码往往通过汇编实现，基本使用形式如下：
DEFINE_SPINLOCK(mr_lock);
spin_lock(&mr_lock);
/* 临界区 */
spin_unlock(&mr_lock);

自旋锁可以使用在中断处理程序中，`在中断处理程序中使用自旋锁时，一定要在获取锁之前首先禁止本地中断`（当前处理器上的中断请求），否则中断处理程序就会打断正持有锁的内核代码，有可能会视图去争用这个已经被持有的自旋锁，于是造成死锁。