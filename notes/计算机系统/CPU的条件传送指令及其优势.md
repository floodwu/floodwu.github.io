# CPU的条件传送指令及其优势

实现条件操作的传统方法是利用控制的条件转移，当条件满足时程序沿着一条执行路径进行，而当条件不满足时，就走另一条路径。这种机制比较简单，但在现代处理器上可能会非常低效。条件转移是一种替代策略：先计算一个条件操作的两种结果，然后再根据条件是否满足从而选取一个，只有在一些受限的情况下这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它。`条件传送指令更好地匹配了现代处理器的性能特性`。

使用条件表达式实现absdiff函数：
```C
int absdiff(int x,int y){
	return x < y ? y-x :x-y;
}
```
生成的汇编代码如下：
```
  movl 8(%ebp),%ecx          获取x
  movl 12(%ebp),%edx         获取y
  movl %edx,%ebx             复制y
  subl %ecx,%ebx             计算y-x
  movl %ecx,%eax             复制x
  subl %edx,%eax             计算x-y，并设置为返回值
  cmpl %edx,%ecx             比较x，y
  cmovl %ebx,%eax            如果<，则将返回值替换为y-x    !!! 仅需一条指令图（条件传送指令）
```
以上汇编代码类似于如下的C语言代码：
```
  int tval = y-x;
  int rval = x-y;
  int test = x<y;

  // 只需一条指令
  if(test) {
    rval = tval;
  }

  return rval;
```
基于条件数据传送的代码比基于条件控制转移的代码性能好，原因在于：现代处理器使用流水线方式来执行指令，这种方式通过重叠连续指令的步骤来获得高性能，例如正在取一条指令的时候执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行指令的序列，这样才能够保持流水线中充满了待执行的指令。当机器遇到条件跳转时，它常常还不能确定是否会进行跳转，处理器使用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行，如果它的猜测比较可靠，指令流水线中就会充满着指令，但是如果猜测错误，则处理器要丢掉它为该跳转指令后所有指令已经做了的工作，然后再开始从正确位置处起始的指令去填充流水线。这样一个错误的预测会导致大约20~40个时钟周期的浪费。
与条件跳转不同，处理器可以执行条件传送而无需预测测试的结果，处理器只是读源值，检查条件码，然后要么更新目的寄存器，要么保持不变。
使用条件传送也不是总会改进代码的效率，如果条件求值需要大量的计算，那么当相应的条件不满足时，这些工作就白费了。对gcc的实验表明，只有当两个表达式都很容易计算时（即所谓的受限情况）它才会使用条件传送。