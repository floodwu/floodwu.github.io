# 系统调用

在Linux中，`系统调用是用户空间访问内核的唯一手段`，除异常和陷入外，它们是内核唯一的合法入口。一般情况下，应用程序通过在用户空间实现的应用编程接口（API），而不是直接通过系统调用来编程。调用printf()函数时，应用程序、C库和内核之间的关系：
![image](https://github.com/woojean/woojean.github.io/blob/master/images/linux_1.png)
用户程序通过包含标准头文件并和C库链接，就可以使用系统调用。

## 系统调用号
在Linux中，每个系统调用都被赋予一个系统调用号（一个操作系统应该提供哪些接口，由POSIX标准规定），用来指明到底是要执行哪个系统调用，进程不会提及系统调用的名称。内核中有一个名为sys_call_table的系统调用表，记录了所有已注册的系统调用，并为其指定唯一的系统调用号。

## 系统调用处理程序
触发系统调用
因为内核驻留在受保护的地址空间上，用户空间进程无法直接执行内核代码，因此需要一种通知内核进行系统调用的方式。`通知内核的机制基于软中断实现`：通过引发一个异常来促使系统切换到内核态去执行异常处理程序，`此时的异常处理程序实际上就是系统调用处理程序`。
在x86上预定义的软中断号是128，通过int $0x86指令（中断指令）触发该中断后，将执行第128号异常处理程序，而该程序正是系统调用处理程序system_call()。

## 指定系统调用
在x86上，系统调用号通过eax寄存器传递给内核：在陷入内核之前，用户空间就把相应系统调用所对应的系统调用号放入eax中，这样系统调用处理程序一旦运行，就可以从eax中得到数据。

## 参数传递
在x86系统上，ebx、ecx、edx、esi、edi按照顺序存放前5个参数，当需要6个及以上参数时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。

## 返回值
给用户空间返回值也通过寄存器传递，在x86系统上它存放在eax寄存器中。

## 系统调用的实现
（如何编写、添加一个系统调用（不提倡），略）
系统调用上下文
内核在执行系统调用的时候处于进程上下文，current指针指向当前任务，即引发系统调用的那个进程。在进程上下文中，内核可以休眠，并且可以被抢占。当系统调用返回时，控制权仍然在system_call()中，它最终会负责切换到用户空间，并让用户进程继续执行下去。