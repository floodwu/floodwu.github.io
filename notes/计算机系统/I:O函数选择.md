# I/O函数选择

标准的I/O函数是磁盘和终端设备I/O之选，大多数情况下不会涉及低级的Unix I/O函数。但是当试图对网络输入输出使用标准I/O时会有问题，Unix对网络的抽象是套接字文件类型，也使用文件描述符来引用，称为套接字描述符。标准I/O流是全双工的，因为程序能够在同一个流上进行输入和输出，但是对于套接字流会有限制：
1.如果中间没有插入对fflush、fseek、fsetpos或者rewind的调用，输入函数不能跟在输出函数之后；
2.如果中间没有插入对fseek、fsetpos或者rewind的调用，输出函数不能跟在输入函数之后，除非该输入函数遇到了一个EOF；
但是对套接字使用fseek、fsetpos、rewind等函数是非法的。限制1可以通过采用在每个输入操作前刷新缓冲区来满足，如果使用标准I/O解决限制2的唯一办法是：对同一个打开的套接字描述符打开两个流，一个用来读，一个用来写。但是这样会带来另一个问题，因为程序必须在两个流上都调用fclose才能释放与每个流相关联的存储器资源，避免存储器泄露，但是当第一个关闭操作执行后，第二个关闭操作就会失败。对于顺序执行的程序这不是问题，但是在多线程的程序中关闭一个已经关闭了的描述符会导致灾难。
因此，在网络套接字上不要使用标准的I/O函数来进行输入和输出，而应该使用健壮的比如RIO函数。

可以使用dup2函数实现重定向：
int dup2( int oldfd, int newfd );
基本原理是拷贝文件描述符表中oldfd的内容到newfd，使得两个描述符都指向相同的文件表项，从而实现输出数据的重定向。