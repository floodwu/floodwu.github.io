# 虚拟存储器工作原理

虚拟存储器是系统提供的一种对主存的抽象，为每个进程提供了一个大的、一致的、私有的地址空间。
注意：这里“私有”指的是每个进程的虚拟内存空间是私有的，但是不同进程的虚拟内存空间中的地址可能指向相同的物理地址。

## 物理寻址与虚拟寻址
物理主存被组织成一个由连续字节组成的数组，每个字节都有一个唯一的物理地址。早期的CPU使用物理寻址，即CPU通过存储器总线直接读取主存上特定物理地址的内容到寄存器中。现代处理器使用虚拟寻址方式，通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址（地址翻译）。CPU上的存储器管理单元（MMU）利用存放在主存中的查询表（页表）来动态地翻译虚拟地址，该表的内容由操作系统管理。

虚拟存储器提供3个重要的功能：
1.在主存中自动缓存最近使用的存放在磁盘上的虚拟地址空间的内容。
2.虚拟存储器简化了存储器管理，进而简化了链接、在进程间共享数据、进程的存储器分配以及程序加载。
3.虚拟存储器通过在每条页表条目中加入保护位，从而简化了存储器保护。


## 虚拟存储器作为存储器保护的工具
每个PTE（页表条目，Page table entity）中有3个位用于实现存储器保护：
1.SUP位表示进程是否必须运行在内核模式下才能访问该页，运行在用户模式中的进程只能访问那些SUP为0的页面；
2.READ位控制对页面的读；
3.WRITE位控制对页面的写；
如果一条指令违反了这些许可条件，那么CPU将触发一个保护故障（段错误 segmentation fault），将控制传递给一个内核中的异常处理程序。


## 地址翻译
当页命中时，CPU硬件的执行步骤如下：
1.处理器生成一个虚拟地址，并把它传送给MMU；
2.MMU生成PTE地址，并从高速缓存/主存中请求得到它；
3.高速缓存/主存向MMU返回PTE；
4.MMU构造物理地址，并把它传送给高速缓存/主存；
5.高速缓存/主存返回所请求的数据字给处理器；
可见页命中完全是由硬件处理的。

当缺页时，需要硬件和操作系统内核协作完成，步骤如下：
1.处理器生成一个虚拟地址，并把它传送给MMU；
2.MMU生成PTE地址，并从高速缓存/主存中请求得到它’
3.高速缓存/主存向MMU返回PTE；
4.PTE中的有效位为零，所以MMU触发一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序；
5.缺页处理程序确定出物理存储器中的牺牲页，如果这个页已经被修改了，则把它换出到磁盘；
6.缺页处理程序调入新的页，并更新存储器中的PTE；
7.缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理存储器中，所以就会被命中，主存会将所请求的字返回给处理器。

在MMU中包括了一个关于PTE的小的缓存，称为TLB（翻译后备缓冲器）。在有TLB，且TLB命中的情况下，CPU的执行步骤如下：
1.处理器生成一个虚拟地址，并把它传送给MMU；
2.MMU从TLB中取出相应的PTE；
3.MMU构造物理地址，并把它传送给高速缓存/主存；
4.高速缓存/主存返回所请求的数据字给处理器；


## 存储器映射
现代系统通过将虚拟存储器片和磁盘上的文件片关联起来，以初始化虚拟存储器片，这个过程称为存储器映射，这为共享数据、创建新的进程以及加载程序提供了一种高效的机制。
（略）

## 动态存储器分配
动态存储器分配器维护着一个进程的虚拟存储器区域，称为堆。堆是一组不同大小的块的集合，每个块就是一个连续的虚拟存储器片，要么是已分配的，要么是空闲的。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式地执行，要么是存储器分配器自身隐式地执行，对应的分配器有两种风格：
1.显式分配器：要求应用显式地释放任何已分配的块，例如C中的malloc，free，C++中的new，delete；
2.隐式分配器：例如Java的垃圾回收机制；

碎片是造成堆利用率低的主要原因。有两种形式的碎片：
1.内部碎片：在一个已分配块比有效负荷大时发生，如为了满足字节对齐而额外分配的空间。
2.外部碎片：当空闲存储器空间合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生。

## 垃圾收集
垃圾收集器将存储器视为一张有向图，由堆节点组成，每个堆节点对应堆中一个已分配的块，当存在一条从任意根节点（根节点是一些不在堆中的位置，但是它们包含指向堆中的指针）出发并达到p节点的有向路径时，就说节点p是可达的，而不可达的节点就是垃圾，是不能被应用再次使用的。垃圾收集器的角色是维护可达图的某种表示，并通过释放不可达节点来定期地回收它们。