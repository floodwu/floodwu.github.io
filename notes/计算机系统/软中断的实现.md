# 软中断的实现

软中断保留给系统中对时间要求最严格以及最重要的下半部使用，目前只有两个子系统（网络、SCSI）直接使用软中断。此外，tasklet和内核定时器都是建立在软中断上的。
软中断是在编译期间静态分配的，不像tasklet那样能够被动态地注册或注销。软中断由softirq_action结构表示。softirq_vec数组是一个包含32个该结构体的数组，每个被注册的软中断都占据该数组的一项，因此最多可能有32个软中断，在当前版本的内核中这32个项中只用到了9个。

当内核运行一个软中断处理程序的时候，会执行softirq_handler()函数，其唯一的参数是指向softirq_vec某个softirq_action结构体的指针。

一个注册的软中断必须在被标记后才会执行，中断处理程序在返回前会标记它的软中断。在下列场景待处理的软中断会被检查和执行：
从一个硬件中断代码处返回时；
在ksoftirqqd内核线程中；
在那些显式检查和执行待处理的软中断的代码中，比如网络子系统；
软中断最终在do_softirq()中执行，该函数很简单，如果有待处理的软中断，则循环遍历每一个，并调用它们的处理程序。