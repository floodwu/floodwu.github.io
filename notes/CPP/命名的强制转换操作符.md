# 命名的强制转换操作符

标准 C++ 为了加强类型转换的可视性，引入命名的强制转换操作符：
1）dynamic_cast 支持运行时识别指针或引用所指向的对象。
2）const_cast将转换掉表达式的 const 性质。

```C++
const char *pc_str;
char *pc = string_copy(const_cast<char*>(pc_str));
```
只有使用 const_cast 才能将 const 性质转换掉。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了添加或删除 const 特性，用 const_cast 符来执行其他任何类型转换，都会引起编译错误。
3）static_cast：编译器隐式执行的任何类型转换都可以由 static_cast 显式完成
```C++
void* p = &d; // ok: address of any data object can be stored in a void*
// ok: converts void* back to the original pointer type
double *dp = static_cast<double*>(p);
```
4）reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。
旧式强制类型转换：在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：
```C++
char *pc = (char*) ip;
```
效果与使用 reinterpret_cast 符号相同，但这种强制转换的可视性比较差，难以跟踪错误的转换。
附：dynamic_cast<type-id>(expression)与 static_cast<type-id>(expression)的区别：
static_cast字面意思是静态转换，编译期间就能判断是否可以转换成功，但是无法识别兄弟指针之间的转换（先提升一个兄弟指针为父指针，再向下转换）而dynamic_cast是运行时转换，可以编译通过，但是可以与NULL指针的比较来判断是否转换成功！