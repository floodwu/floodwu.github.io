# 字节对齐

在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。
`为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”`。比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除。
对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而非标准数据类型按下面的原则对齐：
`数组` ：按照`基本数据类型`对齐，第一个对齐了后面的自然也就对齐了。 
`联合` ：按其包含的`长度最大的数据类型`对齐。 
`结构体`： 结构体中每个数据类型都要对齐。
  比如有如下一个结构体：
  struct stu{
    char sex;
    int length;
    char name[10];
  };
  struct stu my_stu;
由于在x86下，GCC默认按4字节对齐，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们sizeof(my_stu)会得到长度为20，而不是15。
 ![image](https://github.com/woojean/woojean.github.io/blob/master/images/img_4.png)

需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。