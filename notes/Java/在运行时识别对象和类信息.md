# 在运行时识别对象和类信息

Java主要有两种在运行时识别对象和类信息的方式：RTTI和反射。

## RTTI
使用RTTI可以查询某个基类引用所指向的对象的确切类型。每当编译一个新类，就会产生一个Class对象（属于Class类，被保存在类的.class文件中）。所有类都是在对其第一次使用时（第一次引用类的静态成员，构造函数也是静态成员）动态加载到JVM中。类加载器会首先检查当前被引用类的Class对象是否已经被加载，如果没有，则会根据类名查找对应的.class文件（其中包含了Class对象），并加载Class对象。`一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象`。

可以调用`Class.forName()`获取一个指定类名的类的Class对象的引用：
```
Class.forName("ClassName");
```
如果该类还没有被加载过，就加载它，在加载的过程中该类的static子句会被执行。

如果当前已经有了一个目标类的对象，则可以通过调用`getClass()`方法来获取Class对象的引用，这个方法定义在Object中。

Class类的API：
getName();           // 类的完全限定名（含包名）
getSimpleName();     // 简单类名
getCanonicalName();  // 和getName()一样
getInterfaces();     
getSuperclass();     // 返回直接基类
newInstance();       // 使用newInstance()来创建对象的类必须带有默认的构造器

## 类字面常量
可以不使用forName()方法，而直接使用类字面常量来获取对Class对象的引用：
```
ClassName.class;
```
使用这种方式的好处是在编译时就能够受到检查，因此不需要置于try语句块中。类字面常量还可以应用于接口、数组以及基本数据类型。

对于基本数据类型的包装器类，有一个TYPE字段，指向对应的基本数据类型的Class对象。即：
int.class等价于Integer.TYPE

为了使用类而做的准备工作实际包含三个步骤：
1.加载：类加载器查找字节码，并从字节码中创建一个Class对象；
2.链接：验证类中的字节码，为静态域分配存储空间，解析这个类对其他类的所有引用；
3.初始化：初始化超类，执行静态初始化器和静态初始化块；

注意：当使用.class来创建对Class对象的引用时，不会自动地初始化该Class对象，而Class.forName()立即就进行了初始化。

如果一个static final域被用“字面值常量”初始化(即编译期常量)，那么这个域无需对类进行初始化（意味着执行静态块）就可以被读取。否则仍然需要初始化。
对于非final的static域，总是要求在它被读取之前先进行链接和初始化。

## 泛化的Class引用
普通的类引用可以被重新赋值为指向任何其他的Class对象，而泛型类引用只能赋值为指向其声明的类型，所以通过使用泛型语法可以让编译器强制执行额外的类型检查。
```
Class<Integer> genericIntClass = int.class;
genericIntClass = Integer.class; // 与int.class一样
genericIntClass = double.class;  // 非法
```

注意泛型对子类型的限制，比如虽然Integer继承自Number，但是如下语句无法执行：
```
Class<Number> genericNumberClass = int.class;
```
因为Integer Class对象不是Number Class对象的子类。

泛型支持通配符：
```
Class<?> intClass = int.class;  // 与非泛型等效，但是更明确
intClass = double.class;
```

指定为特定类的子类：
```
Class<? extends Number> bounded = int.class;
bounded = double.class;  // OK
```

指定为特定类的超类：
```
Class<FancyToy> ftClass = FancyToy.class;
Class<? super FancyToy> up = ftClass.getSuperclass();
Object obj = up.newInstance();  // 将返回Object（因为无法确定是哪一个基类）
```

可以使用cast()方法进行引用转型：
```
class Building {}
class House extends Building {}
...
Building b = new House();
Class<House> houseType = House.class;
House h = houseType.cast(b);
h = (House)b;  // 效果一样
```

## instanceof
```
if( x instanceof Dog){  // 只能与类型做比较，而不能与Class对象做比较
  ((Dog)x).bark();
}
```

## Class.isInstance()
```
String s = new String("abcd");
System.out.println(String.class.isInstance(s)); // true
```

使用instanceof或Class.isInstance()进行判断时，会考虑类的继承关系，而使用Class对象进行比较时，没有考虑继承关系（父类型不等于子类型）。


## 反射
当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个类（和RTTI一样），然后加载那个类的Class对象（所以JVM必须能够获取该类的.class文件）。反射和RTTI之间真正的区别在于：对于RTTI，编译器在编译时打开和检查.class文件，而对于反射机制，.class文件在编译时是不可获取的，所以在运行时打开和检查.class文件。

```
import java.lang.reflect.*;

Class<?> c = Class.forName("...");
Method[] methods = c.getMethods();
Constructor[] ctors = c.getConstructors();
...
```

## 空对象
空对象是用来替代null的一种解决方案，空对象可以响应实际对象可以响应的所有消息（仍需要某种方式去测试其是否为空）。

## 绕过访问权限的操作
通过反射可以到达并调用所有方法，包括private方法（在Method对象上setAccessible(true)）。

对于编译后发布的代码，可以执行：
```
javap -private C
```
列出包括private成员在内的所有成员（包括私有内部类）。
不过，通过反射修改final域实际是无效的（也不会抛出异常）。