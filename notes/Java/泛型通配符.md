# 泛型通配符

Java中的数组是协变的，也是不安全的：

```
Fruit[] fruit = new Apple[10];  // 数组是协变的，可以向上转型
fruit[0] = new Apple();   // OK
fruit[1] = new Fruit(); // 编译不会报错，但运行时会报错，因为数组实际类型是Apple 
```

通配符的使用可以对泛型参数做出某些限制，使代码更安全。

通配符引用的是明确的类型（尽管其形式上类似普通边界可以接受一系列不同的类型）。
```
List<? extends Fruit> flist = new ArrayList<Apple>(); 
flist.add(new Apple());   // 编译错误
flist.add(new Fruit());   // 编译错误
flist.add(new Object());  // 编译错误
flist.add(null);   // 唯一可以添加的是 null
```
需要注意的是，flist却可以调用contains和indexOf方法，因为在ArrayList的实现中，add()接受一个泛型类型作为参数，但是contains和indexOf接受一个Object类型的参数。


## 无边界通配符
无边界通配符的使用形式是一个单独的问号：List<?>，也就是没有任何限定。
List<?> list 表示list是持有某种特定类型的List，但是不知道具体是哪种类型。`因为并不知道实际是哪种类型，所以不能添加任何类型`，这是不安全的。

## 逆变
可以使用超类型通配符来定义泛型参数的下界：
<? super MyClass>甚至<? super T>，
但是不能这样定义：
<T super MyClass>