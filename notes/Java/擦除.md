# 擦除

`在泛型代码内部无法获得任何有关泛型参数类型的信息`。擦除丢失了在泛型代码中执行某些操作的能力，任何在运行时需要知道确切类型信息的操作都无法进行。

```
public class Erased<T>{
  private final int SIZE = 100;
  public static void f(Object arg){
    if(arg instanceof T){             // error
      // ...
    }

    T var = new T();                  // error

    T[] array = new T[SIZE];          // error

    T[] array = (T)new Object[SIZE];  // Unchecked warning
  }
}
```

Java泛型使用擦除来实现，即在使用泛型时，任何具体的类型信息都被擦除了，因此List<String>和List<Integer>在运行时实际上是相同的类型：都被擦除成它们原生的类型，即List。

`泛型类型参数将擦除到它的第一个边界`（边界即使用extends对类型参数的范围做限制，可能会有多个边界），如下的边界：
```
<T extends HasF>
```
T将擦除到HasF，就好像在类的声明中用HasF替换了T一样。

Java的泛型之所以基于擦除来实现，是因为要兼容旧版本（Java1.0中没有泛型功能），因此泛型类型只有在静态类型检查期间才出现，在此之后程序中的所有泛型类型都将被擦除并替换为它们的非泛型上界。

有时必须通过引入类型标签来对擦除进行补偿，即显式地传递类型的Class对象以便在类型表达式中使用。
```
ClassTypeCapture<Building> ctt = new ClassTypeCapture<Building>(Building.class);
```