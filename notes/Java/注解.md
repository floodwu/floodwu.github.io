# 注解

通过使用注解可以将一些元数据保存在Java源代码中，并利用注解API来为自己的注解构造处理工具。

Java内置三种标准注解（定义在java.lang中）：
1.@Override；
2.@Deprecated：使用该注解将会使编译器发出警告信息；
3.@SuppressWarnings：关闭不当的编译器警告信息；

此外还有4种元注解：
1.@Target：表示注解可以用于什么地方（构造函数、域、局部变量、方法、包、参数、类、接口、枚举）
2.@Retention：表示在什么级别保存注解信息（源代码、class文件、运行时）
3.@Documented：将此注解包含在Javadoc中
4.@Inherited：允许子类继承父类中的注解

注解也会被编译成class文件。

## 定义、处理注解
示例：通过注解的方式跟踪项目中的用例（方法）实现情况
```java
import java.lang.annotation.*;

// 定义注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UseCase {
  public int id();
  public String description() default "no description";
}

// 使用注解
public class PasswordUtils {
  @UseCase(id = 47, description =
  "Passwords must contain at least one numeric")
  public boolean validatePassword(String password) {
    return (password.matches("\\w*\\d\\w*"));
  }
  @UseCase(id = 48)
  public String encryptPassword(String password) {
   return new StringBuilder(password).reverse().toString();
  }
  @UseCase(id = 49, description =
  "New passwords can't equal previously used ones")
  public boolean checkForNewPassword(
    List<String> prevPasswords, String password) {
    return !prevPasswords.contains(password);
  }
}

// 处理注解
public class UseCaseTracker {
  public static void trackUseCases(List<Integer> useCases, Class<?> cl) {
    for(Method m : cl.getDeclaredMethods()) {  // 反射获取方法列表
      UseCase uc = m.getAnnotation(UseCase.class);  // 获取方法的注解
      if(uc != null) {
        System.out.println("Found Use Case:" + uc.id() +
          " " + uc.description());
        useCases.remove(new Integer(uc.id()));
      }
    }
    for(int i : useCases) {
      System.out.println("Warning: Missing use case-" + i);
    }
  }
  public static void main(String[] args) {
    List<Integer> useCases = new ArrayList<Integer>();
    Collections.addAll(useCases, 47, 48, 49, 50);
    trackUseCases(useCases, PasswordUtils.class);
  }
}
```
注解的元素只能是基本类型、String、Class、enum、Annotation、或者以上类型的数组。
注解的值不能为null（即必须赋值且非null，或者有非null的默认值）。
注解不支持继承，即不能extends某个@interface。