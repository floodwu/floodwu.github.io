# MySQL数据类型选择

## 选择数据类型的几个简单原则
1.更小的通常更好；
2.简单就好：整型操作比字符型操作代价低；使用整型存储IP地址；
3.尽量避免NULL：可为NULL的列需要更多的存储空间，在索引优化时也更复杂（需要记录额外的字节）；（InnoDB使用单独的bit存储NULL值，这对于稀疏数据有很好的空间效率）

TIMESTAMP只使用DATATIME一半的存储空间，且会根据时区自动更新，但是它允许的范围要小很多（1970年开始）。

MySQL中的INTEGER、BOOL等只是基本类型的别名，如果用这些名字建表，SHOW CREATE TABLE仍然显示基本类型。

MySQL可以为整数类型指定宽度，例如INT(11),但这实际并不会限制值的合法范围，作用只是规定了MySQL的一些交互工具用来显示字符的个数，对于存储和计算来说，INT(1)和INT(20)是相同的（都是11位）。其他整型数同理。

TINYINT的存储空间为`8位`，存储值范围为-128~127，TINYINT UNSIGNED的存储范围是0~255；

VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于等于255，则只使用1个字节，否则使用2个字节，所以一个VARCHAR(10)的列需要11个字节的存储空间，VARCHAR(1000)的列则需要1002个字节。

## 比较适合使用VARCHAR类型的情况
1.字符串的最大长度比平均长度大很多；
2.列的更新很少；（更新导致长度变化，会有额外的更新操作）
3.使用了像UTF-8这样的复杂字符集，每个字符使用不同的字节数进行存储；

InnoDB可以把过长的VARCHAR存储为BLOB；

MySQL把BLOB和TEXT值当做独立的对象处理，当其太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

如果使用完全随机的字符串作为标识列，例如使用MD5值，会导致INSERT以及UPDATE语句变得很慢，原因可能有：
1.插入值会随机地写到索引的不同位置，使得INSERT语句更慢，会导致页分裂，磁盘随机访问，产生聚簇索引碎片；
2.SELECT会更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方；
3.随机值导致缓存对所有类型的查询语句效果都很差；（局部性原理失效）