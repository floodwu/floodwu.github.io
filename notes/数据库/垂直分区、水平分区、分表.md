# 垂直分区、水平分区、分表

## 垂直分区
对于数据库写操作频繁的站点，仅仅采用主从复制和读写分离效果并不好，因为从服务器将花费更多的时间用来同步数据，因此用来出来查询请求的时间就变少了，这时增加从服务器所获得的回报也将越来越小。

垂直分区：将不同业务的数据库（不需要JOIN查询）分不到不同的服务器上。

## 水平分区
水平分区：将同一个数据表中的记录通过特定的算法进行分离，分别保存在不同的数据表中，从而可以部署在不同的数据库服务器上。

比如原本有一个博客表，现在可以按照用户ID的奇偶性将所有用户划分为两部分，并分别存储到不同的数据库服务器上。当然在查询时需要额外传递用户ID参数用于进行奇偶性判断。
```
<?php
  // http://api.xxx.com/blog_post.php?post_id=123&user_id=321

  $db = new DataAccess($user_id);
  $db->selectDb("db_blog");
  $sql = "select * from tpl_posts where post_id=" . $post_id";
  $result = $db->query($sql);
```

## 分表
实际上在考虑水平分区之前一般会对数据库进行分表，比如按user_id%10将原来的表分为10个表。
分表属于单台数据库的优化策略，当已经实现了分表策略时，将可以更容易地实现水平分区，因为数据已经是分离的，只需要迁移到其他服务器。

分表算法和分区算法可能不一致（比如将分表得到的10个表分布在2台机器上），因此需要在应用程序中维护一份映射关系：
```
<?php 
  $db = new DataAccess($user_id);  // 分区逻辑
  $db->selectDb("db_blog");
  $tbl_name = getTblName($user_id); // 用户ID
  $sql = "select * from " .$tbl_name. " where post_id=" . $post_id";
  $result = $db->query($sql);
?>
```
显然用于分区的字段不能是auto_increment自增类型。

常见的分区算法有：
1.哈希，如user_id%10，这种方法不太友好，当扩展节点数时，所有数据需要重新分区；
2.范围，扩展性较好，但是会造成各个分区的工作量存在较大差异，比如老用户所在分区压力相对较大；
3.映射关系，将分区映射关系存到数据库中，当确定在哪个分区时，需要通过查询数据库（当然需要使用缓存）来获得答案；这种方案最可控；

## 分区反向代理
Spock Proxy基于MySQL Proxy实现，可以帮助应用程序实现水平分区的访问调度，意味着无需再在应用程序中维护那些分区对应关系。