# 如何分析MySQL语句的执行情况？

```
mysql> explain select * from t_online_group_records where UNIX_TIMESTAMP(gre_updatetime) > 123456789;
+----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table                  | type | possible_keys | key  | key_len | ref  | rows | `Extra`      |
+----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | t_online_group_records | ALL  | NULL          | NULL | NULL    | NULL |   47 | Using where |
+----+-------------+------------------------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.00 sec)
```
如上面例子所示，重点关注下type，rows和Extra：
`type`：`操作的类型`，可以用来判断有无使用到索引。结果值从好到坏：`... > range(使用到索引) > index > ALL(全表扫描)`，一般查询应达到range级别，具体可能值如下：
  `SYSTEM`	# CONST的特例，当表上只有一条记录匹配
  `CONST`	# WHERE条件筛选后表上至多有一条记录匹配时，比如WHERE ID = 2 （ID是主键，值为2的要么有一条要么没有）
  `EQ_REF`	# 参与连接运算的表是内表（在代码实现的算法中，两表连接时作为循环中的内循环遍历的对象，这样的表称为内表）。
基于索引（连接字段上存在唯一索引或者主键索引，且操作符必须是“=”谓词，索引值不能为NULL）做扫描，使得对外表的一条元组，内表只有唯一一条元组与之对应。
  `REF`		# 可以用于单表扫描或者连接。参与连接运算的表，是内表。
基于索引（连接字段上的索引是非唯一索引，操作符必须是“=”谓词，连接字段值不可为NULL）做扫描，使得对外表的一条元组，内表可有若干条元组与之对应。
  `REF_OR_NULL`		# 类似REF，只是搜索条件包括：连接字段的值可以为NULL的情况，比如 where col = 2 or col is null
  `RANGE`			# `范围扫描`，基于索引做范围扫描，为诸如BETWEEN，IN，>=，LIKE类操作提供支持
  `INDEX_SCAN`		# 索引做扫描，是基于索引在索引的叶子节点上找满足条件的数据（不需要访问数据文件）
  `ALL`				# `全表扫描`或者范围扫描：不使用索引，顺序扫描，直接读取表上的数据（访问数据文件）
  `UNIQUE_SUBQUERY`	# 在子查询中，基于唯一索引进行扫描，类似于EQ_REF
  `INDEX_SUBQUERY`		# 在子查询中，基于除唯一索引之外的索引进行扫描
  `INDEX_MERGE`		# 多重范围扫描。两表连接的每个表的连接字段上均有索引存在且索引有序，结果合并在一起。适用于作集合的并、交操作。
  `FT`				# FULL TEXT，`全文检索`
rows：SQL执行检查的记录数
Extra：SQL执行的附加信息，如`"Using index"表示查询只用到索引列`，不需要去读表等