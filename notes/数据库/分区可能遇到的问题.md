# 分区可能遇到的问题

1.NULL值会使分区过滤无效；
在旧版本中可以创建一个“无用”的第一个分区来处理特殊值的情况。5.5以后的版本可以直接基于列进行分区：

```
PARTITION BY RANGE COLUMNS(order_date);
```
2.分区列和索引列不匹配；
3.选择分区的成本可能很高；
4.打开并锁住所有底层表的成本可能很高；
5.维护分区的成本可能很高；
6.所有分区都必须使用相同的存储引擎；
7.某些存储引擎不支持分区；

对于访问分区表，很重要的一点是要在WHERE条件中带入分区列（有时看似多余也要带上），这样就可以让优化器能够过滤掉无须访问的分区。假如没有这些条件，MySQL就需要让对应存储引擎访问这个表的所有分区。

可以通过EXPLAIN查看查询是否使用了分区过滤：
```
EXPLAIN PARTITIONS SELECT * FROM sales_by_day WHERE day > '2011-01-01';
```
如果结果中partitions部分没有展示所有的分区，说明有分区过滤。

虽然在创建分区时可以使用表达式，但在查询时只能根据列来过滤分区。