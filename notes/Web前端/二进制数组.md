# 二进制数组

二进制数组允许开发者`以数组下标的形式，直接操作内存`，`使得开发者有可能通过JavaScript与操作系统的原生接口进行二进制通信`。

## 二进制数组由三类对象组成
1.`ArrayBuffer`对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。

2.`TypedArray`视图：是一组不同类型视图的统称，共包括9种类型的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float32Array（32位浮点数）数组视图等等。

3.`DataView`视图：可以自定义复合格式的视图，比如第一个字节是Uint8（无符号8位整数）、第二、三个字节是Int16（16位整数）、第四个字节开始是Float32（32位浮点数）等等，此外还可以自定义字节序。

即，ArrayBuffer对象代表原始的二进制数据，TypedArray视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。

`注意，二进制数组并不是真正的数组，而是类似数组的对象。`


## ArrayBuffer对象 
ArrayBuffer对象代表储存二进制数据的一段内存，它`不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写`，视图的作用是以指定格式解读二进制数据：
```
var buf = new ArrayBuffer(32);
var dataView = new DataView(buf);
dataView.getUint8(0) // 0
```

TypedArray视图的构造函数，除了接受ArrayBuffer实例作为参数，还可以接受普通数组作为参数，直接分配内存生成底层的ArrayBuffer实例，并同时完成对这段内存的赋值:
```
var typedArray = new Uint8Array([0,1,2]);
typedArray.length // 3

typedArray[0] = 5;
typedArray // [5, 1, 2]
```

ArrayBuffer实例的`byteLength属性`，返回所分配的内存区域的`字节长度`：
```
var buffer = new ArrayBuffer(32);
buffer.byteLength
// 32
```

ArrayBuffer实例的`slice方法`，可以将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象：
```
var buffer = new ArrayBuffer(8);
var newBuffer = buffer.slice(0, 3);  // 拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束）
```
除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。

ArrayBuffer的静态方法`isView`，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例：
```
var buffer = new ArrayBuffer(8);
ArrayBuffer.isView(buffer) // false

var v = new Int32Array(buffer);
ArrayBuffer.isView(v) // true
```

## TypedArray视图
普通数组与TypedArray数组的差异主要在以下方面：
1.TypedArray数组的所有成员，都是同一种类型。
2.TypedArray数组的成员是连续的，不会有空位。
3.TypedArray数组成员的默认值为0。比如，new Array(10)返回一个普通数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个TypedArray数组，里面10个成员都是0。
4.TypedArray数组只是一层视图，`本身不储存数据`，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。

视图可以不通过ArrayBuffer对象，直接分配内存而生成：
```
var f64a = new Float64Array(8);
f64a[0] = 10;
f64a[1] = 20;
f64a[2] = f64a[0] + f64a[1];
```
普通数组的操作方法和属性，对TypedArray数组完全适用，除了concat方法。
`TypedArray数组只能处理小端字节序！DataView对象，可以设定字节序。`


不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。TypedArray数组（除了Uint8ClampedArray）的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。
```
var uint8 = new Uint8Array(1);

uint8[0] = 256;
uint8[0] // 0

uint8[0] = -1;
uint8[0] // 255
```
Uint8ClampedArray规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即0。

buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。
set方法用于复制数组（普通数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。
subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。
(其他方法，略)

## DataView视图
在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。

DataView实例提供8个方法读取内存：
getInt8：读取1个字节，返回一个8位整数。
getUint8：读取1个字节，返回一个无符号的8位整数。
getInt16：读取2个字节，返回一个16位整数。
getUint16：读取2个字节，返回一个无符号的16位整数。
getInt32：读取4个字节，返回一个32位整数。
getUint32：读取4个字节，返回一个无符号的32位整数。
getFloat32：读取4个字节，返回一个32位浮点数。
getFloat64：读取8个字节，返回一个64位浮点数。
如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。
