# 把两个链表合并成一个新的有序链表，返回头指针

递归终止条件：若head1为空，返回head2指针（head）；若head2为空，返回head1指针（head）
递归过程：
（1）若head1->data > head2->data; head 指针应该指向head2所指向的节点，而且head->next应该指向head1和head2->next两个链表的合成序列的头指针；
（2）否则head 指针应该指向head1所指向的节点，而且head->next应该指向head->next和head2两个链表的合成序列的头指针；

实现代码（C++）： 
```c++
#include <iostream>
using namespace std;
    
/*节点的类定义*/
class Node{
public:
  int data;
  Node * next;
  Node(int data){
    this->data=data;
  }
};

/*链表的类定义*/
class LinkedList{
public:
  Node * head;
  /*用一个整形数组作为参数的构造函数*/
  LinkedList(int array[]){
    head=new Node(array[0]);
    Node * temp=head;
    int i;
    for(i=1;i<3;i++){
      temp->next=new Node(array[i]);
      temp=temp->next;
    }
    temp->next=NULL;
  }
};

/*递归的合并两个有序链表*/
Node * mergeLinkedList(Node * head1,Node * head2){   
  Node *p=NULL;   
  if(head1==NULL && head2==NULL){
            return p;
  }   
  else if(head1==NULL){   
    return head2;
  }   
  else if(head2==NULL){
    return head1;
  }   
  else{   
    if(head1->data < head2->data){   
      p = head1;   
      p->next = mergeLinkedList(head1->next,head2);   
    }   
    else{
      p = head2;   
      p->next = mergeLinkedList(head1,head2->next);   
    }   
    return p;   
  }   
} 

/*打印链表的所有元素*/
void printList(Node * head){
  Node * temp=head;
  while(temp!=NULL){
    cout<<temp->data<<"  ";
    temp=temp->next;
  }
}

int main(){
  int array1[3]={2,5,8};
  int array2[3]={1,6,7};

  /*构造两个有序链表--list1和list2*/
  LinkedList list1(array1);
  LinkedList list2(array2);

  /*递归的将这两个有序链表合并成一个有序链表*/
  Node * new_head=mergeLinkedList(list1.head,list2.head);
    
  /*打印有序链表*/
  printList(new_head);
  return 0;
}
```