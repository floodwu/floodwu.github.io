# 堆排序（Java）

基于二叉堆的排序，二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按层级存储。
完全二叉树：除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。
叶子结点只可能在最大的两层上出现。对任意结点，若其右分支下的子孙最大层次为L，则其左分支下的子孙的最大层次必为L 或 L+1；
完全二叉树通常采用数组而不是链表存储，对于tree[i]，有如下特点：
（1）若i为奇数且i>1，那么tree的左兄弟为tree[i-1]；
（2）若i为偶数且i<n，那么tree的右兄弟为tree[i+1]；
（3）若i>1，tree的双亲为tree[i div 2]；
（4）若2*i<=n，那么tree的左孩子为tree[2*i]；若2*i+1<=n，那么tree的右孩子为tree[2*i+1]；
（5）若i>n/2，那么tree[i]为叶子结点（对应于（3））；
（6）若i<(n-1)/2，那么tree[i]必有两个孩子（对应于（4））。
（7）满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。
完全二叉树第i层至多有2^（i-1）个节点，共i层的完全二叉树最多有2^i-1个节点。


堆排序：使用堆下沉操作，将原始数组重新组织安排进一个大根堆中，然后将大根堆的顶部元素（当前大根堆中最大的元素）与数组空间的最后一个元素交换，这样最后一个元素就排好序了，然后用剩下的N-1个元素构造新的大根堆，继续以上操作。
```java
// 大根堆下沉算法：k为待下沉元素索引，N为堆中最后一个元素的索引
private static void sink(Comparable[] a,int k,int N) {
        while (2*k <= N) {
            int j = 2*k;
            if (j < N && less(a[j], a[j+1])) 
				j++;
            if (!less(a[k], a[j])) 
				break;
            exch(a,k,j);
            k = j;
        }
    }
	
// 堆排序
	public static void heapSort(Comparable[] a){
		int N = a.length-1;
// 首先将指定数组调整为一个大根堆：从k=N/2的元素开始往前调整
		for(int k= N/2; k>=0; k--){
			sink(a,k,N);
		}
 
// 去掉大根堆的堆顶元素，用剩下的元素重新构造堆。循环N次
		while(N>0){
			exch(a,0,N--);
			sink(a,0,N);
		}
	}
```