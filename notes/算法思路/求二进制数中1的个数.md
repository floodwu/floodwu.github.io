# 求二进制数中1的个数

解法1：对于二进制操作，除以一个2，如果除的过程中有余，那么就表示当前位置有一个1。考虑利用整型数据除法的特点，通过相除和判断余数的值来分析。

```C++
int Count ( BYTE v )

  	int num = 0;
	while(v)
	{
		if(v%2 == 1)
			num++;
		v = v/2;
	}
	return num;
}
```

解法2：对解法1进行改进，通过移位操作来实现除法。通过与00000001进行与操作来判断当前八位数字最后一位是否为1.
```C++
int Count ( BYTE v )
{
	int num = 0;
	while(v)
	{
		num += v & 0x01;
		v >>= 1;
	}
	return num;
}
```
解法3：在每次判断中仅与1来进行判断，将复杂度由二进制数的位数降低至二进制数中1的个数。
	v & (v-1)操作每次能消去二进制表示中最后一位1，利用这个技巧可以减少一定的循环次数。
```C++
int Count ( BYTE v )
{
	int num = 0;
	while(v)
	{
		v &= (v-1);
		num++;
	}
	return num;
}
```
解法4：使用分支操作（switch语句），针对8位数据，直接把0~255的情况都罗列出来，并使用分支操作，可以得到答案。不是好的方法。
```C++
int Count ( BYTE v )
{
	int num = 0;
	switch( v )
	{
		case 0x0:
			num = 0;
			break;
		case 0x1:
		case 0x2:
		…
		case 0x80:
			num = 1;
			break;
		case 0x3:
		case 0x6:
		…
		case 0xc0;
			num = 2;
			break;
		…
	return num;
}
```
解法5：查表法，典型的空间换时间算法，把0~255中1的个数直接存储在数组中，v作为数组的下标，countTable[v]就是v中1的个数。算法的时间复杂度仅为1.
```C++
int countTable[256] = {
	0,1,1,2,1,2,2,3,……7,6,7,7,8
};

int Count ( BYTE v )
{
	//check parameter
	return countTable[v];
}
```