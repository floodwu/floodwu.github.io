# 寻找发帖“水王”

最直接的方法，先对所有ID排序，再统计各个ID出现的次数。如果某个ID出现次数超过总数的一半，那么就输出这个ID。这个算法的时间复杂度为O( N*logN + N ) .
如果ID列表已经是有序的，也可以不用扫描统计各个ID的出现次数。如果一个ID出现的次数超过总数N的一半，那么无论水王的ID是什么，这个有序的ID列表的第N/2项（从0开始编号）一定是这个ID。除去排序的时间复杂度后，处理的时间复杂度为O(1)。
上面的方法都需要先对ID列表进行排序，时间复杂度方面没有根本的改进。如果`每次删除两个不同的ID`，那么在剩下的ID列表中，水王ID出现的次数仍然超过总数的一半（即，哪怕每次拿一个其他ID来同归一个水王的ID，最终剩下的仍然是水王的ID，且只有水王的ID能够满足这种挑战）。可以通过不断重复这个过程，把ID列表中的ID总数降低。从而避免了排序这个耗时的步骤，总的时间复杂度也只有O( N )，且只需要常数的额外内存:

```C++
Type Find( Type* ID ,int N )
{
	Type candidate;
	int nTimes, i;
	for( i = nTimes = 0; i<N; i++)
	{
		if( nTimes == 0 )
			candidate=ID[i], nTimes=1;
		else
		{
			if(candidate == ID[i])
				nTimes++;
			else
				nTimes--;
		}
	}
	return candidate;
}
```
大致思想就是：假设每个ID都有可能是水王，那么在遍历时这个水王就要遇到一种挑战，可能自己的帖子数是会增加的，也可能是遇到挑战的，帖子数要减少的。这样遍历下来，只有水王的帖子增加的减去遇到挑战的帖子数会是大于0的。其他任何帖子假设为水王时都是禁不起挑战的。
步骤：
1.可以假设帖子的第一个ID是次数最大的，用candidate记录，次数用nTimes记录。
2.遍历下一个ID，如果跟candidate一样，nTimes++，否则，遇到一个挑战，则nTimes--，如果nTimes == 0，下一步就要重复第一步了。
3.遍历结束，nTimes>0的那个candidate就是水王ID，他是获胜者。
问题解决的关键在于水王ID超过了总数的一半这一特殊条件。