# 《推荐系统实践》

这本书记笔记很失败，因为有很多实验过程。

# 第1章 好的推荐系统
推荐系统的基本任务是联系用户和物品，解决信息过载的问题

和搜索引擎一样，推荐系统也是一种帮助用户快速发现有用信息的工具。和搜索引擎不同的是，推荐系统不需要用户提供明确的需求，而是通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐能够满足他们兴趣和需求的信息。

传统的80/20原则（80%的销售额来自于20%的热门品牌）在互联网的加入下会受到挑战。主流商品往往代表了绝大多数用户的需求，而长尾商品往往代表了一小部分用户的个性化需求。如果要通过发掘长尾提高销售额，就必须充分研究用户的兴趣，而这正是个性化推荐系统主要解决的问题。

尽管不同的网站使用不同的推荐系统技术，但总的来说，几乎所有的推荐系统应用都是由前台的展示页面、后台的日志系统以及推荐算法系统3部分构成的。

个性化推荐的成功应用需要两个条件。第一是存在信息过载，因为如果用户可以很容易地从所有物品中找到喜欢的物品，就不需要个性化推荐了。第二是用户大部分时候没有特别明确的需求，因为用户如果有明确的需求，可以直接通过搜索引擎找到感兴趣的物品。

预测准确度是推荐系统领域的重要指标（没有之一）。但是，很多研究表明，准确的预测并不代表好的推荐。好的推荐系统不仅仅能够准确预测用户的行为，而且能够扩展用户的视野，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西。

在推荐系统中，主要有3种评测推荐效果的实验方法，即：
1.离线实验（offline experiment）
（1）通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集；
（2）将数据集按照一定的规则分成训练集和测试集；
（3）在训练集上训练用户兴趣模型，在测试集上进行预测；
（4）通过事先定义的离线指标评测算法在测试集上的预测结果。
它的主要缺点是无法获得很多商业上关注的指标，如点击率、转化率等，而找到和商业指标非常相关的离线指标也是很困难的事情。

2.用户调查（userstudy）
在对算法会不会降低用户满意度不太有把握的情况下，上线测试具有较高的风险，所以在上线测试前一般需要做一次称为用户调查的测试。

3.在线实验（online experiment）
在完成离线实验和必要的用户调查后，可以将推荐系统上线做AB测试，将它和旧的算法进行比较。AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同的评测指标比较不同算法，比如可以统计不同组用户的点击率，通过点击率比较不同算法的性能。

推荐系统的评测指标：
1.用户满意度：只能通过用户调查或者在线实验（用户行为统计数据）获得。
2.预测准确度：度量一个推荐系统或者推荐算法预测用户行为的能力。这个指标是最重要的推荐系统离线评测指标。
3.覆盖率：描述一个推荐系统对物品长尾的发掘能力。覆盖率有不同的定义方法，最简单的定义为推荐系统能够推荐出来的物品占总物品集合的比例。覆盖率为100%的推荐系统可以将每个物品都推荐给至少一个用户。
4.多样性：多样性描述了推荐列表中物品两两之间的不相似性。如果推荐列表只能覆盖用户的一个兴趣点，而这个兴趣点不是用户这个时刻的兴趣点，推荐列表就不会让用户满意。
5.新颖性：给用户推荐那些他们以前没有听说过的物品。
6.惊喜度：如果推荐结果和用户的历史兴趣不相似，但却让用户觉得满意，那么就可以说推荐结果的惊喜度很高，而推荐的新颖性仅仅取决于用户是否听说过这个推荐结果。
7.信任度：度量推荐系统的信任度只能通过问卷调查的方式，询问用户是否信任推荐系统的推荐结果。同样的推荐结果，以让用户信任的方式推荐给用户就更能让用户产生购买欲，而以类似广告形式的方法推荐给用户就可能很难让用户产生购买的意愿。
8.实时性；
9.健壮性：衡量了一个推荐系统抗击作弊的能力（比如防刷），设计推荐系统时尽量使用代价比较高的用户行为。
10.商业目标；

推荐系统的评测维度：
1.用户维度：主要包括用户的人口统计学信息、活跃度以及是不是新用户等。
2.物品维度：包括物品的属性信息、流行度、平均分以及是不是新加入的物品等。
3.时间维度：包括季节，是工作日还是周末，是白天还是晚上等。
增加评测维度的目的就是知道一个算法在什么情况下性能最好。这样可以为融合不同推荐算法取得最好的整体性能带来参考。如果能够在推荐系统评测报告中包含不同维度下的系统评测指标，就能帮我们全面地了解推荐系统性能，找到一个看上去比较弱的算法的优势，发现一个看上去比较强的算法的缺点。


# 第2章 利用用户行为数据
按照反馈的明确性分，用户行为数据可以分为显性反馈和隐性反馈：
1.显性反馈行为：用户明确表示对物品喜好的行为。
2.隐性反馈行为：不能明确反应用户喜好的行为，最具代表性的隐性反馈行为就是页面浏览行为。
相比显性反馈，隐性反馈虽然不明确，但数据量更大。

按照反馈的方向分，可以分为正反馈和负反馈：
1.正反馈：指用户的行为倾向于指用户喜欢该物品；
2.负反馈：指用户的行为倾向于指用户不喜欢该物品。
在显性反馈中，很容易区分一个用户行为是正反馈还是负反馈，而在隐性反馈行为中，就相对比较难以确定。

用户行为的统一表示：
1.user id：产生行为的用户的唯一标识；
2.item id：产生行为的对象的唯一标识；
3.behavior type行为的种类（比如是购买还是浏览）；
4.context产生行为的上下文，包括时间和地点等；
5.behavior weight行为的权重（如果是观看视频的行为，那么这个权重可以是观看时长；如果是打分行为，这个权重可以是分数）；
6.behavior content行为的内容（如果是评论行为，那么就是评论的文本；如果是打标签的行为，就是标签）；
当然，在很多时候并不使用统一结构表示所有行为，而是针对不同的行为给出不同表示。

互联网上的很多数据分布都满足一种称为Power Law的分布，这个分布在互联网领域也称长尾分布。

不管是物品的流行度还是用户的活跃度，都近似于长尾分布。

一般认为，新用户倾向于浏览热门的物品，因为他们对网站还不熟悉，只能点击首页的热门物品，而老用户会逐渐开始浏览冷门的物品。

基于邻域的模型：仅仅基于用户行为数据设计的推荐算法一般称为协同过滤算法。其中最著名的、在业界得到最广泛应用的是基于邻域的方法，而基于邻域的方法主要包含下面两种算法。   1.基于用户的协同过滤算法：这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。   2.基于物品的协同过滤算法：这种算法给用户推荐和他之前喜欢的物品相似的物品。

实验验证举例，略。

基于用户的协同过滤算法（UserCF）：
（1）找到和目标用户兴趣相似的用户集合。主要利用行为的相似度计算兴趣的相似度。（两个用户对冷门物品采取过同样的行为更能说明他们兴趣的相似度）
（2）找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。

基于物品的协同过滤算法（ItemCF）：
（1）计算物品之间的相似度。
（2）根据物品的相似度和用户的历史行为给用户生成推荐列表。
该算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。

实验验证举例，略。

UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点，而ItemCF的推荐结果着重于维系用户的历史兴趣。换句话说，UserCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF的推荐更加个性化，反映了用户自己的兴趣传承。

从技术上考虑，UserCF需要维护一个用户相似度的矩阵，而ItemCF需要维护一个物品相似度矩阵。从存储的角度说，如果用户很多，那么维护用户兴趣相似度矩阵需要很大的空间，同理，如果物品很多，那么维护物品相似度矩阵代价较大。

隐语义模型（LFM）：该算法最早在文本挖掘领域被提出，用于找到文本的隐含语义。它的核心思想是通过隐含特征（latent factor）联系用户兴趣和物品。
该模型在实际使用中有一个困难，那就是它很难实现实时的推荐。
详略。

基于图的模型：可以把基于邻域的模型看做基于图的模型的简单形式。详略。


# 第3章 推荐系统冷启动问题

冷启动问题分类：
1.用户冷启动：当新用户到来时，因为没有他的行为数据，所以也无法根据他的历史行为预测其兴趣，从而无法借此给他做个性化推荐。
2.物品冷启动：主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题。
3.系统冷启动：主要解决如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性化推荐系统，从而在网站刚发布时就让用户体验到个性化推荐服务这一问题。

冷启动问题的常见解决方案：
1.提供非个性化的推荐，比如推荐热门排行榜；
2.利用用户注册时提供的年龄、性别等数据做粗粒度的个性化。
3.利用用户的社交网络账号登录（需要用户授权），导入用户在社交网站上的好友信息，然后给用户推荐其好友喜欢的物品。
4.要求用户在登录时对一些物品进行反馈，收集用户对这些物品的兴趣信息，然后给用户推荐那些和这些物品相似的物品。
5.对于新加入的物品，可以利用内容信息，将它们推荐给喜欢过和它们相似的物品的用户。
6.在系统冷启动时，可以引入专家的知识，通过一定的高效方式迅速建立起物品的相关度表。

解决用户冷启动问题的另一个方法是在新用户第一次访问推荐系统时，不立即给用户展示推荐结果，而是给用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐。

详细推导过程，略。


# 第4章 利用用户标签数据
标签是一种无层次化结构的、用来描述信息的关键词，它可以用来描述物品的语义。根据给物品打标签的人的不同，标签应用一般分为两种：一种是让作者或者专家给物品打标签；另一种是让普通用户给物品打标签，也就是UGC（User Generated Content，用户生成的内容）的标签应用。UGC的标签系统是一种表示用户兴趣和物品语义的重要方式。当一个用户对一个物品打上一个标签，这个标签一方面描述了用户的兴趣，另一方面则表示了物品的语义，从而将用户和物品联系了起来。

代表应用举例，略。

标签系统中的推荐问题主要有以下两个：  1.如何利用用户打标签的行为为其推荐物品（基于标签的推荐）？   2.如何在用户给物品打标签时为其推荐适合该物品的标签（标签推荐）？

在互联网中，尽管每个用户的行为看起来是随机的，但其实这些表面随机的行为背后蕴含着很多规律。

示例，略。

用户用标签来描述对物品的看法，因此标签是联系用户和物品的纽带，也是反应用户兴趣的重要数据源。
实验过程，略。

标签清理的另一个重要意义在于将标签作为推荐解释。这些标签不能包含没有意义的停止词或者表示情绪的词，其次这些推荐解释里不能包含很


# 第5章 利用上下文信息
上下文包括用户访问推荐系统的时间、地点、心情等。

，时间信息对用户兴趣的影响表现在以下几个方面：
1.用户兴趣是变化的；
2.物品也是有生命周期的；
3.季节效应；

在给定时间信息后，推荐系统从一个静态系统变成了一个时变的系统，而用户行为数据也变成了时间序列。

不同类型网站的物品具有不同的生命周期，比如新闻的生命周期很短，而电影的生命周期很长。

推荐系统每天推荐结果的变化程度被定义为推荐系统的时间多样性。

纯粹的随机推荐虽然具有最高的时间多样性，但不能保证推荐的精度。

提高推荐结果的时间多样性需要分两步解决：
1.需要保证推荐系统能够在用户有了新的行为后及时调整推荐结果，使推荐结果满足用户最近的兴趣；
2.需要保证推荐系统在用户没有新的行为时也能够经常变化一下结果，具有一定的时间多样性。

时间多样性也不是绝对的。推荐系统需要首先保证推荐的精度，在此基础上适当地考虑时间多样性。在实际应用中需要通过多次的实验才能知道什么程度的时间多样性对系统是最好的。

时间上下文推荐算法，略。

时间段图模型，略。

离线实验，略。


# 第6章 利用社交网络数据

获取社交网络数据的途径：
1.电子邮件：可以通过分析用户的联系人列表了解用户的好友信息，而且可以进一步通过研究两个用户之间的邮件往来频繁程度度量两个用户的熟悉程度。
2.用户注册信息：需要用户在注册时填写一些诸如公司、学校等信息。
3.用户的位置数据：IP地址、GPS数据。
4.论坛和讨论组：如果两个用户在讨论组中曾经就某一个帖子共同进行过讨论，那就更加说明他们之间的熟悉程度或兴趣相似度很高。
5.即时聊天工具：和电子邮件系统一样，用户在即时聊天工具上也会有一个联系人列表，而且往往还会给联系人进行分组。通过这个列表和分组信息，我们就可以知道用户的社交网络关系，而通过统计用户之间聊天的频繁程度，可以度量出用户之间的熟悉程度。
6.社交网站：在Facebook和Twitter诞生之前，社会化应用（无论是电子邮件系统还是即时聊天系统）都过于封闭。用户只能和自己的好友进行交流，而无法了解到好友圈以外的世界，而且用户之间交流的内容都是非常私密的，大部分用户不会允许将它们公开来用作其他用途。
社会图谱和兴趣图谱：以Facebook为代表的社交网络称为社交图谱（social graph），而以Twitter为代表的社交网络称为兴趣图谱（interest graph）。
19世纪，德国社会学家斐迪南·滕尼斯（FerdinandTönnies）认为社会群体分为两种，一种是通过人们之间的共同兴趣和信念形成的。另一种社会群体则是由于人们之间的亲属关系，工作关系而形成的。

一般来说，有3种不同的社交网络数据：
1.双向确认的社交网络数据：用户A和B之间形成好友关系需要通过双方的确认。因此，这种社交网络一般可以通过无向图表示。
2.单向关注的社交网络数据：用户A可以关注用户B而不需要得到用户B的允许，因此这种社交网络中的用户关系是单向的，可以通过有向图表示。
3.基于社区的社交网络数据：用户之间并没有明确的关系，但是这种数据包含了用户属于不同社区的数据。

社交网络中用户的入度（in degree）和出度（out degree）的分布也是满足长尾分布的。用户的入度反映了用户的社会影响力。用户的入度近似长尾分布，这说明在一个社交网络中影响力大的用户总是占少数。

社会化推荐之所以受到很多网站的重视，是缘于如下优点：
1.好友推荐可以增加推荐的信任度；
2.社交网络可以解决冷启动问题；

基于邻域的社会化推荐算法，略。
基于图的社会化推荐算法，略。

社会化推荐系统的效果往往很难通过离线实验评测，因为社会化推荐的优势不在于增加预测准确度，而是在于通过用户的好友增加用户对推荐结果的信任度，从而让用户单击那些很冷门的推荐结果。

信息流推荐，略。

好友推荐系统的目的是根据用户现有的好友、用户的行为记录给用户推荐新的好友，从而增加整个社交网络的稠密程度和社交网站用户的活跃度。

可以给用户推荐和他们有相似内容属性的用户作为好友，常用的内容属性：
1.用户人口统计学属性，包括年龄、性别、职业、毕业学校和工作单位等。
2.用户的兴趣，包括用户喜欢的物品和发布过的言论等。
3.用户的位置信息，包括用户的住址、IP地址和邮编等。

可以将微博看做物品，如果两个用户曾经评论或者转发同样的微博，说明他们具有相似的兴趣。

也可以根据用户在社交网络中的发言提取用户的兴趣标签，来计算用户的兴趣相似度。


# 第7章 推荐系统实例

外围架构：网站会通过日志系统将用户在UI上的各种各样的行为记录到用户行为日志中。日志可能存储在内存缓存里，也可能存储在数据库中，也可能存储在文件系统中。而推荐系统通过分析用户的行为日志，给用户生成推荐列表，最终展示到网站的界面上。

数据能否实时存取在推荐系统中非常重要，一般来说，需要实时存取的数据存储在数据库和缓存中，而大规模的非实时地存取数据存储在分布式文件系统（如HDFS）中。

推荐系统架构：推荐系统需要由多个推荐引擎组成，每个推荐引擎负责一类特征和一种任务，而推荐系统的任务只是将推荐引擎的结果按照一定权重或者优先级合并、排序然后返回。
详略。

推荐引擎的架构：推荐引擎使用一种或几种用户特征，按照一种推荐策略生成一种类型物品的推荐列表。推荐引擎架构主要包括3部分：
1.部分A负责从数据库或者缓存中拿到用户行为数据，通过分析不同行为，生成当前用户的特征向量。不过如果是使用非行为特征，就不需要使用行为提取和分析模块了。该模块的输出是用户特征向量。
2.部分B负责将用户的特征向量通过特征-物品相关矩阵转化为初始推荐物品列表。   3.部分C负责对初始的推荐列表进行过滤、排名等处理，从而生成最终的推荐结果。

详略。

# 第8章 评分预测问题
离线实验，略。

