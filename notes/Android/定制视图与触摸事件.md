# 定制视图与触摸事件

定义一个表示矩形框的类：

```java
public class Box{
private PointF mOrigin;
private PointF mCurrent;
public Box(PointF origin){
mOrigin = mCurrent = origin;
}
public void setCurrent(PointF current){
mCurrent = current;
}
public PointF getCurrent(){
return mCurrent;
}
public PointF getOrigin(){
return mOrigin;
}
}
```
创建自定义视图类：
处理触摸事件有两种方式，一是使用View.OnTouchListener接口，实现onTouch(...)方法，然后在视图上调用setOnTouchListener(View.OnTouchListener)方法。另一种方式是直接覆盖View的onTouchEvent(...)方法。前一种方式的优先级更高，如果同时使用两种方式，则只有在onTouch()方法中返回false时，onTouchEvent(...)方法才会被接着调用。
```java
public class BoxDrawingView extends View{
private Box mCurrentBox;
private ArrayList<Box> mBoxes = new ArrayList<Box>();
private Paint mBoxPaint;
private Paint mBackgroundPaint;

public BoxDrawingView(Context context){ // 从代码实例化
this(context,null);
}

public BoxDrawingView(Context context,AttributeSet attrs){ // 从布局文件实例化
super(context,attrs);
mBoxPaint = new Paint();
mBoxPaint.setColor(0x22ff0000);
mBackgroundPaint = new Paint();
mBackgroundPaint.setColor(0xfff8efe0);
}

public boolean onTouchEvent(MotionEvent event){
PointF curr = new PointF(event.getX(),event.getY());
switch(event.getAction()){
case MotionEvent.ACTION_DOWN:
		// 按下后，初始化一个box，起点和终点一样，之后起点不变，终点随MOVE不断变化，直至UP
mCurrentBox = new Box(curr);
mBoxes.add(mCurrentBox);
break;
case MotionEvent.ACTION_MOVE:
if(mCurrentBox != null){
mCurrentBox.setCurrent(curr);
invalidate(); // 强制视图重绘
}
break;
case MotionEvent.ACTION_UP:
mCurrentBox = null;
break;
case MotionEvent.ACTION_CANCEL:
mCurrentBox = null; 
break;
}
return true;
}

// 覆盖视图的onDraw(...)方法
@Override
protected void onDraw(Canvas canvas){
canvas.drawPaint(mBackgroundPaint);
for(Box box:mBoxes){
float left = Math.min(box.getOrigin().x,box.getCurrent().x);
float right = Math.max(box.getOrigin().x,box.getCurrent().x);
float top= Math.min(box.getOrigin().y,box.getCurrent().y);
float bottom= Math.min(box.getOrigin().y,box.getCurrent().y);

canvas.drawRect(left,top,right,bottom,mBoxPaint);
}
}
}
```
在Fragment布局文件中引用自定义视图类：
fragment_drag_and_draw.xml
<com.xxx...BoxDrawingView // 必须使用全路径类名，否则布局inflater会在android.view和android.widget包中寻找目标。对于android.view和android.widget包以外的自定义视图类，必须指定其全路径类名。
xmlns:android=”http://xxx...”
android:layout_width=”match_parent”
android:layout_height=”match_parent”
/>

创建Fragment：
```java
public class DragAndDrawFragment extends Fragment{
@Override
public View onCreateView(LayoutInflater inflater,ViewGroup parent,Bundle savedInstanceState){
View v =inflater.inflate(R.layout.fragment_drag_and_draw,parent,false);
return v;
}
}
```
创建托管Fragment的Activity：
```java
public class DragAndDrawActivity extends SingleFragmentActivity{
@Override
public Fragment createFragment(){
return new DragAndDrawFragement();
}
}
```