# APK程序的运行过程

1）ActivityThread从main()函数中开始执行，调用prepareMainLooper()为UI线程创建一个消息队列；
2）创建一个ActivityThread对象，在ActivityThread的初始化代码中会创建一个H（Handler）对象和一个ApplicationThread（Binder），其中Binder负责接收远程AmS的IPC调用，接收到调用后则通过Handler把消息发送到消息队列，UI主线程会异步地从消息队列中取出消息并执行相应操作，比如start、stop、pause等；
3）UI主线程调用Looper.loop()方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息；
4）当ActivityThread接收到AmS发送start某个Activity后，就会创建指定的Activity对象，Activity又会创建PhoneWindow类→创建DecorView类→创建相应的View或者ViewGroup，创建完成后，Activity需要把创建好的界面显示到屏幕上，于是调用WindowManager类创建一个ViewRoot对象，该对象实际上创建了ViewRoot类和W类，创建ViewRoot对象后，WindowManager再调用WmS提供的远程接口完成添加一个窗口并显示到屏幕上；
5）用户开始在程序界面上操作，KeyQ线程不断把用户消息存储到QueueEvent队列中，InputDispatcherThread线程逐个取出消息，然后调用WmS中的相应函数处理该消息。当WmS发现该消息属于客户端某个窗口时，就会调用相应窗口的W接口；
6）W类是一个Binder，负责接收WmS的IPC调用，并把调用消息传递给ViewRoot，ViewRoot再把消息传递给UI主线程ActivityThread，ActivityThread解析该消息并做相应的处理。在客户端程序中首先处理消息的是DecorView，如果DecorView不想处理某个消息，则可以将该消息传递给其内部包含的子View或者ViewGroup，如果还没有处理，则传递给PhoneWindow，最后再传递给Activity；
因为每个Binder对象都对应一个线程，因此包含有Activity的客户端程序至少拥有三个线程：Activity启动后会创建一个ViewRoot.W对象，同时ActivityThread会创建一个ApplicationThread对象，这两个对象都继承于Binder，因此会启动两个线程负责接收Linux Binder驱动发送的IPC调用。最后一个主要线程也就是程序本身所在的线程，即UI（用户交互）线程。
UI线程与自定义Thread的区别在于，UI线程是从ActivityThread运行的，在该类的main()方法中已经使用Looper.prepareMainLooper()为该线程添加了Looper对象，即已经为该线程创建了消息队列，因此程序员才可以在Activity中定义Handler对象（因为声明Handler时，所在的线程必须已经创建了消息队列），而普通的自定义Thread是一个裸线程，因此不能直接在Thread中定义Handler对象。

有关Activity类之间传递数据：与普通类传递数据有所不同，普通类的实例化都是程序员显式完成的，而Activity类的实例化却是由Framework完成的，程序员只能使用startActivity()方法来告诉Framework去运行哪个Activity，也即程序员不能得到Activity对象的引用，也就不能直接访问该对象的内部数据。解决方法是使用Activity.getApplication()函数，因为同一个程序中的不同Activity调用该函数所返回的Application对象是相同的，，该对象名称可以在AndroidManifest.xml中指定。此外Framework提供的标准的Activity之间传递数据的方法是Intent类（结合startActivity和startActivityForResult）。另外也可以借助Preference Storage、文件、数据库等。