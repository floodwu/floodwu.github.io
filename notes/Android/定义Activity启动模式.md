# 定义Activity启动模式

启动模式使你可以定义新的activity如何与当前的任务相关联．有两种方法来定义不同的启动模式：
1）使用manifest文件：当你在你的manifest文件中声明一个activity时，你可以指定activity在启动时如何与任务相关联．
2）使用Intent的flag：当你调用startActivity()时，你可以在Intent中包含指明新的activity如何（或是否）与当前栈关联的flag．
同样的，如果ActivityA 启动ActivityB，ActivityB可以在它的manifest中定义如何与当前的任务关联(如果真的存在)并且ActivityA 也可以请求让ActivityB如何与当前的任务关联．如果两个activity都定义了ActivityB如何与任务关联，那么ActivityA的请求(在intent中定义)优先于ActivityB的请求(在它的manifest中定义)．
一些启动模式可以用在manifest中但不能用在intent的flag上，同样的，一些启动模式可以用在intent的flag上但不能用在manifest中．
使用manifest文件：当在你的manifest文件中声明一个activity时，你可以使用<activity>元素的launchMode属性指定activity如何与一个任务关联。launchMode属性指明了activity如何启动到一个任务中去．有四种不同的启动模式你可以用于指定给launchMode属性：
（1）"standard"(默认模式)
默认．系统创建一个新的activity的实例到启动它的任务中．activity可以被多次实例化，每个实例可以属于不同的任务，也可以属于同一个任务．
（2）"singleTop"
如果一个activity的实例已经存在于当前任务的栈的顶端，系统通过调用它的onNewIntent()方法把intent路由到这个实例，而不是创建一个新的实例．activity可以被多次实例化，每个实例可以属于不同的任务，并且一个任务可以具有多个实例(但只是当位于后退栈的顶端的activity不存在时才会出现这种现像)．
例如，假设一个任务的后退栈中有根ActivityA和activityB,C,Ｄ(A-B-C-D;D位于顶端)．一个intent到达了D类型的activity(不是指这里的acitivityD)．如果D具有默认的"standard"启动模式，一个新的类的实例被启动并且栈变为A-B-C-D-D．然而，如果D的启动模式是"singleTop"，那么这个已存在的ActivityD就通过onNewIntent()接收到intent，因为它在栈的顶端—栈于是依然保持A-B-C-D．又然而，如果一个intent到达了B类型的activity(不是此处的activityB)，那么一个新的B实例被添加到栈中，即使它的启动模式是"singleTop"．
注：当一个新的activity的实例被创建，用户可以按下后退键回到上一个activity．但当一个已存在的activity实例处理了一个新intent，用户就不能按下后退键回到当前的activity在intent来之前的状态．
（3）"singleTask"
系统创建一个新的任务并且实例化activity为新任务的根．然而，如果一个activity的实例已存在于另一个任务，系统就会通过调用这个activity的onNewIntent()把intent路由给它，而不是创建一个新的实例．某个时刻只有一个activity的实例可以存在．
　　注：尽管activity在一个新任务中启动，后退键依然可以返回到上一个activity．
（4）"singleInstance".
　跟"singleTask"一样．除了系统不能再启动其它activity到拥有这个activity实例的任务中．activity永远是任务的唯一；任何由这个activity启动的其它activity都在另一个任务中打开．