# 跟踪设备的地理位置

Android中的地理位置数据是由LocationManager系统服务提供的，该系统服务向所有需要地理位置数据的应用提供数据更新，通常采用两种方式：
1.使用LocationListener接口，实现onLocationChanged(...)方法。
2.使用PendingIntent获取地理位置数据更新，然后发布广播。
第1种方法在实现LocationListener接口的组件不可用时就无法进行地理位置数据更新。而第2种方法即使应用组件，甚至整个应用进程都销毁了，LocationManager仍然会一致发送Intent，直到要求它停止并按需启动新组件响应它们。

创建一个与LocationManager通信的单例类：
```java
public class RunManager{
public static final String ACTION_LOCATION = “xxx....”;
private static RunManager sRunManager;
private Context mAppContext;
private LocationManager mLocationManager;

private RunManager(Context appContext){
mAppContext = appContext;
mLocationManager = 
(LocationManager)mAppContext.getSystemService(Context.LOCATION_SERVICE);
}

// 单例方法，返回实例
public static RunManager get(Context c){  
if(sRunManager == null){
sRunManager = new RunManager(c.getApplicationContext());
}
return sRunManager;
}

// 返回一个新的或者已存在的PendingIntent
private PendingIntent getLocationPendingIntent(boolean shouldCreate){
Intent broadcast = new Intent(ACTION_LOCATION);
int flag = shouldCreate ? 0 :PendingIntent.FLAG_NO_CREATE; // FLAG_NO_CREATE;如果当前系统中不存在相同的所描述的PendingIntent对象，系统将不会创建该PendingIntent对象而是直接返回 null
return PendingIntent.getBroadcast(mAppContext,0,broadcast,flags);
}

// 启动位置更新：构造一个PendingIntent，发送给LocationManager
public void startLocationUpdates(){
String provider = LocationManager.GPS_PROVIDER; // 还有WIFI、手机基站等定位方式

// 获取最近一次的地理位置,然后模拟LocationManager的方式发送广播
Location lastKnown = mLocationManager.getLastKnownLocation(provider);
if(lastKnown != null){
lastKnown.setTime(System.currentTimeMillis());
Intent broadcast = new Intent(ACTION_LOCATION);
broadcast.putExtra(LocationManager.KEY_LOCATION_CHANGED，location);
mAppContext.sendBroadcast(broadcast);
}

PendingIntent pi = getLocationPendingIntent(true);
mLocationManager.requestLocationUpdates(provider,0,0,pi); // 一旦有位置更新，就把这个PendingIntent发出去
}

// 停止位置更新
public void stopLocationUpdates(){
PendingIntent pi = getLocationPendingIntent(false);
if( pi != null){
mLocationManager.removeUpdates(pi);
pi.cancel();
}
}

public boolean isTrackingRun(){
return getLocationPendingIntent(false) != null;
}
}
```
创建用于接收位置信息更新的receiver：
```java
public class LocationReceiver extends BroadcastReceiver{
@Override 
public void onReceive(Context context,Intent intent){
		// 启动LocationManager的requestLocationUpdates(...)方法时，传入了一个PendingIntent
LocationManager在发生位置更新事件时想必是先往该PendingIntent中装入了一个索引为KEY_LOCATION_CHANGED的Location实例后，再发送的
Location loc = 
(Location)intent.getParcelableExtra(LocationManager.KEY_LOCATION_CHANGED);

if(loc != null){
onLocationReceived(context,loc);
return;
}
if(intent.hasExtra(LocationManager.KEY_PROVIDER_ENABLED)){
boolean enabled = intent.getBooleanExtra(LocationManager.KEY_PROVIDER_ENABLES,false);
onProviderEnabledChanged(enabled);
}
}

protected void onLocationReceived(Context context,Location loc){
// 地理位置有更新 
}

protected void onProviderEnabledChanged(boolean enabled){
// 定位服务启停状态有更新
}
}
```
添加地理位置使用权限和receiver：
<manifest
...
<uses-permission android:name=”android.permission.ACCESS_FINE_LOCATION” />
<uses-feature 
android:required=”true”
android:name=”android.hardware.location.gps”
/>
...
<application
...
<receiver
android:name=”.LocationReceiver”
android:exported=”fasle” >
<intent-filter>
<action android:name=”com....ACTION_LOCATION” />
</intent-filter>
</receiver>

实现一个简单的保存开始日期的Run类：
```java
public class Run{
private Date mStartDate;
public Run(){
mStartDate = new Date();
}
public Date getStartDate(){...
public void setStartDate(Date startDate...
public int getDurationSeconds(long endMillis..
}
```
使用地理位置更新UI：
```java
public class RunFragment extends Fragment{
private Button mStartButton,mStopButton;
private TextView mStartedTextView,mLatitudeTextView,mLongitudeTextView,mAltitudeTextView,mDurationTextView;

private RunManger mRunManager;
private Run mRun;
private Location mLastLocation;

// 实现一个继承自LocationReceiver的匿名内部类，重写相关方法
private BroadcastReceiver mLocationReceiver = new LocationReceiver(){
@Override
protected void onLocationReceived(Context context,Location loc){
mLastLocation = loc;
if(isVisible())
updateUI();
}

@Override
protected void onProviderEnabledChanged(boolean enabled){
// toast一下状态变化
}
};


@Override
public void onCreate(Bundle savedInstanceState){
super.onCreate(savedInstanceState);
setRetainInstance(true);
mRunManager = RunManager.get(getActivity());
}

@Override
public void onStart(){
super.onStart();
getActivity().registerReceiver(
mLocationReceiver,
new IntentFilter(RunManager.ACTION_LOCATION)
);
}

@Override
public void onStop(){
getActivity().unregisterReceiver(mLocationReceiver);
super.onStop();
}

@Override
public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
View = inflater.inflate(...
// 初始化控件，略

mStartButton.setOnClickListener(new View.OnClickListener(){
@Override
public void onClick(View v){
mRunManager.startLocationUpdates();
mRun = new Run();
updateUI();
}
});

mStopButton.setOnClickListener(new View.OnClickListener(){
@Override
public void onClick(View v){
mRunManager.stopLocationUpdates();
updateUI();
}
});

uodateUI();
return v;
}

// 使用从LocationManager中返回的Location对象中的数据更新UI
private void updateUI(){
boolean started = mRunManager.isTrackingRun();

if(mRun != null)
mStartedTextView.setText(mRun.getStartDate().toString());
int durationSeconds = 0;
if(mRun != null && mLastLocation != null){
durationSeconds  = mRun.getDurationSeconds(mLastLocation.getTime());
mLatitudeTextView.setText(Double.toString(mLastLocation.getLatitude());
mLongitudeTextView.setText(Double.toString(mLastLocation.getLongitude());
mAltitudeTextView.setText(Double.toString(mLastLocation.getAltitude());
}
...
mStartButton.setEnabled(!started);
mStopButton.setEnabled(started);

}

}
```