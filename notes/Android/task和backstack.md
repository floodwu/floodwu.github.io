# task和backstack

一个任务是用户在执行某种工作时所交互的Activity的集合．Activity们放置在一个栈("后退栈")中，按照打开的顺序排列．（这里的Activity不一定属于同一个应用，可以来自于不同的应用。Android可以把不同应用的Activity衔接在一起来达到无缝的用户体验）
当用户触摸在应用启动台中的图标(或一个home屏上的快捷方式)时，应用的任务就来到了前台．如果没有这个应用的已存在的任务(这个应用最近没有被使用)，那么一个新的任务被创建并且这个应用的"main"activity被作为栈的根activity打开．当当前的activity启动了另一个activity，新的activity被放置在栈顶并拥有焦点．先前的activity依然保存在栈中，但是停止了．当一个activity停止时，系统保存了它的用户界的当前状态．当用户后退按钮时，当前的activity被从栈顶弹出(activity被销毁了)并且先前的activity被恢复了．栈中的Activities永不会被重新排列，只是入栈或出栈—当被当前activity启动时就入栈，当用户使用后退按钮离开它时就出栈。如果用户继续后退，那么栈中的各activity被弹出来展示上一个，直到用户退到Home屏(或到达任务开始时运行的那个activity)．当所有的activitie都从棧种移除，任务就不再存在．
一个任务是一个有聚合力的单元，它可以在用户启动一个新的任务或回到home屏时被整体地移到后台．当位于后台时，任务中的所有的activitie都处于停止，但是任务的后退栈却保存完整—当任务被另一个任务取代时，仅仅是失去了焦点。两个任务：任务B到了前台，任务A于是被打入后台，伺机恢复：

![image](https://github.com/woojean/woojean.github.io/blob/master/images/java_16.png)



（多个任务可以同时存在于后台．然而，如果用户在同一时刻运行多个后台任务，系统可能会销毁后台activitie来釋放内存，从而导致activity状态的丢失．）
Android管理任务和后退栈的方式，如前面文章所述—通过把所有接连启动的activity放在同一个任务中并且是同一个后进先出的栈中—在大多数应用中工作得很好并且你无需关心你的activity如何与任务相关连或如何在后退栈中存在．然而，你可能决定要打破这种正常的行为．可能你想在你应用的activity启动时开始一个新的任务(而不是放置到当前栈中)；或者，当你启动一个activity，你想把已经运行的它的一个实例提到前台来(而不是创建一个新的实例放在后退栈的顶端)；或者，你希望当用户离开任务时，你的后退栈清除除了根activity以外所有的activity．
可以做这些事情，甚至更多事情，通过设置manifest中<activity>的属性和传到startActivity()的intent的flag．
在这一点上，你可以设置的最重要的<activity>属性有：
taskAffinity
launchMode
allowTaskReparenting
clearTaskOnLaunch
alwaysRetainTaskState
finishOnTaskLaunch

可以使用的最重要的intent　flag：
FLAG_ACTIVITY_NEW_TASK
FLAG_ACTIVITY_CLEAR_TOP
FLAG_ACTIVITY_SINGLE_TOP