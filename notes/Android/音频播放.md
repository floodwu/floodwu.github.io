# 音频播放

```java
public class AudioPlayer{
private MediaPlayer mPlayer;

public void stop(){
if(mPlayer != null){
mPlayer.release(); // 除非调用release()方法，否则MediaPlayer将一直占着音频解码硬件及其他系统资源。另有一个stop()方法，会使MediaPlayer实例进入停止状态，需要时再重新启动。对于简单的音频播放应用，应该直接release()
mPlayer = null;
}
}

public void play(Context c){
stop(); // 避免用户多次单击Play按钮创建多个MediaPlayer实例
mPlayer = MediaPlayer.create(c, R.raw.one_small_step);  // R.raw.one_small_step是raw文件夹下的一个音频资源
// 监听音频播放结束事件，结束后主动调用stop()方法，释放占用资源
mPlayer.setCompletionListener(new MediaPlayer.OnCompletionListener(){
public void onCompletion(MediaPlayer mp){
stop();
}
});
mPlayer.start();
}
}
```
此外，因为MediaPlayer运行在一个不同的线程上，因此一旦启动，即使其所在Fragment被销毁了，MediaPlayer仍可以不停地播放。因此，需要覆盖Fragment的onDestroy()方法：
```java
	// 在Fragment销毁时，释放音频播放资源
@Override
public void onDestroy(){
super.onDestroy();
mPlayer.stop();
}
```