# Redis底层实现-客户端

通过使用由I/O多路复用技术实现的文件事件处理器，Re-dis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。

```
struct redisServer {    
  // ...    
  list *clients;  // 一个链表，保存了所有客户端状态
  // ...
};
```

## 客户端属性
1.套接字描述符：客户端状态的fd属性记录了客户端正在使用的套接字描述符；
2.名字：使用CLIENT setname命令可以为客户端设置一个名字(默认没有名字)；
3.标志：客户端的标志属性flags记录了客户端的角色（主、从、伪客户端），以及客户端目前所处的状态（阻塞、正在执行事务等）；
4.输入缓冲区：用于保存客户端发送的命令请求；输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端。
5.命令与命令参数；
6.命令的实现函数：当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，它会将客户端状态的cmd指针指向这个结构；之后，服务器就可以使用cmd属性所指向的redisCom-mand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。
7.输出缓冲区：执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的（保存长度比较小的回复），另一个缓冲区的大小是可变的（保存长度比较大的回复）；
8.身份验证：用于记录客户端是否通过了身份验证；
9.时间：创建客户端的时间、与服务器最后一次进行互动的时间、输出缓冲区第一次到达软性限制（soft limit）的时间；

## 客户端的创建与关闭
如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。

一个普通客户端可以因为多种原因而被关闭：
1.客户端进程退出或者被杀死;
2.向服务器发送了带有不符合协议格式的命令请求;
3.成为了CLIENT KILL命令的目标;
4.当客户端的空转时间超过timeout选项设置的值时;(客户端本身是主从服务器、或者正在执行阻塞、订阅命令除外)
5.客户端发送的命令请求的大小超过了输入缓冲区的限制大小；
6.如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。

## Lua脚本的伪客户端
服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中。
只有服务器被关闭时，这个客户端才会被关闭。
详略。

## AOF文件的伪客户端
服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。