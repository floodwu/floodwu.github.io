# 结构体大小如何判断？

偏移量：偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。
由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：
1.结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）
2.结构体大小必须是所有成员大小的整数倍。
此外：`结构体变量的首地址能够被其最宽基本类型成员的大小所整除`；
因此`不同的定义顺序会影响到结构体的大小`：

```
  struct s{
	  char c;
	  int i;
	  char cc;
  };  // 大小为12

  struct s{
	  char c;
	  char cc;
    int i;
  };  // 大小为8
```
当结构体中的成员又是另外一种结构体类型时，只需要把其展开，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。
附：基本数据类型所占字节数如下
类型                  字节
char                  	1
short int             	2
int                   	2(16bit)/4(32bit)/4(64bit)
long                  	4(16bit)/4(32bit)/8(64bit)
指针变量              	4
float                 	4
double                	8
long long             	8
long double           	10
各种数据类型所占字节长度，主要是int型,long型和指针数据类型的差异。
int型数据，如果是16bit平台,则是2个字节，如果是32bit的，则占4个字节,64bit仍然是4字节。
long型数据，如果是16bit平台,则是4个字节，如果是32bit的，则占4个字节,64bit仍然是8字节。
指针型数据，比较特殊，大多是4个字节，只有在16bit平台，并且指针式段内寻址时才是2个字节。
另外注意：sizeof(表达式)这样的使用，sizeof是给出其操作数所需要占用的内存大小，在编译时就可以确定。因此不需要去计算表达式的值；
因此有：
```
int i = 3;
cout << sizeof(i++) << endl;
cout << i << endl;
```
输出4,3。i++根本没有执行。
![image](https://github.com/woojean/woojean.github.io/blob/master/images/img_3.png)